<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"powerlzy.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="相比到达的地方，同行的人更重要！">
<meta property="og:type" content="website">
<meta property="og:title" content="PowerLZY&#39;s Blog">
<meta property="og:url" content="https://powerlzy.github.io/page/27/index.html">
<meta property="og:site_name" content="PowerLZY&#39;s Blog">
<meta property="og:description" content="相比到达的地方，同行的人更重要！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://powerlzy.github.io/page/27/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/27/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PowerLZY's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">PowerLZY's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">本博客主要用于记录个人学习笔记（测试阶段）</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lzy"
      src="/images/cat_mac.jpg">
  <p class="site-author-name" itemprop="name">lzy</p>
  <div class="site-description" itemprop="description">相比到达的地方，同行的人更重要！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">267</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/PowerLZY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PowerLZY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3289218653@qq.com" title="E-Mail → mailto:3289218653@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/17HFC4S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/17HFC4S/" class="post-title-link" itemprop="url">AI安全（3）A survey on practical adversarial examples for malware classifiers</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-29 20:42:22" itemprop="dateCreated datePublished" datetime="2021-07-29T20:42:22+08:00">2021-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-21 13:38:06" itemprop="dateModified" datetime="2023-04-21T13:38:06+08:00">2023-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AI%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">AI安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>30 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3><span id="恶意软件的对抗样本综述"><strong>恶意软件的对抗样本综述：</strong></span></h3>
<h3><span id="asurvey-on-practical-adversarial-examples-for-malwareclassifiers"><strong>A
survey on practical adversarial examples for malware
classifiers</strong></span></h3>
<ul>
<li><p><strong>INTRODUCTION</strong></p></li>
<li><p><strong>BACKGROUND</strong></p>
<ul>
<li><strong>Machine learning for malware</strong></li>
<li><strong>Adversarial examples</strong></li>
</ul></li>
<li><p><strong>PRACTICAL ATTACKS</strong></p>
<ul>
<li><strong>Gradient-driven approaches</strong>
<ul>
<li><strong>Editing bytes and metadata</strong></li>
<li><strong>Code transformations</strong></li>
</ul></li>
<li><strong>Problem-driven approaches</strong>
<ul>
<li><strong>Editing bytes and metadata</strong></li>
<li><strong>Code transformations</strong></li>
</ul></li>
</ul></li>
<li><p><strong>DISCUSSION</strong></p>
<ul>
<li><p><strong>Challenges</strong></p>
<ul>
<li><p><strong>Threat models</strong></p></li>
<li><p><strong>Establishing baselines</strong></p></li>
</ul></li>
<li><p><strong>Possible research directions</strong></p>
<ul>
<li><strong>Defending against practical adversarial malware
examples</strong></li>
<li><strong>Relationships between obfuscation and adversarial
examples</strong></li>
<li><strong>Integration of static and dynamic analysis
techniques</strong></li>
</ul></li>
<li><p><strong>Other Survey and systematization of knowledge
papers</strong></p></li>
</ul></li>
<li><p><strong>CONCLUSION</strong></p></li>
<li><p><strong>ACKNOWLEDGMENTS</strong></p></li>
</ul>
<hr>
<h3><span id="abstract">ABSTRACT</span></h3>
<blockquote>
<p>基于机器学习的解决方案非常有助于解决处理大量数据的问题，例如恶意软件检测和分类。然而，人们发现，深层神经网络容易受到敌对示例的攻击，或故意干扰输入以导致错误标签的攻击。研究人员已经表明，可以利用此漏洞创建规避恶意软件样本。然而，许多提议的攻击并不生成可执行文件，而是生成特征向量。为了充分了解敌对示例对恶意软件检测的影响，我们回顾了针对生成可执行敌对恶意软件示例的恶意软件分类器的实际攻击。我们还讨论了该研究领域当前面临的挑战，以及改进建议和未来研究方向。</p>
</blockquote>
<h3><span id="1-introduction">1 INTRODUCTION</span></h3>
<blockquote>
<p>基于机器学习的解决方案非常有助于解决处理大量数据的问题，例如恶意软件检测和分类。然而，人们发现，深层神经网络容易受到敌对示例的攻击，或故意干扰输入以导致错误标签的攻击。研究人员已经表明，可以利用此漏洞创建规避恶意软件样本。然而，许多提议的攻击并不生成可执行文件，而是生成特征向量。为了充分了解敌对示例对恶意软件检测的影响，我们回顾了针对生成可执行敌对恶意软件示例的恶意软件分类器的实际攻击。我们还讨论了该研究领域当前面临的挑战，以及改进建议和未来研究方向。</p>
</blockquote>
<blockquote>
<p>然而，在2014年，Szegedy等人表明深层神经网络（DNN）容易受到对抗性攻击。Grosse等人进一步证明，这种漏洞也适用于基于机器学习的恶意软件检测器和分类器[29]。自这项工作以来，针对流行的基于机器学习的模型（如MalConv[62]）开发了许多攻击，但其中许多攻击并不实用。具体地说，许多攻击不会生成实际的恶意软件，而是生成一个特征向量，表示可能受干扰的恶意文件应该是什么样子以逃避检测。由于逆特征映射的困难，在给定特征向量的情况下生成可执行程序是不切实际的[59]。也就是说，特征提取过程不是唯一可逆的，也不能保证找到的解决方案将包含与原始恶意软件样本相同的程序逻辑。在这项工作中，我们回顾了针对基于机器学习的恶意软件分类器和检测器的实际攻击，或者针对这些导致可执行恶意软件的ML模型的攻击。在第2节中，我们介绍并定义了对抗性示例以及考虑这些示例的威胁模型。然后，我们在第3节回顾了恶意软件领域的实际对抗性示例研究。我们为该领域的未来方向提供建议，并在第4节讨论任何挑战。最后，我们在第5节总结。</p>
</blockquote>
<h3><span id="2-background">2 BACKGROUND</span></h3>
<h4><span id="21-machine-learning-formalware">2.1 Machine learning for
malware</span></h4>
<blockquote>
<p>检测恶意软件的经典方法是提取在受感染系统上发现的恶意样本的文件签名，并将其添加到签名数据库，也称为基于签名的检测[51]。对于这种方法，必须在整个样本以及相关样本的子集中搜索已知签名，因为恶意行为可以嵌入并交织在其他良性软件中。然而，由于基于特征码的检测依赖于捕获恶意软件样本，然后对其进行分析以生成新的特征码，因此它只能防御已知的攻击，并且只能尝试防御新的或模糊的恶意软件[67]。</p>
</blockquote>
<blockquote>
<p>基于机器学习的方法被提出作为这个问题的解决方案，因为它们能够预测新输入的标签。机器学习模型，如支持向量机（SVM）和均值聚类，用于恶意软件分类、检测和分析方法。在分类问题中，我们尝试将恶意软件样本分离为预定义的恶意软件系列。基于学习的模型基于由标记恶意软件样本组成的训练数据，推断新恶意软件样本的分类。检测问题可以看作是分类的一个子问题。对于检测，基于学习的模型用于在给定恶意和良性可执行文件时查找或检测恶意软件样本。由于检测是二进制分类的一种情况，基于学习的检测模型也可以称为分类器。分类和检测是训练数据标记时的监督算法。机器学习也可用于增强恶意软件分析。非监督聚类算法可用于学习恶意软件样本之间的新相似性[32]。此外，我们可以对基于学习的模型进行推理，以更好地理解恶意软件的恶意原因[7,20]。最近，随着深入学习方法研究的增加，研究人员开始利用卷积神经网络来分类和检测恶意软件[52,62]。</p>
</blockquote>
<h4><span id="211-static-features">2.1.1 Static Features</span></h4>
<blockquote>
<p>N-gram是目前流行的用于恶意软件分类和检测的功能。Kolter和Maloof提出使用各种机器学习模型，包括朴素贝叶斯分类器、决策树、支持向量机（SVM）和增强模型[37]，从PE恶意软件中提取最相关的=-克字节码进行分类。他们发现，除了分类之外，他们的模型还可以用于恶意软件检测.</p>
<p>McBoost是作为一种在搜索恶意软件时快速分析大量二进制文件的工具引入的，并采用了三步流程[58]。第一步是使用基于启发式的分类器和两个不同的基于n-gram的分类器的集合来检测打包器。如果检测到封隔器，则使用QEMU和动态分析对二进制文件进行解包。最后，使用一个单独的n-gram分类器来检测应该转发以进行额外分析的恶意软件。</p>
<p>Santos等人在2009年提出使用=-grams作为基于文件签名的方法的替代方案。在这样做的过程中，他们表明机器学习，特别是k近邻模型和=-grams可以成功地用于检测新的恶意软件样本[67]#-grams还与动态特征一起使用，以同时合并恶意软件的多个视图，而无需实际进行动态分析[5]。最近的工作，如为Kaggle
Microsoft恶意软件挑战提出的解决方案[64，78]，证明了字节和操作码=-grams的持续使用，分类准确率几乎为100%。</p>
<p>与使用操作码序列生成=gram类似，可以从程序的操作码跟踪中提取马尔可夫链。这样的马尔可夫链使用唯一的操作码作为其状态，并显示从一个操作码到另一个操作代码的转换概率。Anderson等人使用程序的马尔可夫链之间的相似性作为恶意软件检测的一个特征。类似地，Runwal等人[53]提出使用马尔可夫链之间的图相似性来检测嵌入式恶意软件，Shafiq等人[45]提出使用马尔科夫链来测量熵来检测恶意软件。</p>
<p>Jang等人介绍了BitShred，一种用于恶意软件分类和分析的工具[32]。BitShred使用位置敏感哈希对从样本中提取的=gram指纹进行哈希，以降低特征空间的维数。在k近邻模型中使用散列来对恶意软件样本进行聚类。此外，作者还表明BitShred可以用于改进以前的恶意软件检测和分类模型。例如，作者表明BitShred可以用于散列动态特征，例如Bayer等人[12]中生成的行为简档，以降低特征空间的维数。</p>
<p>Drebin对Android软件进行大规模静态分析，以提取硬件使用和请求、权限、API调用和网络信息等功能[7]。这些特征用于通过生成二进制指示符向量将样本映射到联合向量空间。这些二进制指示符向量被用作SVM的输入，SVM将样本标记为良性或恶意。重要的是，Drebin利用其模型的简单性，将模型的决策归因于特定的特征。这使得Drebin比基于复杂架构（如卷积神经网络）的恶意软件分类器和检测器更容易解释。</p>
<p><strong>【ember、+ 字节直方图】</strong></p>
<p><strong>【恶意软件图像】</strong>Nataraj等人提出使用恶意软件图像（二进制文件的黑白图像表示）来检测恶意软件[52]。从那时起，研究人员和商业杀毒软件都使用恶意软件图像来高精度检测恶意软件[23，26，78]。Nataraj等人使用恶意软件图像创建了一个特征向量，该向量将用作支持向量机的输入。然而，最近的工作也表明，使用原始图像作为卷积神经网络的输入是有效的[23，34，38，82]。</p>
<p><strong>【CFG控制流图】</strong>在开发静态功能方面也进行了研究，这些功能可以使用控制流图深入了解程序在运行时的行为。这项研究主要围绕构建控制流图和使用图匹配技术来检测恶意软件[13，16]。Ma等人在使用控制流图时采取了类似的方法，但提取了一系列API调用，试图模拟动态分析[46]。</p>
<p><strong>【Malconv】</strong>Raff等人采用了一种不同的方法，并提出了一种卷积神经网络（CNN）模型，该模型将整个二进制作为输入[62]。特别地，所提出的模型MalConv查看文件的原始字节以确定恶意。MalConv借鉴了神经网络的研究，从长序列中学习更高级别的表示，并依赖于CNN捕捉高级别局部不变量的能力。MalConv通过提取文件的：字节来工作。这些：用0G5字节填充字节，以创建大小为3的特征向量。如果：&gt;3，则使用文件的前3个字节，而不使用任何额外的填充。通过与CNN联合学习的嵌入，将这个3长度的向量映射到固定长度的特征向量。</p>
</blockquote>
<h4><span id="212-dynamic-features">2.1.2 Dynamic Features</span></h4>
<blockquote>
<p>动态分析是一种通过在实时环境中运行二进制文件来分析二进制文件的技术。此环境通常是一个安全的沙盒或测试环境，如CWSandbox[80]和cuckoo
sandbox[1]，以确保主机的安全。通常，这些环境都经过大量检测，以便记录已执行和加载的代码以及对内部文件、目录和设置所做的任何更改。这些记录的特征称为动态特征。</p>
<p>提取动态特征的最常用方法是记录系统和API调用的频率和顺序[3,21]。例如，<strong>Accessminer</strong>在动态分析期间记录系统调用trace，并生成每个样本的n-grams表示[42]。Accessminer将一个样本标记为恶意软件，如果该样本相对于某个预定义阈值包含多个“恶意”=-grams实例。动态分析的另一个好处是可以捕获和分析网络流量和通信，如Taintdroid[22]所述。这些功能还可用于为其他功能生成不同的恶意软件表示，或降低维数。</p>
<p>Bailey等人提出了一种用于恶意软件自动分类和分析的动态分析工具，该工具使用动态分析来记录生成的新进程、修改的任何文件、修改的任何注册表项以及网络访问和使用情况[11]。这些记录的特征用于创建amalware指纹，该指纹关注的是状态变化，而不是代码序列。这些动态特征用于使用标准化压缩距离度量创建恶意软件样本的层次聚类。</p>
<p>Rieck等人使用CWSandbox进行动态分析，类似于Bailey等人的工作，但是，使用字符串从结果文本报告中提取特征[63]。字符串频率与SVMto一起用于分类恶意软件样本。作者还表明，他们的方法可以通过引入新的“未知”类而扩展到恶意软件检测，而无需在训练集中引入良性样本。</p>
<p>拜耳等人通过使用污染分析来了解可执行文件如何使用来自操作系统的信息，从而扩展了之前的工作[12]。此外，所提出的方法使用操作系统对象和操作的抽象来创建行为概要。作者认为，由于能够在没有虚假系统调用的情况下对程序进行抽象或推理，因此抽象对规避更具鲁棒性。然后，将提取的行为特征与基于位置敏感哈希的聚类算法结合使用，对恶意软件样本进行分类。</p>
<p>程序的行为也可以建模为图，如Kolbitsch等人的工作[35]。作者扩展了malspec[18]，并使用systemcalls生成了程序的行为图。每个行为图都是一个有向无环图，其中节点是系统调用，有向边表示信息流。使用图匹配和相似性度量对已知恶意软件样本进行检测。</p>
</blockquote>
<h4><span id="22-adversarial-examples">2.2 Adversarial examples</span></h4>
<blockquote>
<p>定义-&gt;图片等领域的限制条件-&gt;常用方法介绍-&gt;</p>
<p>在[72]中首次引入了对抗性示例的概念，并在[28]中进行了扩展。假设5是敌方计划攻击的目标分类器。这个分类器可以表示为一个函数<span class="math inline">\(f(x)\)</span>，它接受一个输入并给它分配一个标签。通过用X扰动原始输入f生成对抗性示例x′5，使5（G）≠
5（G′）。</p>
<p>有很多方法可以找到X，最流行的是快速梯度符号法[28]和卡里尼·瓦格纳（C&amp;W）攻击[15]用于白盒模型，而<strong>替代模型攻击</strong>[55]用于黑盒模型。大多数攻击都会使用损失函数相对于输入的梯度来找到输入必须扰动的方向，以使输出发生想要的变化。然后使用该方向来查找X。我们在附录中简要讨论了这些攻击和其他攻击。</p>
</blockquote>
<h4><span id="221-threat-models">2.2.1 Threat models.</span></h4>
<p>威胁模型是研究中对攻击者能力和已知信息的明确定义。在本节中，我们定义了机器学习领域中广泛使用的<strong>白盒</strong>和黑盒威胁模型。威胁模型由三部分组成：<strong>威胁向量和威胁面、知识和能力</strong>。</p>
<p><strong>威胁向量和威胁面</strong>：威胁向量和威胁面表示攻击者与目标模型交互的方式。威胁向量是攻击者可以用来攻击模型的允许输入空间和位置。威胁面或攻击面是所有此类威胁向量的集合。通常情况下，威胁向量和威胁面由机器学习模型的输入和输出组成。然而，攻击者进入这些表面的能力进一步受到其知识和能力的限制。</p>
<p><strong>Knowledge:</strong>攻击者的知识表示我们假设对攻击者了解<strong>目标模型的内容</strong>。然后，攻击者利用这些知识构建并发起攻击。在对抗式机器学习中，可以将攻击者的知识概括为白盒和黑盒模型。在白盒模型中，假设攻击者对系统有完全的了解。因此，我们假设攻击者可以完全访问目标机器学习模型（带有权重和参数）以及用于训练模型的数据。在黑箱模型中，假设攻击者只能访问模型的输入和输出。因此，攻击者不知道模型的内部或训练过程（例如，从可执行文件和梯度信息中提取的特征）。<strong>攻击者也可以建模为灰盒模型。在灰箱模型中，攻击者可以访问模型的输入、输出和一些其他信息（模型使用的特征）等。</strong></p>
<blockquote>
<p>本研究中回顾的作品与攻击者的知识并不完全一致。具体地说，有些作品可能假设攻击者还可以访问恶意软件源代码，而其他作品则没有。在第3节中，将明确指出每部作品与对抗性知识的一般定义之间的偏差</p>
</blockquote>
<p><strong>能力</strong>：攻击者的能力表示我们假设对攻击者可以发动的攻击类型。在对抗样本中，我们可以指定攻击者将使用的<strong>攻击算法</strong>。在恶意软件领域的对抗性示例中，攻击者的能力受到其知识的限制。例如，通过访问恶意软件源代码，攻击者可以轻松地在编译时应用特定的转换。但是，如果没有源代码，这将变得更加困难。</p>
<h4><span id="222-adversarial-malwareexamples">2.2.2 Adversarial malware
examples</span></h4>
<blockquote>
<p>大多数对抗性示例研究是使用自然图像数据集进行的，如MNIST、CIFAR10和ImageNet。然而，有必要考虑一组<strong>允许干扰攻击者恶意软件实例功能的允许扰动</strong>。</p>
</blockquote>
<blockquote>
<p>对于自然图像，像素值会受到干扰以生成一个对抗性示例。只要得到的像素值在0到255之间，像素值的任何负数或正数变化都会导致图像发生轻微变化。可执行程序可以用类似的方式表示。根据定义，二进制文件的每个字节都在0x00和0xff之间。每个字节的十六进制表示可以转换为其十进制等效值（0到255之间）。在此状态下，可以使用相同的方法扰动字节和像素。然而，对字节的任意扰动可能不会产生有效的可执行文件，因为可执行程序存在于离散空间中。考虑改变可执行文件的一个字节的简单情况。如果字节来自ELF的.text部分，则新修改的字节可能会通过更改函数参数或导致错误指令而中断程序的功能。因此，将对抗性示例技术应用于恶意软件领域需要特别注意二进制文件的构造。最重要的是，对抗性恶意软件示例必须包含与原始恶意程序相同的恶意程序逻辑和功能。</p>
</blockquote>
<p><strong>对抗性恶意软件示例是一种直接的威胁，因为它们是规避性的恶意可执行文件，可以利用许多商业防病毒软件对混淆和变异的持久漏洞</strong>[61]。<strong>这将实际的恶意软件示例与恶意特征向量区分开来。虽然恶意特征向量也可以逃避检测或分类，但没有直接威胁</strong>。<strong>Pierazzi等人认为，在给定敌对特征向量的情况下生成可执行文件是困难的，并将其称为反向特征映射问题。逆特征映射问题没有唯一的解决方案</strong>。在n-gram分类器的简单情况下，可以通过多种方式添加n-gram。但是，它们并不能保证产生与原始恶意软件样本包含相同程序逻辑或可执行性的可执行文件。当处理黑盒模型时，这个问题变得更加困难，因为攻击者不知道分类器的输入和内部结构。Pierazzi等人解释说，实际的恶意软件示例有两种方法可以避免这种情况：</p>
<p>（1）一种梯度驱动方法，其中代码扰动对梯度的影响是近似的，并用于遵循梯度的方向；</p>
<p>（2）一种问题驱动方法，其中突变首先随机应用，然后再开始一种进化的方法。</p>
<h4><span id="3-practical-attacks">3 PRACTICAL ATTACKS</span></h4>
<blockquote>
<p>在本节中，我们将回顾对抗性恶意软件示例文献中的实际攻击，或导致可执行二进制文件的攻击。在表3中，我们概述了本工作中的实际攻击记录（1）如果工作是针对使用静态功能的恶意软件分类器评估的（2）如果工作是针对使用动态功能的恶意软件分类器评估的，（3）评估中的targetmodels，（4）攻击中的可用转换，（5）该方法是梯度驱动还是问题驱动。</p>
</blockquote>
<blockquote>
<p>我们使用[59]中的术语，并按照第2.2.2节中定义的梯度驱动和问题驱动方法组织我们的审查。对于这两种方法，我们进一步将文献组织为第3.1.1和3.2.1节中主要编辑字节和元数据的攻击，以及第3.1.2和3.2.2节中利用代码转换的攻击。</p>
</blockquote>
<figure>
<img src="image-20210415140727064.png" alt="image-20210415140727064">
<figcaption aria-hidden="true">image-20210415140727064</figcaption>
</figure>
<ul class="task-list">
<li><p><input type="checkbox" checked>[65] Generic Black-Box
End-to-End Attack Against State of the Art API Call Based Malware
Classifiers</p></li>
<li><p><input type="checkbox">[6] Learning to Evade Static PE Machine
Learning Malware Models via <strong>Reinforcement
Learning</strong></p></li>
<li><p><input type="checkbox" checked>[36] <strong>Adversarial
Malware Binaries: Evading Deep Learning for Malware Detection in
Executables</strong></p></li>
<li><p><input type="checkbox" checked>[39] <strong>Deceiving
End-to-End Deep Learning Malware Detectors using Adversarial
Examples</strong></p></li>
<li><p><input type="checkbox" checked>[20] Explaining
Vulnerabilities of Deep Learning to Adversarial Malware
Binaries</p></li>
<li><p><input type="checkbox">[57] Generation &amp; Evaluation of
Adversarial Examples for Malware Obfuscation.</p></li>
<li><p><input type="checkbox" checked><strong>[68]</strong>
<strong>Automatic Generation</strong> of Adversarial Examples for
Interpreting Malware Classifiers</p></li>
<li><p><input type="checkbox">[83] Malware Detection in Adversarial
Settings: Exploiting Feature Evolutions and Confusions in Android
Apps.</p></li>
<li><p><input type="checkbox">[40] Deceiving Portable Executable
Malware Classifiers into Targeted Misclassification with Practical
Adversarial Examples</p></li>
<li><p><input type="checkbox" checked>[59] <strong>Intriguing
Properties of Adversarial ML Attacks in the Problem Space (2020
S&amp;P)</strong></p></li>
<li><p><input type="checkbox">[24] <strong>HideNoSeek: Camouflaging
Malicious JavaScript in Benign ASTs (2019 CCS)</strong></p></li>
</ul>
<h4><span id="31-gradient-driven-approaches">3.1 Gradient-driven approaches</span></h4>
<h4><span id="311-editing-bytes-andmetadata">3.1.1 Editing bytes and
metadata</span></h4>
<blockquote>
<p>创建实际恶意软件示例的一种流行方法是在二进制文件中的未使用空间中添加或更改字节。此外，这可以在头中完成，以在不影响功能的情况下更改头元数据。在本节中，我们将回顾使用这种类型转换的拟议攻击。因为这些攻击集中在未使用或“不重要”（用于执行）字节上，所以它们不需要源代码来生成规避恶意软件样本。然而，除了GADGET[65]之外，这些攻击仍然是白盒攻击，因为它们需要完全访问目标模型来计算梯度。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox" checked>##### <strong>[65] Generic
Black-Box End-to-End Attack Against State of the Art API Call Based
Malware Classifiers</strong></li>
</ul>
<p>2018年，Rosenberg等人提出了GADGET，这是一个利用DNN之间对抗样本的可转移性将PE恶意软件转化为规避变体的软件框架[65]。提议的攻击假设一个黑盒威胁模型，无法访问恶意软件源代码。但是，攻击假设目标模型将一系列API调用作为输入。为了生成对抗性示例，GADGET构建了一个代理或替代模型，该模型使用Papernot等人提出的基于Jacobian的数据集扩充进行训练，作为对自然图像分类器的攻击[55]。数据集扩充创建合成输入，帮助替代模型更好地逼近目标黑盒模型的决策边界。这增加了攻击可转移性的概率，因为替代模型和目标模型都将学习到类似的分布。一旦替代模型得到训练，通过向原始恶意软件的API调用序列添加虚拟API调用，生成对抗性恶意软件示例。作者将这些伪API调用称为语义NOP作为所选的API调用，或者它们相应的参数对原始程序逻辑没有影响。需要注意的是，作者只添加API调用，因为删除API调用可能会破坏程序的功能。</p>
<blockquote>
<p>算法介绍：假设原始API调用序列是一个数组F0，其中每个索引都是9∈
[0，=]包含一个API调用。此过程的每个迭代8都返回一个新数组F8。在迭代8中，一个API调用3被添加到F8中−1在某个指数9处，将其推向梯度指示的方向，该梯度对替代模型的决策影响最大。这将导致F8，其中F8[9]=3和F8[9+1::]=F8−1[9:]因为索引9之后的前一序列中的所有API调用基本上都是“向后推”的。</p>
</blockquote>
<p>这种通过添加伪API调用来干扰输入的方法确保了功能不会被破坏。为了从这个对抗性API调用序列生成实际的可执行文件，GADGET实现了一个钩住所有API调用的包装器。钩子根据需要从敌对API调用序列调用原始API和虚拟API。这些钩子确保生成的敌对恶意软件示例在某种意义上保持原始样本的功能和行为。GADGET根据定制模型进行评估，包括logistic回归、递归神经网络（RNN）、全连接深度神经网络（DNN）、卷积神经网络（CNN）、支持向量机、增强决策树和随机森林分类器。作者还表明，他们的攻击产生的恶意软件能够避开使用静态特征（如可打印字符串）的分类器。</p>
<ul class="task-list">
<li><input type="checkbox" checked><strong>[36] Adversarial Malware
Binaries: Evading Deep Learning for Malware Detection in
Executables</strong></li>
</ul>
<blockquote>
<p>Kolosnjaji等人提出了一种针对MalConv的白盒攻击，该攻击通过迭代操作文件末尾的填充字节来生成对抗性PE恶意软件示例[36]。尽管作者指出PE中任何位置的字节都可以更改，但它需要对文件体系结构的精确了解，因为简单的更改可能会破坏文件完整性。因此，提议的攻击只关注字节附加。作者面临的一个挑战是由于其嵌入层，MALCONV的不可微性。为了避免这种情况，作者建议计算目标函数相对于嵌入表示I的梯度，而不是输入。每个填充字节都替换为最靠近第6行的嵌入式字节&lt;（[）=I+[=其中=是标准化的渐变方向。但是，如果第6行（[）上的“&lt;”投影未与=”对齐，则选择下一个最近的嵌入字节。通过仅更改文件末尾的填充，提议的攻击不会更改程序逻辑或原始almarware示例的功能。<strong>但是，这也限制了攻击允许的干扰总数</strong>。如第2节所述，MalConv从二进制文件中最多提取3个字节。如果二进制文件的大小小于3，则提取的：字节数为（3−
:)
附加到它的0xff填充字节。这意味着提议的攻击受到原始恶意软件样本大小的限制。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox" checked><strong>[39] Deceiving
End-to-End Deep Learning Malware Detectors using Adversarial
Examples</strong></li>
</ul>
<blockquote>
<p>Kruek等人[39]扩展了Kolosnjaji等人的工作，提出了一种方法，用于在敌对示例嵌入的情况下重建PE恶意软件样本。作者发现，从扰动嵌入重建字节∗
像我一样经常是不平凡的∗ 可能会与我失去相似之处∈ /
用于学习“将填充字节映射到嵌入字节的函数。因此，他们提出了一种新的损失函数，以确保扰动嵌入∗
将接近于实际的嵌入”。这是通过在生成的嵌入和“”之间的损失函数中引入距离项来实现的。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox" checked><strong>[20] Explaining
Vulnerabilities of Deep Learning to Adversarial Malware
Binaries</strong></li>
</ul>
<blockquote>
<p>Demetrio等人提出将特征属性作为一种可解释的机器学习算法，以理解机器学习模型做出的决策[20]。特征归因基于Sundararajan等人于2017年引入的一种称为积分梯度的技术[71]。Demetrio等人观察了输入可执行文件的每个字节的属性，发现MalConv对二进制文件的PE头部分的权重很大。作者利用了这一漏洞，提出了针对MalConv的白盒攻击，该攻击只改变恶意软件样本头中的字节。此攻击使用了与[36]中相同的算法，但干扰了头中未使用和可编辑的字节，而不是在文件末尾填充。</p>
</blockquote>
<h4><span id="312-code-transformations">3.1.2 Code transformations</span></h4>
<blockquote>
<p>上面的许多工作都指出，只要程序的功能和恶意行为没有改变，建议的方法就可以用来改变恶意二进制文件的.text部分。以下攻击利用模糊处理技术更改.text部分。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox"><strong>[57] Generation &amp; Evaluation of
Adversarial Examples for Malware Obfuscation.</strong></li>
</ul>
<blockquote>
<p>Park等人提出了一种白盒攻击，该攻击利用语义NOP（如mov
eax、x86汇编中的eax）来创建对抗性PE恶意软件示例[57]。作者攻击了使用可执行文件[52]的图像表示作为输入的卷积神经网络。可执行文件的图像表示将每个字节视为一个像素，并使用字节的十进制值作为像素值。攻击提出了两个步骤。首先，使用FGSM生成对抗性示例。此对抗性示例是一个映像，可能与原始恶意软件示例的功能或恶意行为不同。在第二步中，原始恶意软件样本和生成的敌对图像被用作动态规划算法的输入，该算法使用LLVM过程插入语义NOP。与[65]中添加API调用以类似于生成的对抗性特征向量的方式类似，动态规划算法添加了语义NOP，使得生成的恶意软件样本的图像表示类似于步骤1中生成的敌对图像。作者继续证明，由于敌对示例和干扰的可转移性，这种攻击可以用于黑盒模型[50，
55].
使用一个简单的2层CNN作为替代模型，作者生成了对抗性恶意软件示例，这些示例也避开了黑盒模型，其中一个是使用字节级特征的梯度增强决策树。作者还提到，考虑到恶意软件的源代码，他们的攻击效果最好。然而，在缺乏源代码的情况下，可以使用二进制翻译和重写技术插入必要的语义NOP。需要注意的是，引入这些技术也会引入二进制提升过程中的工件。</p>
</blockquote>
<h4><span id="32-problem-driven-approaches">3.2 Problem-driven approaches</span></h4>
<blockquote>
<p>在本节中，我们将回顾采用问题驱动方法的对抗性恶意软件示例算法。与第3.1节类似，我们使用攻击的可用转换进一步组织审查。问题驱动的方法不需要白盒访问梯度信息的目标。因此，以下方法是黑盒攻击。</p>
</blockquote>
<h4><span id="321-editing-bytes-andmetadata">3.2.1 Editing bytes and
metadata</span></h4>
<ul class="task-list">
<li><input type="checkbox"><strong>[6] Learning to Evade Static PE
Machine Learning Malware Models via Reinforcement Learning</strong>
<ul>
<li>Anderson</li>
</ul></li>
</ul>
<blockquote>
<p>其中，Anderson等人提出了一个具有强化学习代理集[6]。RL代理因产生逃避检测的恶意软件的行为而获得奖励。通过这个游戏，代理学习创建规避恶意软件的策略。提议的攻击利用以下不会改变原始程序逻辑的操作：</p>
<ul>
<li>向导入表中添加从未使用过的函数</li>
<li>更改节名</li>
<li>创建新的但未使用的部分</li>
<li>向节中未使用的空间添加字节</li>
<li>删除签名者信息</li>
<li>更改调试信息</li>
<li>打包或解包二进制文件</li>
<li>修改标题</li>
</ul>
<p>使用这些操作，RL代理能够改变诸如PE元数据、人类可读字符串和字节直方图等特性。在培训阶段发生多达50000个突变后，RL代理根据梯度增强决策树模型进行评估，结果表明该模型能够成功地对恶意软件进行分类[78]。作者指出，他们的对抗性例子应该是功能性的。然而，他们发现，他们的攻击破坏了某些Windows
PE的功能，这些PE使用了不太常见的文件格式或违反PE标准的混淆技巧。作者声称，通过确保二进制检测框架能够正确解析原始恶意软件样本，可以简单地解决这一问题。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox"><strong>[68] Automatic Generation of
Adversarial Examples for Interpreting Malware Classifiers</strong></li>
</ul>
<blockquote>
<p>Song等人在生成对抗性恶意软件示例时采用了不同的方法[68]。提议的攻击随机生成一系列宏操作，并将其应用于原始PE恶意软件样本。重复此操作，直到生成的转化恶意软件逃避检测。一旦恶意软件样本不可信，不必要的宏操作将从应用于其的宏操作序列中删除。这样做是为了最大限度地减少由于某些混淆技巧而意外破坏功能的可能性。剩余的宏操作随后被分解为微操作，以获得更详细的转换跟踪，从而生成恶意软件示例。我们建议读者阅读原始文章，以获得关于每个宏和微操作的更多详细信息，但是，我们在此简要描述它们。宏操作包括以下内容：</p>
<ul>
<li>将字节追加到二进制文件的末尾</li>
<li>将字节追加到节末尾未使用的空间</li>
<li>增加一个新的部分重命名</li>
<li>注销已签名证书</li>
<li>删除调试信息</li>
<li>将标头中的校验和值归零</li>
<li>用语义等价的指令替换指令</li>
</ul>
<p>其中一些宏操作可以分解为一系列较小的操作，称为微操作。例如，追加字节的操作可以分解为一次添加一个字节的序列。作者声称，通过分解每个宏操作，可以深入了解特定操作导致逃避的原因。提出的方法不是利用诸如FGSMor
C&amp;Wattack之类的对抗性示例生成算法，而是试图对机器学习模型提供一种更易于解释的攻击。该方法针对商业防病毒软件进行了评估，并被发现对包含静态和动态分析的分类器有效。</p>
</blockquote>
<h4><span id="322-code-transformation">3.2.2 Code transformation</span></h4>
<ul class="task-list">
<li><input type="checkbox"><strong>[83] Malware Detection in
Adversarial Settings: Exploiting Feature Evolutions and Confusions in
Android Apps.</strong></li>
</ul>
<blockquote>
<p>Yang等人提出了两种对恶意软件样本的攻击，以逃避机器学习模型的检测，但没有使用机器学习算法[83]。建议的进化攻击不是针对错误分类，而是基于变异的上下文特征（由时间特征、区域设置特征和依赖性特征组成）模仿Android恶意软件的自然进化[84]。这是通过混淆工具OCTOPUS自动化这些变异策略并大规模使用它们来识别目标分类器上的“盲点”来实现的。恶意软件家族被组织成系统进化树[69]，以分析家族内的共同特征和不同特征。然后根据可行性和频率对每个特征变异进行排序，并进行排序。然后，顶级G突变用于生成新的恶意软件变体。作者还提出了一种特征混淆攻击来补充进化攻击。特征混淆攻击的目标是修改恶意软件样本，使某些特征与良性样本的特征相似。攻击开始于收集一组混乱的功能，或恶意软件和良性样本共享的一组功能。对于混淆特征集中的每个特征，记录包含该特征的良性和恶意样本数。如果存在更多良性样本，则该特征将添加到“目标特征”列表中。然后，攻击会变异恶意软件样本，使其包含已发现的目标特征，从而增加规避的可能性。针对基于Android学习的恶意软件分类器AppContext[84]和Drebin[7]对提出的方法进行了评估。需要注意的是，虽然攻击不需要白盒访问目标模型，但它确实假设（1）恶意软件源代码和（2）模型使用的功能知识。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox"><strong>[40] Deceiving Portable Executable
Malware Classifiers into Targeted Misclassification with Practical
Adversarial Examples</strong></li>
</ul>
<blockquote>
<p>Kucuk等人认为，敌对恶意软件示例必须避开基于静态和动态机器学习的分类器[40]。因此，他们提出了一种针对PE恶意软件的攻击，利用虚假控制流混淆和API混淆来逃避使用静态和动态特征的模型的检测。应用的控制流混淆基于LLVM-Obfuscator[33]。LLVM模糊器通过使用不透明谓词和从不使用任意指令执行伪基本块，在LLVM-IR级别改变程序的控制流。使用差分分析，作者找到了最佳控制流混淆和伪基本块，以生成一个恶意软件示例。这会干扰静态特性，例如n-grams、操作码频率和导入的API调用。该攻击使用一种遗传算法来最小化所需目标类别的频率特征向量与恶意软件样本之间的Kullback-Leibler（KL）散度。为了规避基于动态API调用的恶意软件分类器，作者使用相同的遗传算法确定哪些API调用必须进行模糊处理，然后使用[70]中介绍的技术进行模糊处理。此外，再次使用相同的遗传算法确定应添加到原始恶意软件样本中的其他API调用序列，类似于[65]所采用的方法。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox" checked><strong>[59] Intriguing
Properties of Adversarial ML Attacks in the Problem Space (2020
S&amp;P)</strong></li>
</ul>
<blockquote>
<p>Pierazzi等人提出了一种针对Android恶意软件分类器Drebin的黑盒攻击[59]。作者提出了一种问题空间方法，使用<a href="Opaque%20predicates%20are%20a%20commonly%20used%20technique%20in%20program%20obfuscatio">不透明谓词</a>反复插入良性代码块，以改变Drebin提取的特征。这些良性代码块是在攻击之前通过分析训练集中的样本来初始化的，这些样本用于识别导致负面或良性标签的代码序列。攻击受到可行性检查的限制，以避免过度转换，从而增加怀疑。此外，使用FlowDroid[8]和So烟灰[75]插入代码块，以最小化副作用或伪影。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox"><strong>[24] HideNoSeek: Camouflaging
Malicious JavaScript in Benign ASTs (2019 CCS)</strong></li>
</ul>
<blockquote>
<p>HideNoSeek与其他应用代码转换的攻击不同，它试图通过将抽象语法树（AST）转换为良性来隐藏恶意JavaScript[24]。攻击开始于构建恶意和良性文件的AST，以检测两个类之间共享的子AST或子图。为了创建对抗性示例，HideNoSeek利用随机化、数据模糊和不透明结构插入良性子AST。该攻击还可以重写现有的AST，使其看起来是良性的。这些攻击是在黑盒模型中针对基于Zozzle的定制分类器进行的，Zozzle是一种使用从JavaScript
AST中提取的特征的贝叶斯分类器[19]。</p>
</blockquote>
<h3><span id="4-discussion">4 DISCUSSION</span></h3>
<h4><span id="41-challenges">4.1 Challenges</span></h4>
<blockquote>
<p>首先，还应注意的是，我们绝不会减少或淡化恶意软件领域中不产生可执行恶意软件样本的对抗性示例研究的贡献。然而，我们认为，为了在现实的敌对环境中更好地构建提议的攻击，有必要扩展或包括关于扩展攻击以产生可执行恶意软件样本的可能方法的讨论。随着对抗性示例研究的快速发展，有必要充分了解这些攻击如何过渡到恶意软件检测和网络安全领域。全面开发或概念验证攻击也有助于开发针对敌对恶意软件样本的健壮模型。</p>
</blockquote>
<h4><span id="411-threat-models">4.1.1 Threat models</span></h4>
<blockquote>
<p>这一研究领域的一个挑战是威胁模型的不一致性。我们认为有必要明确定义每项研究中考虑的威胁模型，以便更好地理解攻击的局限性以及作者所做的任何假设。除了对抗性示例文献中使用的一般白盒和黑盒威胁模型外，我们建议包括（1）对源代码可用性的假设，以及（2）由于时间或计算限制对对手进行攻击的可行性。与Papernot等人[55]的工作类似，观察改变对手资源的效果会很有趣，例如，限制目标模型允许的查询数量，或为对手攻击的每次迭代产生成本。</p>
</blockquote>
<h4><span id="412-establishing-baselines">4.1.2 Establishing baselines</span></h4>
<blockquote>
<p>另一个挑战是建立基线和基本真相。在整个审查的论文中，没有一致的数据集，也没有一致的（ML或商业）恶意软件分类器。尽管本次调查中考虑的所有作品都对顶级分类词有很高的漏检率，但我们无法公平地对它们进行评估。在提议的攻击和它们的实验评估之间保持一致将允许更好地比较攻击。然而，如[76]所示，维护一致的数据集和恶意软件分类器以及进行公平评估都会带来自身的挑战。这也将有助于扩展Quarta
et.al.提出的评估，Quarta
et.al.使用他们的框架crAVe表明，简单地混淆或变异恶意软件样本就足以逃避检测，因为并非所有反病毒软件都进行某种形式的动态分析。</p>
</blockquote>
<h4><span id="413-dataset">4.1.3 Dataset</span></h4>
<blockquote>
<p>数据集：虽然将旧恶意软件转换为规避恶意软件确实显示了恶意软件检测中的漏洞，但排除较新的恶意软件样本会带来概念漂移(concept
drift.)的风险。例如，如果恶意软件针对新平台进行了大幅更改，则旧的恶意软件数据集可能无法正确反映恶意功能和行为。良性程序样本也是如此。传统上，良性样本是从新安装的操作系统中刮取的。然而，目前尚不清楚这些预装程序是否反映了用户下载和/或扫描恶意行为的程序。</p>
</blockquote>
<h4><span id="414-malware-classifiers">4.1.4 Malware classifiers</span></h4>
<blockquote>
<p>目前尚不清楚哪种恶意软件分类器最适合评估攻击。正如Song等人所说，假设模型的任何先验知识也是不现实的。我们认为目前没有也不会有一个一致的恶意软件检测模型基线，因为该领域的研究仍在增长。然而，我们建议未来的工作在黑盒威胁模型下评估他们对多分类器的攻击。这将有助于理解攻击在决策过程中使用不同特征的各种检测模型之间的可转移性。</p>
</blockquote>
<h4><span id="42-possible-researchdirections">4.2 Possible research
directions</span></h4>
<h4><span id="421defending-against-practical-adversarial-malware-examples">4.2.1
Defending against practical adversarial malware examples</span></h4>
<blockquote>
<p>一些研究已经在评估恶意软件领域中对抗性训练的使用[4,43]。然而，鲁棒机器学习研究包括许多其他防御策略，如平滑[2]和随机化[60]。目前尚不清楚这些方法是否会转移和防御对抗性恶意软件示例。</p>
</blockquote>
<h4><span id="422relationships-between-obfuscation-and-adversarial-examples">4.2.2
Relationships between obfuscation and adversarial examples</span></h4>
<blockquote>
<p>混淆和敌对示例有一个共同的目标：逃避检测。此外，大多数实用的对抗性恶意软件示例算法都将流行的混淆策略纳入了攻击中。一个可能的研究问题是评估使用更先进的模糊处理方法（如虚拟化）生成对抗性示例的可行性。目前还不清楚对抗性恶意软件示例与更传统的恶意软件规避技术（如Bulazel等人[14]中总结的技术）相比有什么好处。在Song等人[68]和Demetrio等人[20]的工作基础上扩展对抗性恶意软件示例的可解释性，并利用这一点进一步开发规避转换，这也是很有趣的。</p>
</blockquote>
<h4><span id="423integration-of-static-and-dynamic-analysis-techniques">4.2.3
Integration of static and dynamic analysis techniques</span></h4>
<blockquote>
<p>许多经过审查的工作都假设在测试之前没有对恶意软件样本进行高级分析。然而，情况并非总是如此。例如，预处理步骤可用于使用除臭框架（如SATURN[25]）对[57]和[40]产生的规避恶意软件样本进行除臭。未来的攻击和防御工作将考虑使用分类和检测管道，而不是单一的机器学习模型或商业防病毒产品，这将是一件有趣的事情。</p>
</blockquote>
<h4><span id="43-othersurvey-and-systematization-of-knowledge-papers">4.3 Other
Survey and systematization of knowledge papers</span></h4>
<blockquote>
<p>在本节中，我们将对涉及相关主题的知识论文进行其他调查和系统化。袁等人。深入学习的对抗性攻击和防御调查[86]。它们还提供了可以使用对抗性攻击的应用程序和问题域。与这项工作类似，Maiorca等人对基于机器学习的PDF恶意软件检测系统的对抗性攻击进行了调查[48]。Bulazel和Yener调查动态恶意软件分析规避和缓解策略[14]。Ye等人综述了数据挖掘技术在恶意软件检测中的应用[85]。Ucci等人利用机器学习对恶意软件分析进行了调查[74]。最后，van
der
Kuowe等人调查了为公平准确地评估安全性研究而必须考虑的常见基准测试缺陷。</p>
</blockquote>
<h3><span id="5-conclusion">5 CONCLUSION</span></h3>
<blockquote>
<p>我们对恶意软件领域中的实际对抗性示例进行了调查。随着基于机器学习的解决方案开始在工业界和学术界被采用，对抗性示例及其对网络安全领域的影响的研究非常重要。我们希望这项调查将为这一领域的未来研究提供有用的信息。</p>
</blockquote>
<hr>
<h4><span id="遗传算法">遗传算法</span></h4>
<ul>
<li><strong>Robust Android Malware Detection against Adversarial Example
Attacks.</strong> <a target="_blank" rel="noopener" href="https://dblp.uni-trier.de/db/conf/www/www2021.html#LiZYLGC21">WWW
2021</a>: 3603-3612</li>
<li><strong>secml-malware: A Python Library for Adversarial Robustness
Evaluation of Windows Malware Classifiers.</strong> <a target="_blank" rel="noopener" href="https://dblp.uni-trier.de/db/journals/corr/corr2104.html#abs-2104-12848">CoRRabs/2104.12848</a>
(2021)</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/3SMQYQP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3SMQYQP/" class="post-title-link" itemprop="url">AI安全（5）Functionality-Preserving Black-Box Optimization of Adversarial Windows Malware 2021 TIFS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 19:54:55" itemprop="dateCreated datePublished" datetime="2021-07-25T19:54:55+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-21 13:43:54" itemprop="dateModified" datetime="2023-04-21T13:43:54+08:00">2023-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AI%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">AI安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="functionality-preservingblack-box-optimization-of-adversarial-windows-malware-2021-tifs"><strong>Functionality-Preserving
Black-Box Optimization of Adversarial Windows Malware 2021 TIFS
</strong></span></h2>
<p><strong>keyword:</strong> 对抗样本；黑盒优化；</p>
<h3><span id="abstract">Abstract：</span></h3>
<p>基于机器学习的Windows恶意软件检测器很容易受到攻击性示例的攻击，即使攻击者只获得对模型的黑盒查询访问权限。这些攻击的<strong>主要缺点</strong>是：<strong>查询效率低</strong>下，因为它们依赖于对输入恶意软件反复应用随机转换；它们可能还需要在优化过程的<strong>每次迭代中在沙盒中执行恶意软件</strong>，以确保其入侵功能得到保留。依赖于在恶意文件的<strong>末尾或在一些新创建的部分中注入良性内容</strong>（这些内容永远不会被执行）。<strong>我们的攻击被形式化为一个有约束的最小化问题，这也使得规避检测的概率和注入的有效负载的大小之间的权衡得到优化</strong>。对两种流行的静态Windows恶意软件检测器进行了实证研究，结果表明，即使只返回预测的标签，我们的黑盒攻击也可以通过很少的查询和较小的有效负载绕过它们。还评估了我们的攻击是否会转移到其他商业防病毒解决方案中，并意外地发现它们平均<strong>可以避开12个以上的商业防病毒引擎</strong>。讨论了我们的方法的<strong>局限性</strong>，以及它将来可能扩展到基于动态分析的目标恶意软件分类器。</p>
<h3><span id="一-introduction">一、Introduction</span></h3>
<p>机器学习在计算机安全领域正变得越来越普遍。学术界和工业界都在投入时间、金钱和人力资源来应用这些统计技术来解决恶意软件检测的艰巨任务。特别是，Windows恶意软件仍然是一种威胁，因为每天都有成千上万的恶意程序被上传到<strong>VirusTotal</strong><sup>[1]</sup>。现代方法使用机器学习来大规模检测此类威胁，利用许多不同的学习算法和特征集<sup>[1]–[7]</sup>。虽然这些技术已显示出很有前途的恶意软件检测能力，但它们最初的设计目的并不是为了处理攻击者可以操纵输入数据以逃避检测的非平稳、对抗性问题。</p>
<p>在过去的十年中，这一点在对抗式机器学习领域得到了广泛的证明<sup>[8]，[9]</sup>。该研究领域研究了机器学习算法在训练或测试阶段受到攻击时的安全性问题。特别是，在基于学习的Windows恶意软件检测器的背景下，已经证明可以针对目标系统仔细优化对抗性恶意软件样本以绕过它<sup>[10]–[17]</sup>。其中许多攻击都在黑盒设置中进行了演示，在黑盒设置中，攻击者只能对目标模型进行查询访问<sup>[14]–[17]</sup>。这确实对作为云服务部署的此类系统的安全性提出了质疑，因为外部攻击者可以查询这些系统，然后根据目标系统提供的反馈优化其操作，直到实现规避。</p>
<p>然而，这些黑盒攻击在以下方面仍然不是非常有效：（i）所需查询的数量<strong>(reguired
queries)</strong>，（i）其优化过程的复杂性<strong>(complexity)</strong>，以及（i）<strong>对输入样本执行的操作量(amount
of manipulations)</strong>，如下所述: 1. 首先查询效率 is hindered by the
fact that
攻击通过反复迭代并非专门针对逃避检测的转换（如在文件结尾后注入随机字节）来优化恶意软件。优化过程在计算上可能要求很高，因为有些攻击需要在每次迭代时在沙盒中执行敌对恶意软件样本，以确保其入侵功能得到保留。这种验证步骤是由在特征空间中操纵数据（而不是考虑可实现的输入修改<sup>[18]</sup>的攻击所要求的或者考虑可能破坏恶意软件样本<sup>[14]</sup>的功能的输入变换<sup>[19]</sup>。
2.
虽然在沙盒中执行一次恶意软件样本可能不会显著减慢整个过程，但因为它需要在感染前的阶段恢复虚拟环境的状态。当优化过程的每次迭代后都必须重复此步骤时，问题就变得相关了。此外，许多恶意软件样本可以检测它们是否在虚拟环境中运行，并延迟执行以保持未被检测到：Malware
dynamic analysis evasion techniques：A survey； 3.
所有这些攻击都通过显著操纵输入恶意软件的内容来实现规避，而<strong>不考虑额外的限制</strong>，例如，对生成的文件大小或注入的节数的限制。这可能导致攻击样本很容易被检测为异常，只需查看一些无关紧要的特征（<strong>trivial
characteristics</strong>），如文件大小或节数。</p>
<p>在本文中，我们提出了一个新的黑盒攻击家族（Section 3）
可以有效地优化恶意软件样本。首先，我们的攻击是高效查询的，因为它们依赖于注入特定目标的内容以便于规避，即从良性样本中提取（而不是随机生成）。第二，它们在设计上保留了功能，因为它们利用了一组操作，这些操作仅通过利用用于在磁盘上存储程序的文件格式的模糊性将内容注入恶意程序，而不改变其执行跟踪。虽然在这项工作中，我们只关注在文件末尾（填充）或在一些新创建的节（节注入）中注入内容，但我们的方法足够通用，可以包含更广泛的功能保留操作。最后，我们的攻击更加隐蔽。特别地，它们被形式化为<strong>一个约束最小化问题，该问题不仅优化了规避检测的概率</strong>，而且通过一个特定的正则化项<strong>（via
a specific regularization
term.）</strong>来惩罚注入的敌方有效载荷的大小。</p>
<h3><span id="二-programs-and-malwaredetection">二、PROGRAMS AND MALWARE
DETECTION</span></h3>
<p>在本节中，我们首先讨论Windows可移植可执行文件（PE）格式，2它描述了程序如何存储在磁盘上，并向操作系统（OS）解释了如何在执行之前将其加载到内存中。然后，我们将介绍这项工作剩余部分中使用的两种流行的基于学习的Windows恶意软件检测器。</p>
<h4><span id="21-the-windowsportable-executable-pe-file-format">2.1 The Windows
Portable Executable (PE) File Format</span></h4>
<p>Windows
PE格式由几个组件组成，如图1所示，如下所述。DOS标题（A）。它包含用于在DOS环境中加载可执行文件的元数据，以及DOS存根，如果在DOS环境中执行，则会打印“此程序无法在DOS模式下运行”。保留这两个组件是为了保持与旧版Microsoft操作系统的兼容性。从现代应用程序的角度来看，DOS头中唯一相关的部分是：（i）幻数MZ，文件的两字节长签名，以及（ii）偏移量0x3c处的四字节长整数，用作指向实际头的指针。如果这两个值中的一个由于某种原因被置乱，则认为程序已损坏，操作系统将不会执行该程序。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211340691.png" alt="image-20210724201057346" style="zoom:50%;"></p>
<p>PE
header（B）。它包含幻数PE以及其他文件特征，如目标体系结构、头大小和文件属性。</p>
<p>Optional
Header（C）。它包含操作系统初始化加载程序所需的信息。它还包含指向有用结构的偏移量，如操作系统解析依赖关系所需的导入地址表（IAT）和导出表偏移量，后者指示在何处查找其他程序可以引用的函数。截</p>
<p>Section
Table（D）。它是一个条目列表，指示程序的每个核心组件的特征，以及OS加载程序应该在文件中找到它们的位置。</p>
<p>Sections（E）节。这些连续的字节块承载着可执行文件的真实内容。要列出一些：。文本包含代码。数据包含全局变量和。rdata包含只读常量和计数。</p>
<p>可执行程序的结构可用于静态推断有关其行为的信息。事实上，大多数防病毒供应商应用静态分析来检测野外威胁，而不在受控环境中执行可疑程序。这种方法节省了时间和资源，因为防病毒程序不会在主机操作系统内执行可疑软件。静态分析是第一道防线，其性能对于抵御野外无数威胁至关重要。</p>
<h4><span id="22-learning-basedwindows-malware-detection">2.2 Learning-Based
Windows Malware Detection</span></h4>
<ul>
<li>MalConv</li>
<li>EMBER</li>
</ul>
<h3><span id="三-black-boxoptimization-of-adversarial-windows-malware">三、BLACK-BOX
OPTIMIZATION OF ADVERSARIAL WINDOWS MALWARE</span></h3>
<p>在本节中，我们将介绍一种新的黑盒攻击框架，命名为GAMMA（Genetic
adricative Machine learning Malware
attack）。GAMMA可以有效地优化敌方恶意软件样本，同时只需要黑盒访问模型，即只查询目标模型并观察其输出，而不访问其内部结构和参数。我们的攻击依赖于一组保留功能的操作，这些操作利用用于在磁盘上存储程序的PE格式的模糊性将内容注入恶意程序，而不改变其执行跟踪。这使我们能够摆脱需要计算的验证步骤，以确保被操纵的恶意软件保留其预期功能。特别是，我们认为这里的内容操纵，特别是针对有利于逃避，即，<strong>从良性样本中提取，而不是随机产生。虽然这使得我们的攻击更加有效，但值得注意的是，我们的框架足够通用，可以包含许多其他不同的内容操作技术</strong>。最后，为了使我们的攻击更加隐蔽，我们将其形式化为一个约束优化问题，该问题不仅最小化了逃避检测的概率，而且通过一个特定的惩罚项最小化了注入内容的大小。</p>
<p><strong>符号定义</strong>，我们用x 2 x表示  f0；：：：；255g 
（恶意）输入程序，描述为任意长度的字节字符串。然后，我们定义了一组k个不同的保留功能的操作，这些操作可以作为向量s2
s应用于输入程序x  [0；1]k</p>
<ul>
<li>Notation: <span class="math inline">\(x\)</span> malicious；<span class="math inline">\(s\)</span> (k 种
vector);（良性初始注入+遗传算法）</li>
</ul>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211340847.png" alt="image-20210725161919601">
<figcaption aria-hidden="true">image-20210725161919601</figcaption>
</figure>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211340732.png" alt="image-20210725161950958" style="zoom:50%;"></p>
<h4><span id="31functionality-preservingmanipulations保留功能的操作">3.1
<strong>Functionality-Preserving
Manipulations</strong>（保留功能的操作）</span></h4>
<p>我们在这里讨论一组可以在我们的攻击框架中使用的保留功能的操作。在windowspe文件格式的上下文中，只有一些转换可以在不影响输入程序执行的情况下应用。我们将其分为结构性和行为性两类，详情如下。</p>
<ul>
<li><strong>Structural结构化</strong>：这一系列操作只影响输入程序的结构，利用文件格式中的模糊性，而不改变其行为。
<ol type="1">
<li>Perturb Header
Fields：扰动标题字段[13]–[15]。此技术包括更改节名称、中断校验和以及更改调试信息。</li>
<li>Filling Slack
Space：填充松弛空间[12]–[15]，[23]。此技术操纵编译器插入的空闲空间，以保持文件内部的对齐。相应的空闲字节（图1中的E内）通常被设置为零，并且它们从不被可执行文件的代码引用。</li>
<li><strong>Padding</strong>：填充[11]、[12]、[23]。这种技术在文件末尾注入额外的字节（在图1中的E之后）。</li>
<li>Manipulating DOS Header and
Stub：操作DOS头和存根[10]，[22]。这项技术修改了DOS头中一些现代程序不使用的字节。</li>
<li>Extend the DOS Header:
扩展DOS标头[22]。这种技术通过在程序的实际头之前注入内容来扩展DOS头。</li>
<li><strong>Content
shifting</strong>：内容转移[22]。这种技术通过向前移动内容，在节的开始之前创建额外的空间，并在中间注入对抗性内容。</li>
<li>Import Function
Injection：导入函数注入[13]–[15]。该技术通过向导入地址表添加适当的条目来注入导入函数，指定在加载过程中必须包括哪个库中的哪个函数（这影响图1中的C和E）。</li>
<li>Section
Injection：第[13]-[15]节。这种技术通过在节表中创建一个额外的条目将新的节注入到输入文件中（从而影响图1中的D和E）。每个节条目的长度为40字节，因此所有内容都必须按该长度进行移位，而不会影响头指定的文件和节对齐方式。</li>
</ol></li>
<li><strong>Behavioral行为</strong>：这一系列的干扰可以改变程序的行为和执行痕迹，但仍然保留恶意软件程序的预期功能。例如，这些转换包含[24]中的二进制重写技术，如下所述。</li>
</ul>
<ol type="1">
<li>Packing：<strong>加壳</strong>[13]–[15]。软件加壳的原理是在原始程序外部添加一个保护层，以保护程序代码和数据不被恶意软件攻击者破解、篡改或复制。通过壳程序的加载和解码、原始程序的加密和解密、壳程序的动态反调试和反破解、以及代码混淆和虚拟机技术等手段，可以使程序更加安全和难以被攻击者破解。<strong>封隔器的作用是侵入性的，因为输入样本的整个结构都被修改了；</strong>
<ul>
<li>[13] R. L. Castro, C. Schmitt, and G. D. Rodosek, “ARMED: How
automaticmalware modifications can evade static detection?” in Proc. 5th
Int.Conf. Inf. Manage. (ICIM), Mar. 2019, pp. 20–27.</li>
<li>[14] R. L. Castro, C. Schmitt, and G. D. Rodosek, “Aimed: Evolving
malwarewith genetic programming to evade detection,” in Proc. 18th Int.
Conf.TrustCom, 2019, pp. 240–247.</li>
<li>[15] H. S. Anderson, A. Kharkar, B. Filar, and P. Roth, “Evading
machinelearning malware detection,” in Proc. BlackHat, 2017.</li>
</ul></li>
<li>Direct：直接[24]。这种方法重写代码的特定部分，比如用等价的指令替换汇编指令（例如，用相反的符号进行加法和减法）。
<ul>
<li>这种技术被称为“<strong>代码混淆</strong>”（code
obfuscation）。它是一种常见的恶意软件攻击技术，攻击者使用代码混淆技术来隐藏恶意代码的真实意图，使其更难以被检测和分析。</li>
<li>在这种技术中，攻击者会通过重写代码的特定部分来进行代码混淆。例如，攻击者可以用等价的指令替换汇编指令，或者用相反的符号进行加法和减法等操作。这样一来，原本的代码逻辑就被混淆了，使得恶意代码更难以被理解和分析。</li>
<li>代码混淆技术可以有效地防止恶意代码被检测和分析，因为它使得恶意代码的行为更难以被预测和理解。然而，代码混淆也会使得恶意代码更难以被清除和修复，因为恶意代码的行为可能会受到混淆代码的影响，从而导致误报和误判。</li>
<li>[24] M. Wenzl, G. Merzdovnik, J. Ullrich, and E. Weippl, “From
hackto elaborate technique—A survey on binary rewriting,” ACM
Comput.Surv., vol. 52, no. 3, pp. 1–37, Jul. 2019</li>
</ul></li>
<li>Minimal
Invasive[15]，[24]。此技术将入口点设置为新的可执行部分，该部分跳回原始代码。
<ul>
<li>这种技术被称为“<strong>代码注入</strong>”（code
injection）。它是一种恶意软件攻击技术，攻击者通过将恶意代码注入到受害者计算机中的合法进程中，来控制受害者计算机、窃取敏感信息或者执行其他恶意行为。</li>
<li>在这种技术中，攻击者会将恶意代码插入到被感染程序的可执行部分中，并将程序的入口点设置为恶意代码的起始位置，使程序在运行时首先执行恶意代码。然后，恶意代码会执行一些操作（如窃取信息、下载其他恶意代码等），最后将程序的控制权转回到原始代码中，以避免被检测到。</li>
<li>代码注入是一种常见的恶意软件攻击技术，攻击者可以使用多种方法来实现代码注入，如缓冲区溢出、API
Hooking、DLL注入等。为了防止代码注入攻击，建议用户保持软件的更新和使用安全软件进行防护。</li>
</ul></li>
<li>Full
Translation：完整翻译[24]。这种方法将所有代码提升到更高的表示形式，例如LLVM，4，因为它简化了扰动的应用，然后将代码翻译回汇编语言。
<ul>
<li>这种技术被称为“<strong>语义混淆</strong>”（semantic
obfuscation）。它是一种常见的恶意软件攻击技术，攻击者使用语义混淆技术来隐藏恶意代码的真实意图，使其更难以被检测和分析。</li>
<li>在这种技术中，攻击者会将所有代码提升到更高的表示形式，例如LLVM，因为这样可以简化扰动的应用。然后，攻击者会将代码翻译回汇编语言，但是这时的代码已经被语义混淆了，使得其更难以被理解和分析。</li>
<li>语义混淆技术可以有效地防止恶意代码被检测和分析，因为它使得恶意代码的行为更难以被预测和理解。然而，语义混淆也会使得恶意代码更难以被清除和修复，因为恶意代码的行为可能会受到混淆代码的影响，从而导致误报和误判。</li>
</ul></li>
<li>Dropper[30]。这种方法将代码存储为另一个二进制文件的资源，然后在运行时加载。
<ul>
<li>这种技术被称为“<strong>二进制文件注入</strong>”（binary file
injection）。它是一种恶意软件攻击技术，攻击者使用二进制文件注入技术来隐藏恶意代码，使其更难以被检测和分析。</li>
<li>在这种技术中，攻击者会将恶意代码存储为另一个二进制文件的资源，然后在运行时加载。这样一来，恶意代码就被隐藏在另一个二进制文件的资源中，使得它更难以被检测和分析。</li>
<li>二进制文件注入技术可以有效地防止恶意代码被检测和分析，因为它使得恶意代码更难以被发现。然而，二进制文件注入也会使得恶意代码更难以被清除和修复，因为恶意代码可能会被存储在多个文件中，从而需要进行全面的扫描和清除。</li>
<li>[30] F. Ceschin, M. Botacin, H. M. Gomes, L. Oliveira, and A.
Grégio,“Shallow security: On the creation of adversarial variants to
evademachine learning-based malware detectors,” in Proc. 3rd
ReversingOffensive-Oriented Trends Symp., 2019, pp. 1–9.</li>
</ul></li>
</ol>
<ul>
<li><strong>Padding and Section-Injection Attacks
填充和节注入攻击</strong></li>
</ul>
<p>虽然GAMMA可以通过在[33
]中的开源实现支持大多数上述操作，但是我们只考虑在这项工作中的<strong>填充</strong>和<strong>分段注入攻击</strong>，因为它们提供了两个<strong>有代表性的示例</strong>，即在不需要操纵额外的头组件的情况下，在样本内注入内容（例如，节区表）。特别是，<strong>Padding</strong>将内容注入到可执行文件的未使用空间中，而不改变任何其他头组件。相反，<strong>Section
infection</strong>不仅允许像其他技术一样注入自定义内容，而且还通过在节表中添加节条目来操纵可执行文件的结构。</p>
<h3><span id="四-实验">四、实验</span></h3>
<p>在本节中，我们根据经验评估了针对GBDT和MalConv恶意软件检测器的攻击的有效性。我们在一台装有Intel的工作站上进行了实验 
至强  CPU E5-2670，具有48个CPU和128 GB
RAM。MalConv的预训练版本呈现出略有不同的体系结构w.r.t。原始公式：1
MB的输入大小和256的填充值，以避免移动预处理部分。该网络使用PyTorch实现【25】。我们使用DEAP开发了GAMMA的遗传优化器【26】。我们使用10个元素的总体大小N测试了攻击，将查询预算T从10更改为510。如果优化器在一个局部最小值上停滞了5次以上的迭代，我们将停止该过程。我们使用正则化参数的值 
2层10  ig9i=3。由于攻击特征空间S在攻击者可能添加的节数上是参数化的，因此我们随机提取了75个。如第III-a节所述，我们的goodware数据集中的rdata部分将用于向输入恶意软件添加内容，最大容量为2.5
MB。我们愿意将此数字设置为高值，因为优化器将发现较小的有效负载，这要归功于行为为“1”标准的惩罚术语所施加的稀疏性。我们实现并公开了用于计算这些攻击的库，名为secml恶意软件。5.</p>
<h4><span id="41-无攻击时的性能">4.1 无攻击时的性能</span></h4>
<p>为了在没有攻击的情况下评估这两种分类器的性能，我们收集了一组分类器；15000良性和15；000个恶意软件样本。恶意软件样本是从VirusTotal收集的，而<strong>goodware样本是通过从GitHub下载可执行程序收集的</strong>。结果如图3所示。为GBDT选择的阈值为0.8336，对应于0.039的假阳性率（FPR）和0.95的真阳性率（TPR）。<strong>MalConv使用的阈值为0.5，这导致FPR为0.035，TPR为0.69</strong>。图中的红点直接在曲线上显示这些值。这些结果与GBDT【6】的作者给出的描述相当，因为两种检测器的w.r.t得分略低。这篇论文中报道了这一点。不过，它们都可以作为我们分析的基线。</p>
<h4><span id="42-攻击评估">4.2 攻击评估</span></h4>
<p>我们从收集的15K恶意软件中<strong>随机抽取500个用于对抗性攻击</strong>，其中包括5.3%的勒索软件、29%的下载软件、18%的病毒、7%的后门软件、29%的灰色软件、8%的蠕虫，以及其他百分比较低的家族。图4显示了检测率和对抗性有效载荷大小如何随查询数量和正则化参数的值而变化。曲线图中的每条曲线都是通过计算每个值的平均检测率和平均大小生成的 ,
针对发送的不同查询数重复此操作。作为的值 
由于在计算目标函数时，惩罚项可以忽略不计，因此该算法可以找到更多有效载荷较大的规避样本。另一方面，通过增加 
由此产生的攻击特征向量变得稀疏，生成更小但更可检测的对抗性示例。在这种情况下，惩罚项会吞噬分类器计算的分数，这在优化过程中变得无关紧要。另一个重要影响是遗传优化器使用的总查询数：发送的越多，敌对示例的检测率和大小越好。直观地说，通过发送更多的查询，GAMMA可以同时探索更多隐藏和回避的解决方案，但在优化过程的早期阶段无法找到此类解决方案。为了证明我们的方法的有效性，我们报告了应用递增长度随机字节序列的结果。这个实验强调了轻微的下降趋势，但使用良性内容注入的优化攻击比随机干扰更有效。分段注入攻击比填充攻击更能降低GBDT的检测率。由于第一种技术还在节表中引入了节条目，因此与填充攻击修改的特性相比，对抗性有效载荷干扰的特性更多。</p>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211340248.png" alt="image-20220606205653971">
<figcaption aria-hidden="true">image-20220606205653971</figcaption>
</figure>
<h4><span id="43-硬标签攻击">4.3 硬标签攻击</span></h4>
<p>我们在表I中显示了聚合结果，重点比较了软标签和硬标签攻击的性能。每个条目表示每个检测器的平均检测率和平均对抗有效负载大小，给定一对用于计算指定攻击的查询/正则化参数。我们计算了4个不同的 
在集合f10中  （2i+1）g4i=1。结果表明，在没有置信度得分的情况下，一旦发现一个规避有效载荷，则无论正则化参数的值如何，其大小都会在遗传算法的一次又一次迭代中得到优化 .
这是由我们为实验设置的结果造成的：我们使用一个无限值来丢弃每个检测到的敌对示例，因此所有剩余的示例仅用于优化大小，作为优化的约束本身。我们的方法在这种环境中的有效性是由注入的内容的性质引起的，它模仿良性类，图4证实了这一点，其中注入随机字节序列对目标没有影响。相反，查询的数量本身起到了调节器的作用，因为太少的查询会导致更大的对抗性有效载荷，而置信度较低，而大量的查询会导致分数较高的小有效载荷。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211341881.png" alt="image-20220606205832607" style="zoom:50%;"></p>
<h4><span id="44-时间分析">4.4 时间分析</span></h4>
<p>从时间的角度来看，GAMMA的复杂性主要取决于查询探测器所花费的时间。表II显示了计算每个攻击和目标的单个查询所需的平均运行时间。令人惊讶的是，特征提取阶段和GBDT预测所花费的时间之和小于神经网络处理所有字节所需的时间。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211341457.png" alt="image-20220606210050720" style="zoom:50%;"></p>
<h4><span id="45-加壳影响">4.5 加壳影响</span></h4>
<p>由于这些分类器仅利用静态特征，因此我们有理由问自己，在不应用第三节中介绍的所有技术的情况下，加密程序内容是否足以逃避检测。<strong>打包是一种通过应用压缩、加密或编码算法来减少可执行文件大小的技术。由于打包器的作用完全改变了磁盘上的程序表示，恶意软件供应商广泛使用打包器向分析师隐藏其产品，增加了逆向工程分析的难度。</strong>在这种情况下，我们将一种著名的技术UPX7应用于1000个恶意软件和1000个goodware程序，并测试MalConv和GBDT的规避率。UPX封隔器的有效性如图5所示。这两个检测器在打包样本时都会给出恶意分数，通过查看打包好的goodware程序的方框图，这是很直观的。这两种检测器都增加了它们对恶意软件类别的得分，而打包恶意软件的均值和方差只有很小的变化。</p>
<p>从这些结果来看，我们认为，探测器将包装技术的应用视为一种恶意特征。这可能是由于训练集中有大量打包的恶意软件，而不是缺少打包的好软件。因此，基于此类数据训练的模型可能会有偏差，使他们错误地认为样本是恶意的，只是因为它是打包的。此外，如果使用一种技术打包足够的样本，学习算法应该能够捕获打包程序中打包程序本身留下的签名。例如，UPX打包器创建两个名为UPX0和UPX1的可执行部分，其中包含提取代码和原始压缩程序。<strong>我们认为，通过包装技术进行规避更可能由看不见的包装商实现，即恶意软件供应商自己开发的定制解决方案</strong>。</p>
<blockquote>
<p>We believe that evasion through packing techniques should more likely
to be achieved by unseen packers, <strong>i.e.</strong> custom solutions
developed by malware vendors themselves.</p>
</blockquote>
<h4><span id="46evaluation-on-antivirus-programs-virustotal">4.6
<strong>Evaluation on Antivirus Programs</strong> (VirusTotal)</span></h4>
<p>我们在此评估我们的攻击对商用探测器的影响。在这种情况下，我们无意逃避这些商业程序的检测，例如打包输入样本，而是评估这些方法是否可以检测到我们的攻击，因为我们的攻击只对输入恶意软件样本的内容进行了最小程度的修改。特别是，我们应用于恶意软件样本的操作仅涉及每个程序的语法结构，我们的目的是评估此类转换的应用是否会对其他防病毒程序构成威胁。我们预计，大多数商业解决方案不应受到此类攻击的影响。我们依赖VirusTotal检索到的响应，8这是许多威胁检测器的在线接口。该服务提供了一个API，可以通过从远程上传样本来查询系统。我们通过在向样本中注入对抗性负载之前和之后发送200个恶意软件样本来测试我们的攻击性能，该样本使用针对GBDT分类器的分段注入攻击进行了优化。我们还将我们的攻击与基线随机攻击进行比较，基线随机攻击只是向每个样本添加50
KB的随机负载。表三显示了VirusTotal上托管的防病毒程序平均有多少（总共70个）检测到提交的恶意软件样本。虽然随机攻击只会略微减少每个样本的检测数量，但分段注入攻击能够绕过平均每个样本12个以上的检测器。为了更好地评估我们的攻击对单个杀毒程序的影响，在表IV中，我们报告了2019年Gartner端点保护平台幻方图上出现的9种不同杀毒产品的检测率，9包括许多领先和有远见的产品，在执行随机和部分注入攻击之前和之后。在许多情况下，我们的节注入攻击能够大幅降低检测率（参见，例如，AV1、AV3、AV7和AV9），显著优于随机攻击（参见，例如，AV1和AV9）。原因可能是，其中一些防病毒程序已经使用基于静态机器学习的检测器，在保护终端客户端免受恶意软件攻击时实施了第一道防线，这也在他们的博客或网站上得到了证实，这使他们更容易受到我们的攻击。综上所述，我们的分析强调，这些商业产品可以通过转移攻击来规避，我们相信，通过对其进行优化攻击，它们的检测率可能会下降更多。</p>
<h3><span id="五-related-work">五、RELATED WORK</span></h3>
<h5><span id="强化学习15">强化学习[15]</span></h5>
<blockquote>
<p>Anderson等人[15]提出了一种强化学习方法，以确定导致逃避的最佳操作顺序。为了测试代理的有效性，他们还测试了随机选取的操作的应用。他们用作基线的模型是我们在这项工作中分析的GBDT分类器的原始版本，使用较少的样本进行训练。为了训练学习代理的策略，他们通过为可使用的查询数量确定预算，让模型探索对抗性示例的空间。用于培训这些策略的查询平均数量约为1600[15]。作者没有报告对抗性恶意软件产生的文件大小：强化学习方法包含放大磁盘上表示的操作，但不清楚如何和多少。不同的是，我们的方法不需要培训阶段，因为它可以针对远程探测器进行部署。我们使用的转换在设计上是功能不变的，它们的应用程序不会改变程序的执行流。最后，通过在优化过程中插入正则化器，我们考虑了有多少内容被添加到输入恶意软件中。通过这种方法，可以控制插入噪声的数量，并且该算法可以找到不仅避开目标分类器，而且在大小上受到限制的对抗性示例。</p>
</blockquote>
<h5><span id="随机算法和遗传算法1314">随机算法和遗传算法[13],[14]</span></h5>
<blockquote>
<p>Castro等人[13]，[14]应用随机算法和遗传算法来干扰输入恶意软件，并在沙箱中的优化过程的每次迭代中测试样本的功能。这些突变与Anderson等人提出的相同[15]。这些工作的作者表示，他们需要大约4分钟来创建敌对恶意软件，使用100个查询。尚未公布任何架构细节。我们不需要在沙箱中验证恶意软件，因为我们在变异过程中包含了领域知识。因此，我们的方法在同一时间跨度内执行1400个查询。他们也没有报告哪些是导致规避的最具影响力的突变：后者至关重要，我们正在处理统计算法中的潜在漏洞，与其他安全漏洞相比，这些漏洞的存在并不明显。</p>
</blockquote>
<h5><span id="gan27">GAN[27]</span></h5>
<blockquote>
<p>Hu和Tan[17]开发了一个生成性对抗网络（GAN）[27]，其目的是绕过目标分类器，打造对抗性恶意软件。网络会了解哪些API导入应该添加到原始样本中，但不会生成真正的恶意软件，因为这种攻击只在功能空间内运行。相反，由于每次都会生成真实的样本，因此我们创建了功能正常的恶意软件。针对Windows恶意软件检测器的黑匣子攻击的概述见表V，其中我们将上述技术与我们的方法进行了比较。</p>
</blockquote>
<h3><span id="六-conclusion-and-futurework">六、<strong>CONCLUSION AND FUTURE
WORK</strong></span></h3>
<p>在本文中，我们<strong>提出了一个基于学习的Windows恶意软件检测器的新的黑盒攻击家族，它既能有效地进行查询，又能保持功能</strong>，克服了以往工作的局限性。我们的攻击依赖于在恶意文件末尾或在新创建的部分中注入良性内容（这些内容永远不会被执行），利用用于在磁盘上存储程序的文件格式的模糊性，而不改变其执行痕迹。所提出的攻击被形式化为一个有约束的最小化问题，该问题能够在规避检测的概率和注入的有效负载大小之间进行优化。我们对两个流行的基于学习的Windows恶意软件检测器进行了广泛的实证评估，结果表明，即使目标模型只输出预测的标签，我们的黑盒攻击也可以通过很少的查询和非常小的有效负载绕过它们。我们还表明，我们的攻击可以成功地转移到其他商业防病毒解决方案，发现他们可以逃避，平均而言，多达12个商业防病毒引擎提供的VirusTotal。尽管如此，我们相信直接针对这些探测器的优化攻击可能会更加有效。未来工作：未来工作的一个有趣途径是调查针对我们的攻击的适当对策的适用性，如第节所讨论的。六、
包括使用更健壮的特征表示（对基于字节或基于节的操作不敏感）和学习范式（通过对抗性再训练、特定攻击检测机制或使用领域知识约束）。另一个有希望的研究方向是将我们的攻击扩展到只在文件末尾或新创建的部分中注入内容的操作之外。我们坚信这是可以很容易实现的，因为我们的方法已经足够普遍，可以包含更广泛的功能保留操作，包括第节中讨论的操作。III-A级。将我们的工作扩展到处理也可以修改恶意软件程序动态执行的操作，例如在保留恶意意图的同时改变其控制流，无疑是一个挑战。然而，这无疑将为改进基于动态程序分析提取的特征的恶意软件检测器的评估和对抗性健壮性提供重要的一步。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/35K4AXJ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/35K4AXJ/" class="post-title-link" itemprop="url">AI安全（4）Black-Box Adversarial Attacks Against Deep Learning Based Malware Binaries Detection with GAN</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-02 19:53:40" itemprop="dateCreated datePublished" datetime="2021-06-02T19:53:40+08:00">2021-06-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-06 21:33:04" itemprop="dateModified" datetime="2023-05-06T21:33:04+08:00">2023-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/AI%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">AI安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>19 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="black-boxadversarial-attacks-against-deep-learning-based-malware-binariesdetection-with-gan">Black-Box
Adversarial Attacks Against Deep Learning Based Malware Binaries
Detection with GAN</span></h2>
<h3><span id="摘要">摘要：</span></h3>
<p>​
<strong>【目的】</strong>为了有效地检测恶意软件，有越来越多的基于原始软件二进制文件的深度学习方法。最近的研究表明，深度学习模型很容易被愚弄，通过对输入引入细微的扰动而做出错误的决定，这在对抗性攻击中吸引了大量的工作。<strong>【缺点】</strong>然而，大多数现有的攻击方法都是基于手动特性（例如API调用）或白盒设置，使得这些攻击在当前的现实场景中是不切实际的。<strong>【工作】</strong>在这项工作中，我们提出了一种新的攻击框架，称为GAPGAN，它通过生成对抗网络（GANs）生成对抗有效负载（填充字节）。据我们所知，这是第一个针对基于深度学习的恶意软件二进制文件检测在字节级别执行端到端黑盒攻击的工作。<strong>【创新一】</strong>在我们的攻击框架中，我们将输入的离散恶意软件二进制文件映射到连续空间，然后将其提供给GAPGAN的生成器以生成对抗性有效载荷。我们将有效载荷附加到原始二进制文件中，以便在保留其功能的同时创建一个对抗性示例。<strong>【创新二】</strong>我们建议使用动态阈值来减少有效载荷从连续格式映射回原始离散格式时的有效性损失。为了平衡生成器对有效负载和对抗性样本的关注，我们使用了一种自动权重调整策略。<strong>【结果】</strong>我们用恶意软件和良性软件训练GAPGAN。一旦训练完成，生成器可以在不到20毫秒的时间内生成一个只包含输入恶意软件的对抗性样本，我们应用GAPGAN攻击最先进的探测器MalConv，只需附加2.5%的有效负载即可达到100%的攻击成功率。我们也在不同的防御方法下攻击具有不同结构的深度学习模型。实验结果表明，GAPGAN在效率和有效性上都优于其他最新的攻击模型。</p>
<h3><span id="一-说明">一、说明</span></h3>
<p>深度神经网络已经取得了巨大的成功，越来越多的工作倾向于使用深度学习进行有效的恶意软件检测。其中，一些工作（例如，[5]和[12]）基于可能包含程序恶意行为的手动功能（例如，API调用）检测恶意软件，一些工作（例如，[21]、[24]和[4]）直接使用软件信息而不运行，其他工作（例如，[13]和[20]）集成上述策略或使用其他方法，如可视化。最近，有一种趋势是使用原始二进制文件进行恶意软件检测，它可以有效地挖掘文件不同部分之间的潜在关系。随着恶意软件的快速发展，防御效率在当今的现实场景中变得至关重要，这使得基于原始二进制文件的端到端检测更具前景。</p>
<p>然而，许多研究工作（[25]、[7]、[17]、[9]和[27]）表明，深层神经网络容易受到对抗性攻击。攻击者对原始数据添加了人类无法察觉的小干扰，这可能会误导分类器做出错误的决策。这些研究指出，深度学习算法和人工智能应用的安全性面临严重威胁。</p>
<p>在恶意软件检测中，大多数对抗性攻击（例如，<strong>[14]、[15]和[3]</strong>【<strong>问题空间扰动</strong>】）依赖于检测器的完整信息（例如，白盒攻击）。<strong>然而，这种攻击有其局限性，例如，目标模型必须完全暴露给攻击者</strong>。同时，之前的攻击工作（例如，[11]、[2]和[23]
【<strong>特征空间扰动</strong>】）基于推测用于训练探测器的手动特征。<strong>如果猜测是错误的，或者一旦后卫改变了训练策略，这种攻击将无效。</strong>基于原始二进制文件的检测的广泛使用也使得这种需要大量资源和时间来提取特征的攻击不适用。与手动特性不同，即使稍加修改，也不能简单地更改原始二进制数据，否则会损坏其功能。此外，二进制数据的大小差异很大，这进一步增加了攻击难度。我们还发现，在保存生成的对抗性样本时，将连续空间中的对抗性有效载荷转换回离散二进制时，会忽略细微的扰动，这会影响对抗性攻击的有效性。<strong>因此，如何在保护原有功能的同时，对基于恶意软件二进制文件的深度学习模型进行有效而实用的黑盒攻击仍然是一个巨大的挑战。</strong>本文提出了一种新的攻击框架GAPGAN，该框架通过GANs生成对抗性有效载荷。据我们所知，这是第一项针对基于深度学习的恶意软件二进制文件检测在字节级别执行端到端黑盒攻击的工作。我们应用GAPGAN攻击最先进的检测器MalConv[21]以及其他具有不同结构的深度学习模型。实验表明，我们的模型可以实现较高的攻击成功率，并且在效率和有效性方面优于其他最先进的攻击方法。</p>
<p>We have the following contributions:</p>
<ul>
<li>我们提出了一种新的对抗性攻击框架GAPGAN，该框架在字节级对基于深度学习的恶意软件二进制检测执行端到端的黑盒攻击，使攻击更加高效。</li>
<li>在GAPGAN中，生成器生成对抗性有效载荷，ap将其挂起到原始数据，以制作恶意软件对抗性样本，同时保留其功能。一旦训练过程完成，生成器可以在不到二十毫秒的时间内高效地生成每个对抗性样本。</li>
<li><strong>我们建议在将有效负载从连续空间映射回离散二进制文件时，使用动态阈值来减少有效负载有效性的损失。为了平衡生成器对有效负载和对抗性样本的关注，我们采用了自动权重调整策略。</strong></li>
<li>我们应用GAPGAN攻击最先进的恶意软件检测器MalConv。实验表明，GAPGAN生成的对抗性样本在附加2.5%数据长度的对抗性有效载荷进行检测时，攻击成功率可达100%。实验还表明，GAPGAN在不同防御方式下的效率和有效性均优于其他最先进的攻击方法。</li>
</ul>
<p>论文的剩余部分由五个部分组成：第二部分介绍了本文的研究背景和相关工作。在第3节中，我们将解释攻击框架GAPGAN的详细信息。在第4节中，我们描述了实验设置，包括数据集、指标和目标模型。在第5节中，我们展示了我们的实验结果。在第6节中，我们总结了我们的工作并给出了结论。</p>
<h3><span id="二-背景和相关工作">二、背景和相关工作</span></h3>
<h4><span id="21针对恶意软件检测的对抗性攻击">2.1
针对恶意软件检测的对抗性攻击</span></h4>
<p>大多数用于恶意软件检测的传统机器学习和深度学习方法（例如，[5]和[12]）侧重于从程序的行为信息中提取的手动特征，如签名和API调用。对于这种检测方法，早期的攻击工作主要基于防守者应该使用的手动特征。一些工作建议使用API作为二进制特性，然后采用深度学习模型来生成对抗性样本（[11]和[8]）。一种基于API调用序列的不同方法使用优化过程来执行对抗性攻击【23】。[2]
建议使用强化学习进行攻击，它包含大量手动信息作为特征，例如PE头元数据、节元数据和字节直方图。Xu等人[29]提出了一种基于遗传编程的攻击方法，对文件结构进行随机操作。然而，这些攻击需要专家经验和大量的时间来获得有效的特征，一旦防御者知道用于攻击的特征，快速更新的检测器就可以轻松规避攻击。</p>
<p>最近的恶意软件检测工作（例如，[21]、[24]和[4]）更注重对原始软件二进制文件使用深度学习模型，因为深度神经网络可以有效地挖掘原始数据中的潜在特征，而无需大量数据预处理和先验经验。为了赶上最新的恶意软件检测技术，攻击者开始寻找可应用于原始软件二进制文件的新方法（例如，[14]、[15]和[3]）。与提取的特征不同，原始二进制数据不能简单地更改，否则可能会丢失重要功能。此外，原始二进制文件具有可变的输入大小，这会进一步使这些攻击比以前更加棘手。</p>
<p>[14]
提出了第一种字节级的对抗性攻击，它结合了梯度上升和贪婪策略。它会在文件末尾逐个追加字节，以保留其功能。然而，它执行的白盒攻击在现实场景中有局限性，模型需要计算每个填充字节的梯度，这会消耗大量时间和资源。[15]
还提出了一种通过注入局部扰动来处理离散序列的方法。但是，它处于白盒设置中，效率不高。[3]
提出了白盒和黑盒方法。在黑盒方法中，它随机选择良性数据块并将其附加到恶意软件数据中，每次都测试结果。在执行攻击之前，获取有效块需要大量时间。这种方法简单但繁琐且效率低下，不适用于有效的恶意软件对抗性样本生成。相反，我们将展示我们的端到端框架可以在黑盒环境中进行攻击，并在更短的时间内生成对抗性样本。</p>
<h4><span id="22-generative-adversarialnetworks-gans">2.2 Generative Adversarial
Networks (GANs)</span></h4>
<p>近年来，生成性对抗网络（GANs）[6]广泛应用于计算机视觉任务中（例如，[30]、[16]和[1]）。根据他们的高水平模仿能力，一些作品（例如，[11]和[28]）采用GANs进行对抗性攻击。最具代表性的攻击方法使用称为蒸馏的方法将鉴别器与目标模型的输出相匹配，训练生成器生成可能误导鉴别器的数据。通过这种方式，敌对样本可以间接攻击目标模型，即敌对样本的可转移性[19]。与之前的工作不同，我们使用生成器生成对抗性有效载荷，用于在不破坏其功能的情况下制作对抗性样本。在我们的模型中，一旦GANs的训练过程完成，生成器可以在很短的时间内仅使用输入的恶意软件二进制文件独立生成恶意软件对抗样本。</p>
<h3><span id="三-方法">三、方法</span></h3>
<p>在本节中，我们将简要解释输入二进制文件和对抗性示例的形式化定义，然后介绍GAPGAN的框架和策略细节。</p>
<h4><span id="31-问题定义">3.1 问题定义</span></h4>
<p>【<strong>问题定义</strong>】软件的二进制文件由属于离散空间 <span class="math inline">\(\mathcal{X}=\{0, \ldots, 255\}\)</span>
的字节序列组成。设 <span class="math inline">\(b=\left(b_1, \ldots,
b_n\right) \in \mathcal{X}^n\)</span> 表示一个二进制文件，其中<span class="math inline">\(n\)</span>是字节序列的长度，因文件而异。二进制文件<span class="math inline">\(b\)</span>带有标签<span class="math inline">\(y
\in\{-1,1\}\)</span>，其中<span class="math inline">\(y=1\)</span>表示它是良性软件<span class="math inline">\(b_{b e n}\)</span>，否则它是恶意软件<span class="math inline">\(b_{m a l}\)</span>。</p>
<p>恶意软件检测器旨在学习一个映射函数<span class="math inline">\(f\)</span> : <span class="math inline">\(x
\rightarrow\{-1,1\}\)</span>，满足<span class="math inline">\(f\left(b_{\text {mal }}\right)=-1\)</span>和<span class="math inline">\(f\left(x_{\text {ben
}}\right)=1\)</span>。相反，对抗攻击的目标是找到一个模型<span class="math inline">\(g\)</span>并生成一个有效的对抗样本 <span class="math inline">\(b_{a d v}=g\left(b_{m a l}\right)\)</span>
，使得恶意软件检测器将其分类为良性软件，即<span class="math inline">\(f\left(b_{a d v}\right)=1\)</span>。同时，<span class="math inline">\(b_{a d v}\)</span>必须保留<span class="math inline">\(b_{\mathrm{mal}}\)</span>的原始功能。【可执行】</p>
<h4><span id="32-gapgan">3.2 <strong>GAPGAN：</strong></span></h4>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211339641.png" alt="image-20210602221731158">
<figcaption aria-hidden="true">image-20210602221731158</figcaption>
</figure>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211339571.png" alt="image-20210707153446579">
<figcaption aria-hidden="true">image-20210707153446579</figcaption>
</figure>
<p>【框架流程概述】图1显示了拟议框架GAPGAN的概述。它包括两个阶段：训练过程和进攻过程。在训练过程中，我们同时训练生成器网络G和鉴别器D，其中G打算为输入恶意软件生成对抗性有效载荷，并将它们连接起来以制作对抗性样本，而D试图提取目标黑箱检测器f，并模仿f对原始良性样本和生成的对抗性样本的判定。在攻击过程中，我们只需要经过训练的生成器来攻击黑箱检测器。</p>
<p>【扰动添加概述】为了在制作恶意软件的对抗性示例时保护其原始功能，<strong>有一些流行的方法，如使用调试日志和在运行前压缩数据，但它们是费时费力。通过仔细选择和操纵执行的其他攻击非常复杂，可能需要特定的经验，不适用于有效的对抗性攻击。受之前工作（[3]和[14]）的启发，我们选择在文件末尾附加字节（有效载荷）以保留其功能，这很简单，不需要任何专家经验</strong>.</p>
<p>【数据预处理】由于软件文件的长度<span class="math inline">\(n\)</span>变化很大，我们首先将零（表示为图1中的蓝色部分）附加到输入二进制文件的末尾，以匹配网络的输入大小<span class="math inline">\(t\)</span>，即<span class="math inline">\(b^{\prime}=\left(b_1, \ldots, b_n, 0, \ldots,
0\right) \in \mathcal{X}^t\)</span>，其中<span class="math inline">\(t
\geq
n\)</span>。通过这种方式，我们可以将不同长度的每个样本输入到具有固定大小的特定网络中。然后，我们通过归一化将离散二进制中的每个字节映射到连续空间<span class="math inline">\([-1,1]\)</span>。我们将归一化后的输入定义为<span class="math inline">\(x\)</span>，其中<span class="math inline">\(x=\left(x_1, \ldots, x_t\right) \in
\mathbb{R}^t\)</span>。【值得注意的是，为了保留可执行文件的多态性，没有将输入进行归一化。】</p>
<p>在数据预处理之后，将标准化的恶意软件xmal馈送到生成器G。然后，G基于xmal的相应特征生成对抗性负载aadv(在图1中表示为红色部分)：</p>
<p><span class="math display">\[
aadv = G(xmal) (1)
\]</span></p>
<p>我们将aadv附加到xmal的末尾以制作对抗性恶意软件样本xadv;</p>
<p><span class="math display">\[
xadv = [xmal，aadv]
\]</span></p>
<p>其中[·，·]表示连接操作。</p>
<p>在训练D时，我们将xadv和xben都合并到数据池中。在每次迭代中，我们从数据池中抽取混合示例批次，然后使用它们来查询黑盒检测器f。接下来，我们使用f响应的标签来拟合D，使得D的决策边界尽可能接近f。</p>
<p>在训练过程中，生成器G学习创建可以避开鉴别器D的样本。此外，随着D和我们的目标模型f之间的相似性的提高，G对f的对抗性攻击能力也将提高。最后，由于对抗性攻击的可转移性，G生成的对抗性样本也可以有效地避开f。</p>
<p>一旦训练过程完成，我们就可以使用训练后的G在很短的时间内生成对抗性样本，只需输入恶意软件。值得注意的是，我们在攻击过程中放弃了填充零，以减少有效载荷的整个长度。根据我们的实际经验，这会使攻击成功率略有下降，但损失是可以接受的。此外，我们需要将对抗性样本转换回离散空间作为可执行文件。</p>
<p>【模型结构】为了使我们的框架适应不同长度的恶意软件二进制文件和有效负载，<strong>生成器网络设计为具有可变的输入和输出大小。更具体地说，生成器首先使用两个卷积层提取输入的特征。然后，它使用完全连接的图层调整高级特征的大小。经过两层反卷积和一层1∗
1卷积，产生对抗性有效载荷。</strong>另一方面，鉴别器使用卷积层和完全连接层进行二元分类。请注意，如果确定了输入数据的大小和我们决定生成的有效负载的长度，我们可以使用它们作为输入来轻松调整GAPGAN的结构，因为生成器和鉴别器中的层都是完全连接的。</p>
<h4><span id="33-black-box-attacks-strategy">3.3 Black-box Attacks Strategy</span></h4>
<blockquote>
<p><strong>生成器G：</strong></p>
<ol type="1">
<li><p>将n长度的字节序列添加到t长度（t&gt;n)</p></li>
<li><p>通过<strong>标准化</strong>将离散二进制文件中的每个字节映射到一个连续空间[-1,1]</p></li>
<li><p>将<strong>填充后的恶意软件样本</strong>输入到<strong>生成器</strong>生成对抗样本<span class="math inline">\(adv\)</span></p></li>
<li><p>讲对抗样本<span class="math inline">\(adv\)</span>添加到<strong>填充后的恶意软件样本</strong>后</p></li>
</ol>
<p><strong>检测器D:</strong></p>
<ol type="1">
<li>将对抗样本和良性样本中抽取在黑盒上<strong>打标签</strong></li>
<li>用黑盒打上的标签数据去<strong>拟合检测器D</strong>，使得D的决策边界尽可能接近黑盒</li>
</ol>
<p><strong>训练结束：</strong></p>
<ol type="1">
<li>在攻击过程中放弃了填充零，以减少有效负载的整个长度。</li>
<li>将对抗性样本转换回离散空间作为可执行文件</li>
</ol>
</blockquote>
<p><strong>生成器</strong>：生成器G的目的是学习Xmal的特征，Xmal的原始标签是y=−1，并生成相应的有效样本Xadv，这会误导D将其预测为y=1的“良性”。在我们的实践经验中，G往往更关注D对xadv的预测结果，这带来了一个严重的问题，即对抗有效载荷aadv的有效性得不到很好的提高。因此，<strong>我们让G同时考虑xadv的全局和局部（即xadv和aadv）有效性</strong>。生成器G的对抗性损失函数为：
<span class="math display">\[
LG = −(1 − β)Ex∼pxadv(D(x)) − βEa∼paadv(D(a))
\]</span></p>
<p>其中，β是一个超参数，用于在xadv和aadv之间保持生成器注意力的平衡。我们试图找到β的最佳值，然而，固定的β并不总是表现得最好，因为每次攻击程序运行时，网络的条件都不同。因此，最好的β应该具有自适应调整的能力。受[18]的启发，我们考虑根据D到xadv和aadv的输出自动调整β，这分别代表了它们的攻击有效性。我们给出了自动调谐机制：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211339178.png" alt="image-20210603141233344" style="zoom:50%;"></p>
<p>如果xadv比aadv更有效，那么D到xadv的输出期望就更大。自动机构将增加β
间接提高aadv的学习率。我们将在实验中证明它的有效性。</p>
<p>【介绍动态蒸馏】</p>
<p><strong>判别器：</strong>我们使用鉴别器D来动态提取目标黑盒模型f。更具体地说，我们从数据池中采样一批混合数据，通过查询f来获得标签。样本及其相应的标签用于基于距离度量H拟合D。D的蒸馏损失为：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211339381.png" alt="image-20210603141837636" style="zoom:50%;"></p>
<p>D试图学习f对xben和xadv的决策策略。通过这种方式，D被视为替代检测器，用于将对抗性样本的攻击有效性转移到最终目标黑盒模型f。</p>
<p><strong>动态阈值策略</strong>：在攻击过程中，我们将生成敌方样本并保存在本地。然而，我们发现<strong>当我们将对抗性样本从对抗性连续空间映射回二进制的离散空间时，细微的扰动将被忽略。大部分包含攻击有效性的有效载荷将被忽略</strong>，因为它们的值很小。为了解决这个问题，我们建议使用动态阈值策略来限制有效载荷的最小值：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211339142.png" alt="image-20210603143629837" style="zoom:50%;"></p>
<p>其中<strong>e</strong>表示有效载荷中的每个字节，<strong>i</strong>是当前训练迭代时间，<strong>Tmax</strong>是最大训练迭代时间，<strong>西格玛</strong>是最大阈值。我们直接将具有小值的字节设置为阈值以下的零。然而，<strong>如果我们使用静态阈值，G的学习过程将会丢失</strong>。如果一个字节的值很小，但有一定的攻击效果，它首先会被设置为零的阈值。<strong>然后G将继续对字节或其他相邻字节添加扰动</strong>，以提高该区域的对抗攻击效能。最后该字节或其他相邻字节将被修改，以填充设置为零的字节的对抗攻击损失。</p>
<p>值得注意的是，在我们设置后，所有的调整过程都将使用梯度下降算法自动执行 .
在上述工作的基础上，黑匣子攻击对恶意软件检测的总体算法如算法1所示。在第5节中，我们将展示我们的攻击实验的细节。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338898.png" alt="image-20220606212943284" style="zoom:50%;"></p>
<h3><span id="四-实验装置experimentalsetup">四、实验装置（EXPERIMENTAL
SETUP）</span></h3>
<p>本节介绍了我们的攻击实验准备工作，包括<strong>数据集</strong>、<strong>评估指标</strong>以及我们<strong>选择和训练的目标模型</strong>。</p>
<h4><span id="41-数据集">4.1 <strong>数据集</strong></span></h4>
<blockquote>
<p>研究二进制文件长度对攻击的影响</p>
</blockquote>
<p>恶意软件和良性软件数据从不同来源收集，用于我们的对抗性攻击实验，如表1所示。恶意软件样本从<strong>VirusTotal4</strong>和<strong>Microsoft恶意软件分类挑战赛</strong>（Kaggle
2015）下载【22】。良性软件示例由Windows软件包管理器<strong>Chocolate
Software5下载</strong>。将数据分为四个数据集，使恶意软件的二进制长度分布接近每个数据集中的良性软件。使用具有不同最大和平均长度的数据集1、2和3来<strong>研究二进制文件长度对攻击的影响</strong>。数据集2和数据集4具有不同的来源，但长度分布很近，用于<strong>评估攻击算法的泛化</strong>。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338455.png" alt="image-20210603152949793" style="zoom:50%;"></p>
<p><strong>评估方法：</strong>攻击成功率（ASR）指标</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338962.png" alt="image-20210603153146322" style="zoom:50%;"></p>
<h4><span id="42-target-black-box-models">4.2 Target Black-box Models</span></h4>
<blockquote>
<p>四种目标模型</p>
</blockquote>
<p>我们选择最先进的恶意软件检测器MalConv[21]作为我们的主要目标黑箱模型。MalConv首先将输入二进制文件中的每个字节嵌入到8维向量中，然后使用两个具有不同激活函数的卷积层进行分类。我们为每个数据集训练一个输入大小为2000000的MalConv检测器。表2显示了每个MalConv探测器在培训后的测试精度。它表明，经过训练的MalConv检测器具有与[21]中类似的性能。</p>
<p>为了测试对抗攻击方法的泛化性，我们还使用了四种不同结构的深度学习模型作为目标模型。为了减少输入二进制文件的大尺寸，我们考虑在每个深度学习模型中添加CNN结构。输入二进制文件中的每个字节都以与MalConv相同的方式嵌入到8维向量中。我们在数据集2和4上训练这四个模型，检测精度如表2所示。结果表明，这四种检测器也达到了较好的分类精度。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338337.png" alt="image-20220524173957601" style="zoom:50%;"></p>
<h3><span id="五-experimental-results">五、EXPERIMENTAL RESULTS</span></h3>
<p>在本节中，我们将展示GAPGAN在对抗性攻击实验中的有效性。我们还将其与不同防御下的其他最先进的攻击方法进行了比较。</p>
<p>我们首先应用GAPGAN以不同长度的对抗性有效载荷攻击四个经过训练的MalConv（我们在上一节中展示了它们）。有效负载率用于表示有效负载长度与二进制文件长度的比率，以进行检测。根据表3所示的对不同数据集的攻击性能，可以看出GAPGAN可以对MalConv模型执行有效的黑盒攻击。从数据集2和数据集4的结果可以看出，敌对样本对不同数据的攻击成功率较高。此外，由于有效载荷率的增加，原始长度较短的对抗性二进制文件可能具有更好的攻击效果。<strong>值得一提的是，从数据集1生成的对抗性样本的ASR可以达到100%，只有一小部分有效载荷，即检测数据总长度的2.5%</strong>。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338843.png" alt="image-20210603152949793" style="zoom:50%;"></p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338632.png" alt="image-20220524175422368" style="zoom:50%;"></p>
<p>我们发现，当ASR已经达到很高的值时，使用较大的有效负载可能只会提高很少的攻击成功率（例如，当附加10%的有效负载时，ASR为98.21%，但当附加两倍长度的有效负载时，ASR仅提高1.79%）。然而，随着有效载荷长度的增加，被检测的风险和成本将增加。同时，为了证明GAPGAN生成的对抗性有效载荷的有效性，我们将其与随机有效载荷进行比较，如图2所示。我们发现，<strong>与随机生成的有效载荷相比</strong>，具有GAPGAN生成的有效载荷的对抗性样本具有更好的攻击效果。还可以看出，<strong>随机有效载荷的ASR与有效载荷率成正比，而对抗性有效载荷随着有效载荷率的增加而迅速增加</strong>，当达到较高值时，ASR的增长速度减慢。我们认为，每个数据集都存在最佳的有效负载率，即当附加较大的有效负载时，ASR的增长率将快速下降。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338959.png" alt="image-20220524174337289" style="zoom:50%;"></p>
<h4><span id="52-与最新攻击方法的比较">5.2 与最新攻击方法的比较</span></h4>
<blockquote>
<p>黑盒、速度、攻击等级</p>
<ol type="1">
<li><p><strong>基于梯度优化的方法</strong>：Adversarial malware
binaries: Evading deep learning for malware detection in
executables</p></li>
<li><p><strong>基于API调用序列的AdvSeq方法</strong>：Generic black-box
end-to-end attack against state of the art API call based malware
classifiers</p></li>
<li><p><strong>基于API调用序列的MalGAN</strong></p></li>
</ol>
</blockquote>
<p>我们将GAPGAN与恶意软件检测任务中其他最先进的对抗性攻击方法进行了比较，即Opt。<strong>基于梯度优化的方法</strong>【14】、<strong>基于API调用序列的AdvSeq方法</strong>【23】和<strong>基于API调用和GANs的MalGAN方法</strong>【11】。其结果如表4所示。可以看出，只有Opt。方法在白盒设置中执行攻击。从攻击效率的角度来看，一旦攻击模型得到训练，GAPGAN和MalGAN生成对抗性样本的速度远远快于其他方法（AdvSeq也基于复杂的优化过程，这被认为是无效的）。然而，只有GAPGAN在字节级别执行有效的黑盒攻击，这在现实场景中更具威胁性。为了进一步探索针对基于二进制文件的检测的攻击方法的有效性，我们选择比较GAPGAN和Opt。方法，即字节级攻击方法。选择具有随机有效载荷的对抗性样本进行比较。从表5可以看出，这两种攻击方法对不同的检测器都具有良好的攻击性能。然而，GAPGAN执行高效的黑盒攻击，这被认为是应用程序中对抗性攻击的关键。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338268.png" alt="image-20220524174702187" style="zoom:50%;"></p>
<p><strong>针对二进制文件检测的攻击方法的有效性，我们选择GAPGAN和Opt进行比较</strong>，两种攻击方法对不同的检测器都有很好的攻击性能。然而，GAPGAN执行高效的黑盒攻击，这对于应用中的对抗性攻击至关重要。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338553.png" alt="image-20210603162247046" style="zoom:50%;"></p>
<h4><span id="53-不同防御方式下的攻击性能">5.3 不同防御方式下的攻击性能</span></h4>
<p>人们提出了许多防御方法来防御各种攻击。使模型对对抗性样本具有鲁棒性的最常用方法是<strong>对抗性训练</strong>[7]，它在训练过程中引入对抗性扰动，使深度学习模型调整决策策略。另一种有效的防御方法[26]<strong>随机消除输入数据</strong>，以消除对抗性样本的攻击有效性。我们比较了随机有效载荷与GAPGAN和Opt生成的对抗性样本的攻击效果。在这些防御之下。为了模拟真实场景，我们假设攻击者不知道有关防御的任何信息。<strong>在RND防御方法的实验中，我们随机消除10%的输入数据，并测试对抗样本的攻击成功率</strong>。由于检测器的结构包含一个嵌入层，因此在对抗性训练防御方法中无法传递梯度。因此，我们建议使用用于提取检测器的替代模型来生成具有对抗性干扰的训练数据。新的训练数据用于提高检测器的鲁棒性。使用之前的探测器生成的对抗性样本将在重新培训的探测器上进行评估。表6显示了防御攻击的结果。我们表明，在大多数情况下，GAPGAN的攻击性能优于Opt。方法，尤其是在对抗性训练的防守下。一种可能的解释是Opt。该方法过度依赖于目标模型的结构和梯度信息。此外，有效载荷中的一个字节由Opt根据当前敌对样本的梯度生成。方法在RND防御的随机置零过程中，当字节之间的连接被切断时，攻击的有效性会受到很大的损害。相比之下，GAPGAN考虑了整个对手样本的攻击能力，使其在防御下更有效。</p>
<blockquote>
<p>为了防御各种攻击，人们提出了许多防御方法。使模型对对抗性样本具有鲁棒性的最常用方法是<strong><em>对抗性训练Explaining
and harnessing adversarial
examples</em></strong>，它在训练过程中引入对抗性扰动，使深度学习模型调整决策策略。另一种有效的防御方法<strong><em>随机消除输入数据
Adversary resistant deep neural networks with an application to malware
detection</em></strong>，以消除对手样本的攻击效果。我们比较了随机有效载荷与GAPGAN和Opt生成的对抗样本的攻击效果。在这些防御之下。</p>
<p><strong>在大多数情况下，GAPGAN的攻击性能优于Opt。方法，尤指在对抗性训练的防守下。</strong></p>
</blockquote>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338852.png" alt="image-20220524175324124" style="zoom:50%;"></p>
<h4><span id="54-动态参数的使用效果">5.4 动态参数的使用效果</span></h4>
<blockquote>
<p>集成比列调节</p>
</blockquote>
<p><strong>W</strong>: without using the method; <strong>S</strong>:
using static parameter<strong>; D</strong>: using dynamic parameter</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211338844.png" alt="image-20210603164901344" style="zoom:50%;"></p>
<p><strong>动态阈值和自动权重调整策略显著提高了对抗性样本的有效性</strong></p>
<h3><span id="六-结论">六、结论</span></h3>
<p>​
在本文中，我们基于GAN的思想提出了一个对抗性攻击框架GAPGAN来生成对抗性样本，以对抗基于二进制文件的恶意软件检测。在我们的模型中，我们将<strong>生成器生成的对抗性有效负载附加到原始恶意软件二进制文件中，以在不破坏其原始功能的情况下创建一个对抗性示例</strong>。实验表明，GAPGAN可以有效地攻击最先进的检测器MalConv以及其他不同结构的深度学习模型。结果还表明，<strong>在现有防御机制下，我们的模型在效率和有效性上都优于其他最先进的攻击方法</strong>。GAPGAN是第一个实用的针对恶意软件检测的端到端黑盒攻击框架，对下一代流行的检测技术，即基于原始二进制文件的恶意软件检测构成威胁。虽然我们的工作集中在恶意软件二进制文件，它可以很容易地扩展到其他领域，如对抗性文本或图形生成。这使得GAPGAN成为一个很有前途的攻击框架，用于提高恶意软件检测或其他任务防御方法的健壮性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/GW7NEC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/GW7NEC/" class="post-title-link" itemprop="url">恶意软件检测（13）Dynamic Malware Analysis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-29 19:59:06" itemprop="dateCreated datePublished" datetime="2021-05-29T19:59:06+08:00">2021-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 16:24:26" itemprop="dateModified" datetime="2023-04-19T16:24:26+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">恶意软件检测</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="dynamicmalware-analysis-in-the-modern-eraa-state-of-the-art-survey">Dynamic
Malware Analysis in the Modern Era—A State of the Art Survey</span></h2>
<p>​
本次调查的目的是对用于动态分析恶意软件的现有方法进行全面和最新的概述，其中包括对每种方法的<strong>描述</strong>、其<strong>优缺点</strong>以及对<strong>恶意软件规避技术的适应性</strong>。此外，我们还概述了利用机器学习方法来增强动态恶意软件分析能力的一些重要研究，这些研究旨在检测、分类和分类。</p>
<h4><span id="学习内容">学习内容：</span></h4>
<ul>
<li>分析方法：<strong>易失性内存取证（volatile memory
forensics）、侧通道分析（side-channel analysis）</strong></li>
</ul>
<h4><span id="动态分析的意义">动态分析的意义：</span></h4>
<ol type="1">
<li>虽然恶意软件编写者可以使用各种技术（如代码混淆、动态代码加载、加密和打包）来逃避静态分析（包括基于签名的防病毒工具）态分析对这些技术是健壮的，并且可以提供关于所分析文件的更多理解，因此可以导致更好的检测能力。</li>
</ol>
<h4><span id="动态分析的局限性">动态分析的局限性：</span></h4>
<ul>
<li>只有执行的代码是可观察的。这意味着，如果没有精确地满足所需的条件，那么某些代码可能无法执行，从而无法进行分析。<strong>Deeplocker</strong></li>
<li>动态分析还需要计算开销，这可能会降低执行速度。</li>
<li>分析必须在恶意软件针对的特定操作系统和/或硬件上执行。</li>
</ul>
<h4><span id="说明">说明：</span></h4>
<ul>
<li>物联网设备是另一个可以受益于内存分析的平台示例，因为基于软件的新检测机制的设计和安装并不简单。此外，由于物联网设备具有有限的计算资源，现有的动态分析技术对于此类设备可能不太相关或有效。</li>
</ul>
<h4><span id="恶意软件分类">恶意软件分类</span></h4>
<ul>
<li>Classification of Malware by Type</li>
<li>Classification of Malware by Malicious Behavior</li>
<li>Classification of Malware by Privilege</li>
<li>About Behavior and Privilege</li>
</ul>
<h4><span id="analyzing-malware-behavior">ANALYZING MALWARE BEHAVIOR</span></h4>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191623702.png" alt="image-20210529200406017">
<figcaption aria-hidden="true">image-20210529200406017</figcaption>
</figure>
<h4><span id="动态恶意软件分析框架描述">动态恶意软件分析框架描述</span></h4>
<h4><span id="分析技术和学术工具">分析技术和学术工具</span></h4>
<ul>
<li><h5><span id="函数功能分析">函数功能分析</span></h5>
<ul>
<li>每个进程都依赖函数调用来执行其职责，不管这些函数是进程内部的还是外部的（例如，由其他进程导出的函数、系统调用）。通过跟踪恶意软件调用的各种函数以及与这些函数相关的参数，可以更好地了解所分析恶意软件的行为。调用函数时获取通知可以通过将一段代码<strong>Hooking</strong>到该函数来实现。
<ul>
<li>hooking mechanism</li>
<li>code injection</li>
</ul></li>
<li><strong>TTAnalyze(LastLine)</strong>是一个分析工具，它用一个称为Inside
the
Matrix（insideetm）的客户机组件扩展了QEMU仿真器，该组件将虚拟地址转换为物理地址。</li>
<li><strong>CWSandbox</strong>基于将可信DLL的代码注入到分析的进程中，该进程通过覆盖导出地址表（EAT）中的条目并将执行重定向到CWSandbox来拦截函数调用。CWSandbox收集大量的信息（比如被调用函数的名称、参数、系统状态等），然后将这些信息呈现给用户。</li>
<li><strong>Capture</strong>使用三个监视器分析操作系统的状态：<strong>文件系统监视器</strong>（跟踪所有硬盘上的读/写事件）、<strong>注册表监视器</strong>（跟踪多个注册表事件，如OpenKey、CreateKey等）和<strong>进程监视器</strong>（跟踪进程的创建和终止）。所有监视器都提供其他数据，如触发事件的进程、完整路径和时间戳。使用内核驱动程序，捕获与上述每个监视器对应的内核事件。最终结果是恶意软件触发的事件列表，以及它们的时间戳和参数。</li>
<li><strong>MalTRAK</strong>是一个跟踪恶意软件行为并扭转其影响的框架。它使用内核模式组件并将自身与关键函数挂钩，以跟踪恶意软件的操作，同时提供撤消这些操作的机制。</li>
<li><strong>dAnubis</strong>是用来分析内核驱动程序和检测rootkit的。它使用一个in-guest组件来监视rootkit和系统其余部分之间的通信。触发器引擎调用各种windowsapi调用来显示<strong>rootkit（定义为一组在恶意软件中获得root访问权限、完全控制目标操作系统和其底层硬件的技术编码）</strong>的存在（例如，隐藏的进程或文件）。</li>
</ul></li>
<li><h5><span id="execution-control-执行控制">Execution Control 执行控制</span></h5>
<p>动态恶意软件分析应该包含一种机制，偶尔停止恶意软件的执行，并检查恶意进程和操作系统的状态。执行控制技术包括：</p>
<ul>
<li><strong>Debugging</strong>调试（也称为单步）是一种可靠的分析技术，最初是为了帮助程序员发现代码中的错误而开发的。使用CPU的陷阱标志在每个操作码指令后生成中断，调试器可以允许恶意软件在强制上下文切换回分析进程之前只运行一条操作码指令，然后分析进程可以检查恶意软件和操作系统的状态。</li>
<li>等</li>
</ul></li>
<li><p><strong>Flow Tracking 流量跟踪</strong></p>
<p>细粒度分析用于跟踪通过恶意软件执行代码的信息流（例如，当一个函数的结果用作调用另一个函数的参数时）。</p>
<ul>
<li><strong>Data Tainting</strong></li>
<li><strong>Vigilite</strong>是一种分析工具，它使用二进制工具实现数据污染。最初是为了检测和阻止蠕虫的传播而开发的，Vigilite寻找来自网络的受污染数据的执行。因此，污点源是网络，当指令指针（IP）指向污点数据时，污点接收器就到达了，这意味着一些来自网络的不可信代码正在被执行。</li>
<li><strong>Panorama</strong>最初是一个TEMU插件，用于对各种I/O设备（包括硬盘、键盘或鼠标）进行污染分析。后来成为一个独立的平台。全景图的输出是以图形的形式提供的，它允许用户跟踪进程和内存区域之间的数据流。</li>
<li><strong>Dytan</strong>是Pin仪器系统的一个扩展，为数据污染提供了一个易于使用的API。它的开发采用了灵活的设计，允许用户配置各种组件，如污染源、污染汇、数据流跟踪器和控制流跟踪器。Dytan可以配置为跟踪显式和隐式信息流。此外，它的功能可以通过使用回调函数来扩展，回调函数实现额外的污染源、标签、传播和接收器。</li>
<li><strong>TQana</strong>是一个构建在QEMU之上的框架，用于分析和检测安装在internetexplorer上的恶意浏览器扩展。它使用带有两个污点源的数据污点：（1）用户访问的页面的所有URL字符串和（2）浏览器收到的响应其请求的信息。污点接收器是文件系统、注册表和网络。当受污染的数据被写入文件或通过网络发送时，被分析的样本就被怀疑是间谍软件。</li>
</ul></li>
<li><p><strong>Tracing 追踪</strong></p>
<p>收集执行某些代码后留下的信息称为跟踪。网络连接和分配给恶意软件的内存会留下恶意软件行为的痕迹。分析这些痕迹可以提供有关恶意软件的见解，而无需使用客户端组件中的。</p>
<ul>
<li><strong>Volatile memory analysis
易失性内存分析分析</strong>从内存转储文件分析恶意软件的影响（见第6.5节）需要了解操作系统如何跟踪进程、文件、用户和配置。所有这些数据结构都以二进制形式存在于内存转储中。</li>
<li><strong>Network Tracing</strong>
网络跟踪由于恶意软件在大多数情况下需要连接Internet才能执行其操作，因此在没有Internet访问的情况下，可能无法显示恶意软件的确切性质。然而，允许恶意软件完全访问互联网有时是不可取或不可能的。通过恶意软件限制网络访问并分析网络连接可以揭示恶意软件的C&amp;C和从中收到的命令。恶意软件留下的网络痕迹有助于理解其呈现的通信模式。</li>
<li><strong>HookFinder</strong>是TEMU实现的另一部分，旨在通过分析易失性内存来检测和分析恶意钩子。在堆栈中找到的信息被转换为创建钩子图，这有助于识别钩子链。然后，HookFinder将属于恶意软件的内存段标记为污点接收器。为了验证钩子实际上是由恶意软件安装的，HookFinder调用各种函数调用，并通过检查指令指针（IP）来跟踪控制流。当IP指向受污染的内存时，恶意钩子就会被发现并验证。</li>
<li><strong>LiveDM</strong>利用QEMU来分析内核中新内存区域的分配。通过挂接操作系统实现的几个内存分配函数，它可以跟踪恶意软件的安装位置，并对恶意软件的二进制代码执行静态分析。使用模拟器对客户操作系统的控制，LiveDM能够获得客户操作系统的易失性内存并分析受感染的内核。</li>
<li>等</li>
</ul></li>
<li><p><strong>Side-channel Analysis</strong></p>
<ul>
<li>到目前为止提出的分析技术依赖于从操作系统、易失性存储器或仿真机器的状态中提取数据。然而，任何类型的计算设备都可能成为恶意软件的攻击目标。这些设备包括PCI卡、物联网设备、硬盘、医疗设备等。分析和检测这些设备上运行的恶意软件是困难的，因为大多数情况下，这些设备不包含一个操作系统，可以支持传统的分析技术。与从操作系统的角度（或二进制级别）跟踪系统的行为不同，<strong>可以通过物理组件的功耗、电磁辐射或内部CPU事件来分析它们的行为</strong>。获取的数据分为“正常行为”和“感染行为”。使用统计方法和机器学习算法，检测到偏离正常行为可能表明CPU行为异常（例如，存在cryptominer或rootkit）。侧通道分析无法提供有关操作系统、网络或正在修改的文件的内部事件的深入信息。没有向仅仅收到最终判决的用户提供报告（称为恶意或非恶意）。</li>
<li><strong>WattsUpDoc</strong>是一种分析工具，用于使用外部设备对医疗设备进行侧信道分析。它证明了侧通道分析可以用于分析没有操作系统的设备，而无需向分析的设备加载任何代码。</li>
</ul></li>
</ul>
<h4><span id="布局映射技术mappingtechniques-to-layouts">布局映射技术（MAPPING
TECHNIQUES TO LAYOUTS）</span></h4>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191624416.png" alt="image-20210531145449113">
<figcaption aria-hidden="true">image-20210531145449113</figcaption>
</figure>
<p>​
恶意软件和分析工具之间的战争是一场军备竞赛。攻击者不断开发新的方法来规避和检测分析框架，同时负责检测恶意软件的分析框架和工具的能力也在不断提高。创建图13是为了帮助读者理解这场军备竞赛以及<strong>攻击者和分析人员使用的不同方法</strong>。</p>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191624015.png" alt="image-20210531150025715">
<figcaption aria-hidden="true">image-20210531150025715</figcaption>
</figure>
<h4><span id="综合比较研究">综合比较研究</span></h4>
<p>本部分比较了近年来动态恶意软件分析的研究，并讨论了与此相关的趋势和参数。进行此比较，我们可以发现一些重要的见解，我们也与读者分享。</p>
<ul>
<li><p>基于功能和实际方面的比较</p>
<ul>
<li><p>我们的比较基于以下几个关键方面：</p>
<p>（1）该工具的相关性（其对科学界的影响和贡献基于引文数量和是否开源），</p>
<p>（2）该工具提供的分析的多功能性，</p>
<p>（3）用于实现该工具的分析布局（见第6节），</p>
<p>（4）工具的限制（预分析要求、所依赖的附加软件、特殊要求的硬件）和</p>
<p>（5）工具提供的输出。请注意，这些工具是按分析技术分组的，在每种技术中，它们是按出版年份排序的。关于图14的详细说明如下：</p></li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2WTQDCR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2WTQDCR/" class="post-title-link" itemprop="url">算法长征-代码随想录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-07 22:20:59" itemprop="dateCreated datePublished" datetime="2021-05-07T22:20:59+08:00">2021-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-19 14:08:37" itemprop="dateModified" datetime="2022-05-19T14:08:37+08:00">2022-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">【draft】工程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%B7%A5%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a></li>
<li><a href>labuladong</a></li>
</ul>
<h2><span id="一-树状数组">一、树状数组</span></h2>
<p>leecode 题目：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">数组中的逆序对</a></p>
<blockquote>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<p>示例 1:</p>
<p>输入: [7,5,6,4] 输出: 5</p>
</blockquote>
<p><strong>「树状数组」</strong>是一种可以<strong>动态维护序列前缀和</strong>的数据结构，它的功能是：</p>
<ul>
<li><strong>单点更新<code>update(i, v)</code></strong>:把序列 <span class="math inline">\(i\)</span> 位置的数加上一个值<span class="math inline">\(v\)</span>，这题 v = 1</li>
<li><strong>区间查询 <code>query(i)</code>：</strong>
查询序列[1⋯<em>i</em>] 区间的区间和，即 <em>i</em> 位置的前缀和</li>
</ul>
<p>修改和查询的时间代价都是 <span class="math inline">\(O(\log
n)\)</span>，其中 <em>n</em> 为需要维护前缀和的序列的长度。</p>
<h2><span id="二-单调栈">二、单调栈</span></h2>
<p>通常是一维数组，要==寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置==，此时我们就要想到可以用<strong>单调栈</strong>了。</p>
<ul>
<li><p><strong>单调栈里存放的元素是什么？</strong></p>
<p>单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p></li>
<li><p><strong>单调栈里元素是递增呢？ 还是递减呢？</strong></p>
<p><strong>注意一下顺序为
从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定会越看越懵。</p></li>
<li><p><strong>目标列表遍历顺序？</strong> 倒序？正序？</p></li>
</ul>
<h3><span id="21-下一个更大元素">2.1 下一个更大元素</span></h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># 下一个更大的元素：单调栈(不增的不要) + 哈希 </span></span><br><span class="line">    res = &#123;&#125;</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">reversed</span>(nums2): <span class="comment"># 倒序？</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt;= stack[-<span class="number">1</span>]:</span><br><span class="line">            stack.pop()</span><br><span class="line">        res[num] = stack[-<span class="number">1</span>] <span class="keyword">if</span> stack <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        stack.append(num)</span><br><span class="line">    <span class="keyword">return</span> [res[num] <span class="keyword">for</span> num <span class="keyword">in</span> nums1]</span><br></pre></td></tr></table></figure>
<h3><span id="21下一个更大元素2循环数组又tm是循环">2.1
下一个更大元素2（循环数组）又TM是循环</span></h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 三次逆转</span></span><br><span class="line">        s = <span class="built_in">list</span>(nums[::-<span class="number">1</span>])</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums[::-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">while</span> s <span class="keyword">and</span> s[-<span class="number">1</span>] &lt;= num:</span><br><span class="line">                s.pop()</span><br><span class="line">            <span class="keyword">if</span> s:</span><br><span class="line">                res.append(s[-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(-<span class="number">1</span>)</span><br><span class="line">            s.append(num)</span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    def nextGreaterElements(self, nums: List[int]) -&gt; List[int]:</span></span><br><span class="line"><span class="string">        # 2n 遍历</span></span><br><span class="line"><span class="string">        n = len(nums)</span></span><br><span class="line"><span class="string">        ret = [-1] * n</span></span><br><span class="line"><span class="string">        stk = list()</span></span><br><span class="line"><span class="string">        for i in range(n * 2 - 1):</span></span><br><span class="line"><span class="string">            while stk and nums[stk[-1]] &lt; nums[i % n]:</span></span><br><span class="line"><span class="string">                ret[stk.pop()] = nums[i % n]</span></span><br><span class="line"><span class="string">            stk.append(i % n)</span></span><br><span class="line"><span class="string">        return ret</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    def nextGreaterElements(self, nums: List[int]) -&gt; List[int]:</span></span><br><span class="line"><span class="string">        # 栈留判断</span></span><br><span class="line"><span class="string">        n = len(nums)</span></span><br><span class="line"><span class="string">        ans = [-1 for _ in range(n)]</span></span><br><span class="line"><span class="string">        stack = [0]</span></span><br><span class="line"><span class="string">        stack2 = []</span></span><br><span class="line"><span class="string">        for i in range(1, n):</span></span><br><span class="line"><span class="string">            while stack and nums[i] &gt; nums[stack[-1]]: # ？</span></span><br><span class="line"><span class="string">                ans[stack[-1]] = nums[i]</span></span><br><span class="line"><span class="string">                stack.pop() </span></span><br><span class="line"><span class="string">            stack.append(i)</span></span><br><span class="line"><span class="string">        while len(stack) &gt; 1: # 栈顶是最大的保留</span></span><br><span class="line"><span class="string">            for num in nums: # 从头找？</span></span><br><span class="line"><span class="string">                if num &gt; nums[stack[-1]]:</span></span><br><span class="line"><span class="string">                    ans[stack[-1]] = num</span></span><br><span class="line"><span class="string">                    break</span></span><br><span class="line"><span class="string">            stack.pop()</span></span><br><span class="line"><span class="string">        return ans</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h3><span id="23-每日温度">2.3 每日温度</span></h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dailyTemperatures</span>(<span class="params">self, temperatures: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># next Geater </span></span><br><span class="line">    n = <span class="built_in">len</span>(temperatures)</span><br><span class="line">    res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">    stack = [<span class="number">0</span>] <span class="comment"># 存的初始索引</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n): <span class="comment"># 正序</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> temperatures[i] &gt; temperatures[stack[-<span class="number">1</span>]]:</span><br><span class="line">            res[stack[-<span class="number">1</span>]] = i - stack[-<span class="number">1</span>]  <span class="comment"># stack[-1]</span></span><br><span class="line">            stack.pop() </span><br><span class="line">        stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3><span id="24-接雨水">2.4 接雨水</span></h3>
<p>接雨水是找每个柱子<strong>左右两边第一个大于该柱子高度的柱子</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 单调栈 左 弹出后 s.top() 中 s.pop()  右 height[i]</span></span><br><span class="line">    n = <span class="built_in">len</span>(height)</span><br><span class="line">    stack = [<span class="number">0</span>]</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> height[i] &gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">            mid = stack.pop() <span class="comment"># 弹一个左面还有的话就是有坑</span></span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                high = <span class="built_in">min</span>(height[stack[-<span class="number">1</span>]], height[i]) - height[mid] </span><br><span class="line">                <span class="comment"># 高 = 左右最小 - 低</span></span><br><span class="line">                weith = i - stack[-<span class="number">1</span>] - <span class="number">1</span> <span class="comment"># 宽</span></span><br><span class="line">                res += weith * high </span><br><span class="line">        stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3><span id="25-柱状图的最大矩形">2.5 柱状图的最大矩形</span></h3>
<p><strong>找每个柱子左右两边第一个小于该柱子的柱子。</strong>：==<strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</strong>==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">largestRectangleArea</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 单调栈 左右两边都可以用</span></span><br><span class="line">    heights.insert(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    heights.append(<span class="number">0</span>)</span><br><span class="line">    stack = [<span class="number">0</span>]</span><br><span class="line">    ans = heights[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(heights)):</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">and</span> heights[i] &lt; heights[stack[-<span class="number">1</span>]]:</span><br><span class="line">            mid = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> stack: <span class="comment"># 存在左右最小</span></span><br><span class="line">                weith = i - stack[-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">                <span class="comment"># high = max(heights[i], heights[stack[-1]])</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, heights[mid] * weith)</span><br><span class="line">        stack.append(i)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h2><span id="三-单调队列">三、单调队列</span></h2>
<h2><span id="四-贪心算法"></span></h2>
<p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png" alt="贪心算法大纲"></p>
<h3><span id="什么是贪心">什么是贪心</span></h3>
<p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<h3><span id="贪心一般解题步骤">贪心一般解题步骤</span></h3>
<p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<h2><span id="五-动态规划"></span></h2>
<figure>
<img src="https://images.zsxq.com/FvoG8qppuOWSNhXBbj27ShBAJw0G?imageMogr2/auto-orient/quality/100!/ignore-error/1&amp;e=1648742399&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:q36Nzw1NTcg-NvuvnNyOWSZ_mdI=" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>首先，动态规划问题的一般形式就是==求最值==</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。<strong>求解动态规划的核心问题是穷举</strong>。首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「==备忘录」或者「DP
table」==来优化穷举过程，避免不必要的计算。而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>，才能正确地穷举。</p>
<p>以上提到的<strong>重叠子问题、最优子结构、状态转移方程</strong>就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<h3><span id="51-背包问题"><strong>5.1 背包问题</strong></span></h3>
<p>https://leetcode-cn.com/problems/coin-change/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-wan-q-80r7/</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1">
<figcaption aria-hidden="true">416.分割等和子集1</figcaption>
</figure>
<blockquote>
<p><strong>1、确定dp数组以及下标的含义</strong></p>
<p><strong>2、确定递推公式</strong></p>
<p><strong>3、dp数组如何初始化</strong></p>
<ul>
<li><strong>最大长度</strong></li>
<li><strong>递推等号左侧要初始化</strong></li>
</ul>
<p><strong>4、确定遍历顺序</strong></p>
<ul>
<li><strong>滚动数组</strong></li>
</ul>
<p><strong>5、举例推导dp数组</strong></p>
</blockquote>
<h4><span id="511-背包递推公式">5.1.1 背包递推公式</span></h4>
<p><strong>问==能否装满背包==</strong>（或者<strong>最多装多少</strong>）：dp[j]
= max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.分割等和子集.html">动态规划：416.分割等和子集(opens
new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">划分为k个相等的子集</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/1049.最后一块石头的重量II.html">动态规划：1049.最后一块石头的重量
II</a></li>
</ul>
<p><strong>==问装满背包有几种方法==</strong>：dp[j] += dp[j - nums[i]]
，对应题目如下：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.目标和.html">动态规划：494.目标和(opens
new window)</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.
零钱兑换 II(opens new window)</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0377.组合总和Ⅳ.html">动态规划：377.组合总和Ⅳ(opens
new window)</a></p>
<blockquote>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
</blockquote></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯完全背包版本.html">动态规划：70.
爬楼梯进阶版（完全背包）</a></p></li>
</ul>
<p><strong>问背包装满==最大价值==</strong>：dp[j] = max(dp[j], dp[j -
weight[i]] + value[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0474.一和零.html">动态规划：474.一和零</a></li>
</ul>
<p><strong>问装满背包所有物品的==最小个数==</strong>：dp[j] = min(dp[j -
coins[i]] + 1, dp[j]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0322.零钱兑换.html">动态规划：322.零钱兑换(opens
new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0279.完全平方数.html">动态规划：279.完全平方数(opens
new window)</a></li>
</ul>
<h4><span id="512-遍历顺序">5.1.2 遍历顺序</span></h4>
<h5><span id="01背包">01背包</span></h5>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！
(opens new
window)</a>中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
<p>和<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）
(opens new
window)</a>中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p>
<p><strong>一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！</strong></p>
<h5><span id="完全背包">完全背包</span></h5>
<p>说完01背包，再看看完全背包。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包问题理论基础完全背包.html">动态规划：关于完全背包，你该了解这些！
(opens new
window)</a>中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
<p>但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。</p>
<p><strong>如果求==组合数==就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果==求排列数==就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>相关题目如下：</p>
<ul>
<li>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.零钱兑换II(opens
new window)</a></li>
<li>求排列数：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA">动态规划：377.
组合总和 Ⅳ (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯完全背包版本.html">动态规划：70.
爬楼梯进阶版（完全背包）(opens new window)</a></li>
</ul>
<p>如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：</p>
<ul>
<li>求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.零钱兑换.html">动态规划：322.
零钱兑换 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.完全平方数.html">动态规划：279.完全平方数(opens
new window)</a></li>
</ul>
<p><strong>对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了</strong>。</p>
<h3><span id="52-子序列问题">5.2 <strong>子序列问题</strong></span></h3>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg" alt="img" style="zoom:50%;"></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0300.最长上升子序列.html">动态规划：最长递增子序列</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 子序列 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]) <span class="comment">#取长的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li>
<li><h5><span id="动态规划最长斐波那契数列"></span></h5></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lenLongestFibSubseq</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 基本顺序是 k，i，j 或者 A[k] = A[j] - A[i]</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="comment"># 创建索引字典，提速</span></span><br><span class="line">    <span class="keyword">for</span> ind,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(A):</span><br><span class="line">        dic[val] = ind</span><br><span class="line">    <span class="comment"># 初始化，行代表的是i，不需要取到n-1，为了给j留出位置</span></span><br><span class="line">    <span class="comment"># 初始为2，只要包含了 j i 位置，则意味着已经有了2个数字。</span></span><br><span class="line">    dp = [[<span class="number">2</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>)]</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 因此i只能取到n-2，给j留出空间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># j从i+1开始，毕竟j在i后面</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">            diff = A[j] - A[i]</span><br><span class="line">            <span class="keyword">if</span> diff <span class="keyword">in</span> dic <span class="keyword">and</span> dic[diff] &lt; i:</span><br><span class="line">                k = dic[diff]</span><br><span class="line">                dp[i][j] = dp[k][i] + <span class="number">1</span> <span class="comment"># 这个1，代表着k位置数字</span></span><br><span class="line">                ret = <span class="built_in">max</span>(ret,dp[i][j])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0718.最长重复子数组.html">动态规划：最长重复子数组</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLength</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], B: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(B) + <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(A)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(B), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[i-<span class="number">1</span>] == B[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = dp[j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span> <span class="comment">#注意这里不相等的时候要有赋0的操作</span></span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[j])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/1143.最长公共子序列.html">动态规划：最长公共子序列</a>、
<a target="_blank" rel="noopener" href="https://programmercarl.com/1035.不相交的线.html">动态规划：不相交的线</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 最长子序列 </span></span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text2[j-<span class="number">1</span>] == text1[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0053.最大子序和（动态规划）.html">动态规划：最大子序和</a>
【贪心】【动态规划】</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 为什么dp[-1]不是最大？需要res</span></span><br><span class="line">    <span class="comment"># dp[i] 以i结尾的最大子数组和</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n)</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>]+nums[i], nums[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0392.判断子序列.html">动态规划：判断子序列</a>
【双指针】</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i == n</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0115.不同的子序列.html">动态规划：不同的子序列</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0583.两个字符串的删除操作.html">动态规划：两个字符串的删除操作</a></p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] : word1[i-1], word1[j-1] 最少步数</span></span><br><span class="line"><span class="comment"># word1[i - 1] 与 word2[j - 1]不相同的时候，有2种情况 *  min(dp[i-1][j], dp[i][j-1])+1  </span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            dp[j][<span class="number">0</span>] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])+<span class="number">1</span> <span class="comment"># , dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0072.编辑距离.html">动态规划：编辑距离</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/为了绝杀编辑距离，卡尔做了三步铺垫.html">为了绝杀编辑距离，我做了三步铺垫，你都知道么？</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0647.回文子串.html">动态规划：回文子串</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a>
==<a href="#manacher-算法">Manacher 算法</a>==</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中心扩展法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 枚举+中心扩展法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">extendCenter</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= left <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 返回的为while不成立的值</span></span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>, right-<span class="number">1</span> </span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            left1, right1 = extendCenter(i,i)</span><br><span class="line">            left2, right2 = extendCenter(i,i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> right1 - left1 &gt; end - start:</span><br><span class="line">                start, end = left1, right1</span><br><span class="line">            <span class="keyword">if</span> right2 - left2 &gt; end - start:</span><br><span class="line">                start, end = left2, right2</span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># dp[i][j]: 是否是回文 dp[i+1][j-1] -&gt; dp[i][j]</span></span><br><span class="line">    <span class="comment"># 返回的子串，不是数字 不能记录长度</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 右上为1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[i][i] = <span class="literal">True</span></span><br><span class="line">    begin = <span class="number">0</span></span><br><span class="line">    maxlen = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 判断是否是回文子串中，如果是则记录begin and len</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                <span class="keyword">if</span> j - i &lt;=<span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; maxlen:</span><br><span class="line">                maxlen = j - i + <span class="number">1</span></span><br><span class="line">                begin = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[begin:begin+maxlen]</span><br></pre></td></tr></table></figure>
<h4><span id="manacher-算法">Manacher 算法</span></h4>
<p><strong>Manacher
算法是在线性时间内求解最长回文子串的算法</strong>。在本题中，我们要求解回文串的个数，为什么也能使用
Manacher 算法呢？这里我们就需要理解一下 Manacher 的基本原理。</p>
<ul>
<li><p>奇偶长度处理： abaaabaa 会被处理成
#a#b#a#a##<em>a</em>#<em>b</em>#<em>a</em>#<em>a</em>#</p></li>
<li><p>==<strong><span class="math inline">\(f(i)\)</span></strong>
来表示以 s 的第 i 位为回文中心，可以拓展出的<strong>最大回文半径 （包括
# ）</strong>==，那么$ f(i) - 1$就是以 i 为中心的最大回文串长度
。</p></li>
<li><p>利用已经计算出来的状态来更新 f(i）：<strong>回文右端点rm</strong>
：i + f(i) - 1</p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0516.最长回文子序列.html">动态规划：最长回文子序列</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划 dp[i][j]: s[i:j] 最大回文长度</span></span><br><span class="line">        <span class="comment"># dp[i+1][j-1] -&gt; dp[i][j] 遍历顺序 and j - i &gt;=2</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * i +[<span class="number">1</span>] * (n-i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 从定义出发 右上三角 = 1 有意义</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n): <span class="comment"># j - i &gt;=2</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])                </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
<li><h5><span id="最少回文分割"></span></h5></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCut</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划1:判断回文</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        g = [[<span class="literal">True</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                g[i][j] = (s[i] == s[j]) <span class="keyword">and</span> g[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        f = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> g[<span class="number">0</span>][i]:</span><br><span class="line">                f[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                    <span class="keyword">if</span> g[j + <span class="number">1</span>][i]:</span><br><span class="line">                        <span class="comment"># （0, j) + (j+1, i)</span></span><br><span class="line">                        f[i] = <span class="built_in">min</span>(f[i], f[j] + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><h5><span id="最长连续序列"></span></h5></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        dic, res = <span class="built_in">dict</span>(), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                left, right = dic.get(num - <span class="number">1</span>, <span class="number">0</span>), dic.get(num + <span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                cur = <span class="number">1</span> + left +right</span><br><span class="line">                <span class="keyword">if</span> res &lt; cur:</span><br><span class="line">                    res = cur</span><br><span class="line">                dic[num] = cur</span><br><span class="line">                dic[num - left] = cur</span><br><span class="line">                dic[num + right] = cur</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3><span id="53-打家劫舍问题">5.3 打家劫舍问题</span></h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0198.打家劫舍.html">动态规划：开始打家劫舍</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0213.打家劫舍II.html">动态规划：继续打家劫舍
环</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0337.打家劫舍III.html">动态规划：还要打家劫舍
树状dp</a></li>
</ul>
<h3><span id="54-股票问题">5.4 股票问题</span></h3>
<figure>
<img src="https://code-thinking.cdn.bcebos.com/pics/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg" alt="股票问题总结">
<figcaption aria-hidden="true">股票问题总结</figcaption>
</figure>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0121.买卖股票的最佳时机.html">动态规划：121.买卖股票的最佳时机(opens
new window)</a> 股票只能买卖一次，问最大利润</p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html">动态规划：122.买卖股票的最佳时机II(opens
new window)</a> 可以多次买卖股票，问最大收益。</p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0123.买卖股票的最佳时机III.html">动态规划：123.买卖股票的最佳时机III(opens
new window)</a> 最多买卖两次，问最大收益。</p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0188.买卖股票的最佳时机IV.html">动态规划：188.买卖股票的最佳时机IV(opens
new window)</a> 最多买卖k笔交易，问最大收益。</p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0309.最佳买卖股票时机含冷冻期.html">动态规划：309.最佳买卖股票时机含冷冻期(opens
new window)</a> 可以多次买卖但每次卖出有冷冻期1天。</p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0714.买卖股票的最佳时机含手续费（动态规划）.html">动态规划：714.买卖股票的最佳时机含手续费(opens
new window)</a> 可以多次买卖，但每次有手续费。</p></li>
</ul>
<h3><span id="55-编辑距离问题">5.5 编辑距离问题</span></h3>
<h4><span id="判断子序列">判断子序列</span></h4>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0392.判断子序列.html">动态规划：392.判断子序列
(opens new window)</a>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>这道题目
其实是可以用<strong>双指针</strong>或者<strong>贪心</strong>的的，但是我在开篇的时候就说了这是编辑距离的入门题目，因为从题意中我们也可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。</p>
<ul>
<li>if (s[i - 1] == t[j - 1])
<ul>
<li>t中找到了一个字符在s中也出现了</li>
</ul></li>
<li>if (s[i - 1] != t[j - 1])
<ul>
<li>相当于t要删除元素，继续匹配</li>
</ul></li>
</ul>
<p>状态转移方程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4><span id="不同的子序列">不同的子序列</span></h4>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0115.不同的子序列.html">动态规划：115.不同的子序列
(opens new window)</a>给定一个字符串 s 和一个字符串 t ，计算在 s
的子序列中 t 出现的个数。</p>
<p>本题虽然也只有删除操作，不用考虑替换增加之类的，但相对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0392.判断子序列.html">动态规划：392.判断子序列
(opens new window)</a>就有难度了，这道题目双指针法可就做不了。</p>
<p>当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。</p>
<p>一部分是用s[i - 1]来匹配，那么个数为 dp[i - 1] [j - 1]</p>
<p>一部分是不用s[i - 1]来匹配，个数为 dp[i - 1] [j]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="两个字符串的删除操作">两个字符串的删除操作</span></h4>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0583.两个字符串的删除操作.html">动态规划：583.两个字符串的删除操作
(opens new window)</a>给定两个单词 word1 和 word2，找到使得 word1 和
word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0115.不同的子序列.html">动态规划：115.不同的子序列
(opens new
window)</a>相比，其实就是两个字符串可以都可以删除了，情况虽说复杂一些，但整体思路是不变的。</p>
<ul>
<li>当word1[i - 1] 与 word2[j - 1]相同的时候</li>
<li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li>
</ul>
<p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1] [j -
1];</p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有2种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1</p>
<p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="编辑距离">编辑距离</span></h4>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0072.编辑距离.html">动态规划：72.编辑距离
(opens new window)</a>给你两个单词 word1 和 word2，请你计算出将 word1
转换成 word2 所使用的最少操作数 。</p>
<p>编辑距离终于来了，<strong>有了前面三道题目的铺垫，应该有思路了</strong>，本题是两个字符串可以增删改，比
<a target="_blank" rel="noopener" href="https://programmercarl.com/0392.判断子序列.html">动态规划：判断子序列
(opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0115.不同的子序列.html">动态规划：不同的子序列
(opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0583.两个字符串的删除操作.html">动态规划：两个字符串的删除操作
(opens new window)</a>都要复杂的多。</p>
<p>在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：</p>
<ul>
<li>if (word1[i - 1] == word2[j - 1])
<ul>
<li>不操作</li>
</ul></li>
<li>if (word1[i - 1] != word2[j - 1])
<ul>
<li>增</li>
<li>删</li>
<li>换</li>
</ul></li>
</ul>
<p>也就是如上四种情况。</p>
<p>if (word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j]
就应该是 dp[i - 1] [j - 1]，即dp[i][j] = dp[i - 1] [j - 1];</p>
<p><strong>在整个动规的过程中，最为关键就是正确理解dp[i]
[j]的定义！</strong></p>
<p>if (word1[i - 1] != word2[j - 1])，此时就需要编辑了，如何编辑呢？</p>
<p>操作一：word1增加一个元素，使其word1[i - 1]与word2[j -
1]相同，那么就是以下标i-2为结尾的word1 与 i-1为结尾的word2的最近编辑距离
加上一个增加元素的操作。</p>
<p>即 dp[i][j] = dp[i - 1] [j] + 1;</p>
<p>操作二：word2添加一个元素，使其word1[i - 1]与word2[j -
1]相同，那么就是以下标i-1为结尾的word1 与 j-2为结尾的word2的最近编辑距离
加上一个增加元素的操作。</p>
<p>即 dp[i][j] = dp[i][j - 1] + 1;</p>
<p>这里有同学发现了，怎么都是添加元素，删除元素去哪了。</p>
<p><strong>word2添加一个元素，相当于word1删除一个元素</strong>，例如
word1 = "ad" ，word2 =
"a"，word2添加一个元素d，也就是相当于word1删除一个元素d，操作数是一样！</p>
<p>操作三：替换元素，word1替换word1[i - 1]，使其与word2[j -
1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与
j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。</p>
<p>即 dp[i][j] = dp[i - 1] [j - 1] + 1;</p>
<p>综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：dp[i] [j]
= min({dp[i - 1] [j - 1], dp[i - 1] [j], dp[i][j - 1]}) + 1;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="让字符串成为最小回文">==让字符串成为最小回文==</span></h3>
<p>https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/</p>
<h2><span id="六-回溯法">六、回溯法</span></h2>
<p><strong>一个决策树的遍历过程（回溯法）</strong>：一种通过探索所有可能的候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过在上一步进行一些变化抛弃该解，即回溯并且再次尝试。</p>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>组合问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：一个N个数的集合里有多少符合条件的子集</li>
<li>排列问题：N个数按一定规则全排列，有几种排列方式</li>
<li><strong>棋盘问题</strong>：N皇后，解数独等等</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/1QG49BK/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/1QG49BK/" class="post-title-link" itemprop="url">算法长征（11）动态规划</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-07 22:20:59" itemprop="dateCreated datePublished" datetime="2021-05-07T22:20:59+08:00">2021-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-27 12:14:11" itemprop="dateModified" datetime="2022-06-27T12:14:11+08:00">2022-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">【draft】工程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%B7%A5%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1><span id="五-动态规划"></span></h1>
<figure>
<img src="https://images.zsxq.com/FvoG8qppuOWSNhXBbj27ShBAJw0G?imageMogr2/auto-orient/quality/100!/ignore-error/1&amp;e=1648742399&amp;token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:q36Nzw1NTcg-NvuvnNyOWSZ_mdI=" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>首先，动态规划问题的一般形式就是==求最值==</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。<strong>求解动态规划的核心问题是穷举</strong>。首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「==备忘录」或者「DP
table」==来优化穷举过程，避免不必要的计算。而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>，才能正确地穷举。</p>
<p>以上提到的<strong>重叠子问题、最优子结构、状态转移方程</strong>就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我研究出来的一个思维框架，辅助你思考状态转移方程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base</span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<h2><span id="51-背包问题"><strong>5.1 背包问题</strong></span></h2>
<p>https://leetcode-cn.com/problems/coin-change/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-wan-q-80r7/</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20210117171307407.png" alt="416.分割等和子集1">
<figcaption aria-hidden="true">416.分割等和子集1</figcaption>
</figure>
<blockquote>
<p><strong>1、确定dp数组以及下标的含义</strong></p>
<p><strong>2、确定递推公式</strong></p>
<p><strong>3、dp数组如何初始化</strong></p>
<ul>
<li><strong>最大长度</strong></li>
<li><strong>递推等号左侧要初始化</strong></li>
</ul>
<p><strong>4、确定遍历顺序</strong></p>
<ul>
<li><strong>滚动数组</strong></li>
</ul>
<p><strong>5、举例推导dp数组</strong></p>
</blockquote>
<h3><span id="511-背包递推公式">5.1.1 背包递推公式</span></h3>
<p><strong>问==能否装满背包==</strong>（或者<strong>最多装多少</strong>）：dp[j]
= max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0416.分割等和子集.html">动态规划：416.分割等和子集(opens
new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">划分为k个相等的子集</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/1049.最后一块石头的重量II.html">动态规划：1049.最后一块石头的重量
II</a></li>
</ul>
<p><strong>==问装满背包有几种方法==</strong>：dp[j] += dp[j - nums[i]]
，对应题目如下：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0494.目标和.html">动态规划：494.目标和(opens
new window)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 背包问题</span></span><br><span class="line">        total, n = <span class="built_in">sum</span>(nums), <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> total % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        target = total // <span class="number">2</span></span><br><span class="line">        dp = [<span class="literal">True</span>] + [<span class="literal">False</span>] * target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(target, nums[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                逆序更新</span></span><br><span class="line"><span class="string">                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                dp[j] |= dp[j - nums[i]]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.
零钱兑换 II(opens new window)</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0377.组合总和Ⅳ.html">动态规划：377.组合总和Ⅳ(opens
new window)</a></p>
<blockquote>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
</blockquote></li>
<li><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯完全背包版本.html">动态规划：70.
爬楼梯进阶版（完全背包）</a></p></li>
</ul>
<p><strong>问背包装满==最大价值==</strong>：dp[j] = max(dp[j], dp[j -
weight[i]] + value[i]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0474.一和零.html">动态规划：474.一和零</a></li>
</ul>
<p><strong>问装满背包所有物品的==最小个数==</strong>：dp[j] = min(dp[j -
coins[i]] + 1, dp[j]); ，对应题目如下：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0322.零钱兑换.html">动态规划：322.零钱兑换(opens
new window)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0279.完全平方数.html">动态规划：279.完全平方数(opens
new window)</a></li>
</ul>
<h3><span id="512-遍历顺序">5.1.2 遍历顺序</span></h3>
<h4><span id="01背包">01背包</span></h4>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-1.html">动态规划：关于01背包问题，你该了解这些！
(opens new
window)</a>中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
<p>和<a target="_blank" rel="noopener" href="https://programmercarl.com/背包理论基础01背包-2.html">动态规划：关于01背包问题，你该了解这些！（滚动数组）
(opens new
window)</a>中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。</p>
<p><strong>一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！</strong></p>
<h4><span id="完全背包">完全背包</span></h4>
<p>说完01背包，再看看完全背包。</p>
<p>在<a target="_blank" rel="noopener" href="https://programmercarl.com/背包问题理论基础完全背包.html">动态规划：关于完全背包，你该了解这些！
(opens new
window)</a>中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。</p>
<p>但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。</p>
<p><strong>如果求==组合数==就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果==求排列数==就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>相关题目如下：</p>
<ul>
<li>求组合数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0518.零钱兑换II.html">动态规划：518.零钱兑换II(opens
new window)</a></li>
<li>求排列数：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA">动态规划：377.
组合总和 Ⅳ (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0070.爬楼梯完全背包版本.html">动态规划：70.
爬楼梯进阶版（完全背包）(opens new window)</a></li>
</ul>
<p>如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：</p>
<ul>
<li>求最小数：<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.零钱兑换.html">动态规划：322.
零钱兑换 (opens new window)</a>、<a target="_blank" rel="noopener" href="https://programmercarl.com/0279.完全平方数.html">动态规划：279.完全平方数(opens
new window)</a></li>
</ul>
<p><strong>对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了</strong>。</p>
<h2><span id="52-子序列数组问题">5.2 <strong>子序列（数组）问题</strong></span></h2>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg" alt="img" style="zoom:50%;"></p>
<h4><span id="剑指offer-42-连续子数组的最大和"></span></h4>
<p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>] + nums[i], nums[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<h4><span id="动态规划最长递增子序列"></span></h4>
<p>给你一个整数数组 <code>nums</code>
，找到其中最长严格递增子序列的长度。</p>
<ul>
<li><strong>动态规划</strong>
位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1
的最大值。</li>
<li><strong>贪心 + 二分查找</strong> tail[i] :
记录i长度的末尾是什么</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [<span class="number">1</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; numa[i]:</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            result = <span class="built_in">max</span>(result, dp[i]) <span class="comment">#取长的子序列</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">     <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 贪心 + 二分查找 tail[i] : 记录i长度的末尾是什么</span></span><br><span class="line">        tails, res = [<span class="number">0</span>] * <span class="built_in">len</span>(nums), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            i = bisect.bisect_left(tails[:res], num)</span><br><span class="line">            <span class="string">&quot;&quot;&quot;左边界</span></span><br><span class="line"><span class="string">            while i &lt; j:</span></span><br><span class="line"><span class="string">                mid = (i + j)//2</span></span><br><span class="line"><span class="string">                if tails[m] &lt; num:</span></span><br><span class="line"><span class="string">                    i = m + 1 </span></span><br><span class="line"><span class="string">                else:</span></span><br><span class="line"><span class="string">                    j = m</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span></span><br><span class="line">            tails[i] = num</span><br><span class="line">            <span class="keyword">if</span> i == res:</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h5><span id="动态规划最长斐波那契数列"></span></h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lenLongestFibSubseq</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 基本顺序是 k，i，j 或者 A[k] = A[j] - A[i]</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="comment"># 创建索引字典，提速</span></span><br><span class="line">    <span class="keyword">for</span> ind,val <span class="keyword">in</span> <span class="built_in">enumerate</span>(A):</span><br><span class="line">        dic[val] = ind</span><br><span class="line">    <span class="comment"># 初始化，行代表的是i，不需要取到n-1，为了给j留出位置</span></span><br><span class="line">    <span class="comment"># 初始为2，只要包含了 j i 位置，则意味着已经有了2个数字。</span></span><br><span class="line">    dp = [[<span class="number">2</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>)]</span><br><span class="line">    ret = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 因此i只能取到n-2，给j留出空间</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># j从i+1开始，毕竟j在i后面</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">            diff = A[j] - A[i]</span><br><span class="line">            <span class="keyword">if</span> diff <span class="keyword">in</span> dic <span class="keyword">and</span> dic[diff] &lt; i:</span><br><span class="line">                k = dic[diff]</span><br><span class="line">                dp[i][j] = dp[k][i] + <span class="number">1</span> <span class="comment"># 这个1，代表着k位置数字</span></span><br><span class="line">                ret = <span class="built_in">max</span>(ret,dp[i][j])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4><span id="动态规划最长重复子数组"></span></h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findLength</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], B: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>] * (<span class="built_in">len</span>(B) + <span class="number">1</span>)</span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(A)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(B), <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> A[i-<span class="number">1</span>] == B[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[j] = dp[j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[j] = <span class="number">0</span> <span class="comment">#注意这里不相等的时候要有赋0的操作</span></span><br><span class="line">                result = <span class="built_in">max</span>(result, dp[j])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4><span id="动态规划最长公共子序列"></span></h4>
<p>给定两个字符串 <code>text1</code> 和
<code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong>
的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code>
。</p>
<p>一个字符串的 <strong>子序列</strong>
是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<h4><span id="动态规划不相交的线"></span></h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 最长子序列 </span></span><br><span class="line">        m, n = <span class="built_in">len</span>(text1), <span class="built_in">len</span>(text2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> text2[j-<span class="number">1</span>] == text1[i-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] +<span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0053.最大子序和（动态规划）.html">动态规划：最大子序和</a>
【贪心】【动态规划】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 为什么dp[-1]不是最大？需要res</span></span><br><span class="line">    <span class="comment"># dp[i] 以i结尾的最大子数组和</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (n)</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>]+nums[i], nums[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0392.判断子序列.html">动态规划：判断子序列</a>
【双指针】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSubsequence</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n, m = <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">        i = j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> j &lt; m:</span><br><span class="line">            <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> i == n</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0115.不同的子序列.html">动态规划：不同的子序列</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0583.两个字符串的删除操作.html">动态规划：两个字符串的删除操作</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dp[i][j] : word1[i-1], word1[j-1] 最少步数</span></span><br><span class="line"><span class="comment"># word1[i - 1] 与 word2[j - 1]不相同的时候，有2种情况 *  min(dp[i-1][j], dp[i][j-1])+1  </span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(word1), <span class="built_in">len</span>(word2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][i] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            dp[j][<span class="number">0</span>] = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])+<span class="number">1</span> <span class="comment"># , dp[i-1][j-1]+1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0072.编辑距离.html">动态规划：编辑距离</a></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/为了绝杀编辑距离，卡尔做了三步铺垫.html">为了绝杀编辑距离，我做了三步铺垫，你都知道么？</a></p>
<h4><span id="剑指-offer-ii-020回文子字符串的个数"></span></h4>
<p>给定一个字符串 <code>s</code>
，请计算这个字符串中有多少个回文子字符串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<ul>
<li>动态规划、双指针+中心扩展、<strong>==Manacher算法==</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 双指针+中心扩散</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">_extend</span>(<span class="params">s, i, j, n</span>):</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; n <span class="keyword">and</span> s[i] == s[j]: <span class="comment"># 确定中心点</span></span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span> <span class="comment"># 扩散过程也是答案</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            result += _extend(s, i, i, <span class="built_in">len</span>(s)) <span class="comment">#以i为中心</span></span><br><span class="line">            result += _extend(s, i, i+<span class="number">1</span>, <span class="built_in">len</span>(s)) <span class="comment">#以i和i+1为中心</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSubstrings</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划 dp[i][j]: s[i:j] 是否为回文子串</span></span><br><span class="line">        <span class="comment"># dp[i+1][j-1] -&gt; dp[i][j] 遍历顺序 </span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt;= <span class="number">1</span>:</span><br><span class="line">                        ans += <span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                        ans += <span class="number">1</span></span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">最长回文子串</a>
==[Manacher 算法]==</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中心扩展法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 枚举+中心扩展法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">extendCenter</span>(<span class="params">left, right</span>):</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= left <span class="keyword">and</span> right &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left] == s[right]:</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 返回的为while不成立的值</span></span><br><span class="line">            <span class="keyword">return</span> left+<span class="number">1</span>, right-<span class="number">1</span> </span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            left1, right1 = extendCenter(i,i)</span><br><span class="line">            left2, right2 = extendCenter(i,i+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> right1 - left1 &gt; end - start:</span><br><span class="line">                start, end = left1, right1</span><br><span class="line">            <span class="keyword">if</span> right2 - left2 &gt; end - start:</span><br><span class="line">                start, end = left2, right2</span><br><span class="line">        <span class="keyword">return</span> s[start:end+<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="comment"># dp[i][j]: 是否是回文 dp[i+1][j-1] -&gt; dp[i][j]</span></span><br><span class="line">    <span class="comment"># 返回的子串，不是数字 不能记录长度</span></span><br><span class="line">    n = <span class="built_in">len</span>(s)</span><br><span class="line">    dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 右上为1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[i][i] = <span class="literal">True</span></span><br><span class="line">    begin = <span class="number">0</span></span><br><span class="line">    maxlen = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 判断是否是回文子串中，如果是则记录begin and len</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,n):</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                <span class="keyword">if</span> j - i &lt;=<span class="number">1</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> j - i + <span class="number">1</span> &gt; maxlen:</span><br><span class="line">                maxlen = j - i + <span class="number">1</span></span><br><span class="line">                begin = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[begin:begin+maxlen]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Manacher 算法：<strong>Manacher
算法是在线性时间内求解最长回文子串的算法</strong>。在本题中，我们要求解回文串的个数，为什么也能使用
Manacher 算法呢？这里我们就需要理解一下 Manacher 的基本原理。</p>
<ul>
<li><p>奇偶长度处理： abaaabaa 会被处理成
#a#b#a#a##<em>a</em>#<em>b</em>#<em>a</em>#<em>a</em>#</p></li>
<li><p>==<strong><span class="math inline">\(f(i)\)</span></strong>
来表示以 s 的第 i 位为回文中心，可以拓展出的<strong>最大回文半径 （包括
# ）</strong>==，那么$ f(i) - 1$就是以 i 为中心的最大回文串长度
。</p></li>
<li><p>利用已经计算出来的状态来更新 f(i）：<strong>回文右端点rm</strong>
：i + f(i) - 1</p></li>
</ul></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0516.最长回文子序列.html">动态规划：最长回文子序列</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划 dp[i][j]: s[i:j] 最大回文长度</span></span><br><span class="line">        <span class="comment"># dp[i+1][j-1] -&gt; dp[i][j] 遍历顺序 and j - i &gt;=2</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="number">0</span>] * i +[<span class="number">1</span>] * (n-i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment"># 从定义出发 右上三角 = 1 有意义</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n): <span class="comment"># j - i &gt;=2</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span> </span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])                </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h5><span id="最少回文分割"></span></h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCut</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划1:判断回文</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        g = [[<span class="literal">True</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):</span><br><span class="line">                g[i][j] = (s[i] == s[j]) <span class="keyword">and</span> g[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="comment"># </span></span><br><span class="line">        f = [<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> g[<span class="number">0</span>][i]:</span><br><span class="line">                f[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                    <span class="keyword">if</span> g[j + <span class="number">1</span>][i]:</span><br><span class="line">                        <span class="comment"># （0, j) + (j+1, i)</span></span><br><span class="line">                        f[i] = <span class="built_in">min</span>(f[i], f[j] + <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h5><span id="最长连续序列"></span></h5>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestConsecutive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        dic, res = <span class="built_in">dict</span>(), <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                left, right = dic.get(num - <span class="number">1</span>, <span class="number">0</span>), dic.get(num + <span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">                cur = <span class="number">1</span> + left +right</span><br><span class="line">                <span class="keyword">if</span> res &lt; cur:</span><br><span class="line">                    res = cur</span><br><span class="line">                dic[num] = cur</span><br><span class="line">                dic[num - left] = cur</span><br><span class="line">                dic[num + right] = cur</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3><span id="53-打家劫舍问题">5.3 打家劫舍问题</span></h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0198.打家劫舍.html">动态规划：开始打家劫舍</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0213.打家劫舍II.html">动态规划：继续打家劫舍
环</a></li>
<li><a target="_blank" rel="noopener" href="https://programmercarl.com/0337.打家劫舍III.html">动态规划：还要打家劫舍
树状dp</a></li>
</ul>
<h3><span id="54-股票问题">5.4 股票问题</span></h3>
<p><img src="https://code-thinking.cdn.bcebos.com/pics/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg" alt="股票问题总结" style="zoom:50%;"></p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0121.买卖股票的最佳时机.html">动态规划：121.买卖股票的最佳时机(opens
new window)</a></p>
<p>股票只能买卖一次，问最大利润</p>
<ul>
<li><strong>动态规划、贪心算法</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">      	<span class="comment"># 动态规划</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prices))] </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>]<span class="comment"># 已持有的状态</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> <span class="comment"># 未持有的状态</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], -prices[i])</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 贪心算法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        buy, profit = prices[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(prices)):</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, prices[i] - buy)</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; buy:</span><br><span class="line">                buy = prices[i]</span><br><span class="line">        <span class="keyword">return</span> profit    </span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html">动态规划：122.买卖股票的最佳时机II(opens
new window)</a> 可以多次买卖股票，问最大收益。</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0123.买卖股票的最佳时机III.html">动态规划：123.买卖股票的最佳时机III(opens
new window)</a> 最多买卖两次，问最大收益。</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0188.买卖股票的最佳时机IV.html">动态规划：188.买卖股票的最佳时机IV(opens
new window)</a> 最多买卖k笔交易，问最大收益。</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0309.最佳买卖股票时机含冷冻期.html">动态规划：309.最佳买卖股票时机含冷冻期(opens
new window)</a> 可以多次买卖但每次卖出有冷冻期1天。</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0714.买卖股票的最佳时机含手续费（动态规划）.html">动态规划：714.买卖股票的最佳时机含手续费(opens
new window)</a> 可以多次买卖，但每次有手续费。</p>
<h3><span id="55-编辑距离问题">5.5 编辑距离问题</span></h3>
<h4><span id="判断子序列">判断子序列</span></h4>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0392.判断子序列.html">动态规划：392.判断子序列
(opens new window)</a>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>这道题目
其实是可以用<strong>双指针</strong>或者<strong>贪心</strong>的的，但是我在开篇的时候就说了这是编辑距离的入门题目，因为从题意中我们也可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。</p>
<ul>
<li>if (s[i - 1] == t[j - 1])
<ul>
<li>t中找到了一个字符在s中也出现了</li>
</ul></li>
<li>if (s[i - 1] != t[j - 1])
<ul>
<li>相当于t要删除元素，继续匹配</li>
</ul></li>
</ul>
<p>状态转移方程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4><span id="不同的子序列">不同的子序列</span></h4>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0115.不同的子序列.html">动态规划：115.不同的子序列
(opens new window)</a>给定一个字符串 s 和一个字符串 t ，计算在 s
的子序列中 t 出现的个数。</p>
<p>本题虽然也只有删除操作，不用考虑替换增加之类的，但相对于<a target="_blank" rel="noopener" href="https://programmercarl.com/0392.判断子序列.html">动态规划：392.判断子序列
(opens new window)</a>就有难度了，这道题目双指针法可就做不了。</p>
<p>当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。</p>
<p>一部分是用s[i - 1]来匹配，那么个数为 dp[i - 1] [j - 1]</p>
<p>一部分是不用s[i - 1]来匹配，个数为 dp[i - 1] [j]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="两个字符串的删除操作">两个字符串的删除操作</span></h4>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0583.两个字符串的删除操作.html">动态规划：583.两个字符串的删除操作
(opens new window)</a>给定两个单词 word1 和 word2，找到使得 word1 和
word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>本题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0115.不同的子序列.html">动态规划：115.不同的子序列
(opens new
window)</a>相比，其实就是两个字符串可以都可以删除了，情况虽说复杂一些，但整体思路是不变的。</p>
<ul>
<li>当word1[i - 1] 与 word2[j - 1]相同的时候</li>
<li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li>
</ul>
<p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1] [j -
1];</p>
<p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有2种情况：</p>
<p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1</p>
<p>情况二：删word2[j - 1]，最少操作次数为dp [i] [j - 1] + 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="编辑距离">编辑距离</span></h4>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0072.编辑距离.html">动态规划：72.编辑距离
(opens new window)</a>给你两个单词 word1 和 word2，请你计算出将 word1
转换成 word2 所使用的最少操作数 。</p>
<p>编辑距离终于来了，<strong>有了前面三道题目的铺垫，应该有思路了</strong>，本题是两个字符串可以增删改，比
<a target="_blank" rel="noopener" href="https://programmercarl.com/0392.判断子序列.html">动态规划：判断子序列
(opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0115.不同的子序列.html">动态规划：不同的子序列
(opens new window)</a>，<a target="_blank" rel="noopener" href="https://programmercarl.com/0583.两个字符串的删除操作.html">动态规划：两个字符串的删除操作
(opens new window)</a>都要复杂的多。</p>
<p>在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：</p>
<ul>
<li>if (word1[i - 1] == word2[j - 1])
<ul>
<li>不操作</li>
</ul></li>
<li>if (word1[i - 1] != word2[j - 1])
<ul>
<li>增</li>
<li>删</li>
<li>换</li>
</ul></li>
</ul>
<p>也就是如上四种情况。</p>
<p>if (word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j]
就应该是 dp[i - 1] [j - 1]，即dp[i][j] = dp[i - 1] [j - 1];</p>
<p><strong>在整个动规的过程中，最为关键就是正确理解dp[i]
[j]的定义！</strong></p>
<p>if (word1[i - 1] != word2[j - 1])，此时就需要编辑了，如何编辑呢？</p>
<p>操作一：word1增加一个元素，使其word1[i - 1]与word2[j -
1]相同，那么就是以下标i-2为结尾的word1 与 i-1为结尾的word2的最近编辑距离
加上一个增加元素的操作。</p>
<p>即 dp[i][j] = dp[i - 1] [j] + 1;</p>
<p>操作二：word2添加一个元素，使其word1[i - 1]与word2[j -
1]相同，那么就是以下标i-1为结尾的word1 与 j-2为结尾的word2的最近编辑距离
加上一个增加元素的操作。</p>
<p>即 dp[i][j] = dp[i][j - 1] + 1;</p>
<p>这里有同学发现了，怎么都是添加元素，删除元素去哪了。</p>
<p><strong>word2添加一个元素，相当于word1删除一个元素</strong>，例如
word1 = "ad" ，word2 =
"a"，word2添加一个元素d，也就是相当于word1删除一个元素d，操作数是一样！</p>
<p>操作三：替换元素，word1替换word1[i - 1]，使其与word2[j -
1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与
j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。</p>
<p>即 dp[i][j] = dp[i - 1] [j - 1] + 1;</p>
<p>综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：dp[i] [j]
= min({dp[i - 1] [j - 1], dp[i - 1] [j], dp[i][j - 1]}) + 1;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="让字符串成为最小回文">==让字符串成为最小回文==</span></h4>
<p>https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/</p>
<h4><span id="剑指offer-19-正则表达式匹配"></span></h4>
<p>请实现一个函数用来<strong>匹配包含'.
'和'<em>'的正则表达式<strong>。</strong>模式中的字符'.'表示任意一个字符，而'
</em>
'表示它前面的字符可以出现任意次（含0次）</strong>。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab<em>ac</em>a"匹配，但与"aa.a"和"ab*a"均不匹配。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 【dp含义】dp[i][j] : s[:i - 1] 可以正则匹配 p[:j - 1]</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        <span class="comment"># 【初始化】</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line">        <span class="comment"># 【遍历顺序】</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 【状态转移推导】</span></span><br><span class="line">                <span class="keyword">if</span> p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>: </span><br><span class="line">                    <span class="keyword">if</span> dp[i][j - <span class="number">2</span>]:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> dp[i - <span class="number">1</span>][j] <span class="keyword">and</span> (p[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> s[i - <span class="number">1</span>] == p[j - <span class="number">2</span>]):</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> dp[i-<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> <span class="keyword">or</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]):</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>][-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2><span id="六-其他">六、其他</span></h2>
<h4><span id="剑指offer-66-构建乘积数组"></span></h4>
<p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i]
的值是数组 A 中除了下标 i 以外的元素的积, 即
B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。【求三角矩阵非对角线】</p>
<ul>
<li>动态规划双向遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">constructArr</span>(<span class="params">self, a: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        b, tmp = [<span class="number">1</span>] * <span class="built_in">len</span>(a), <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(a)):</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>] <span class="comment"># 下三角</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a) - <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tmp *= a[i + <span class="number">1</span>]            <span class="comment"># 上三角</span></span><br><span class="line">            b[i] *= tmp                <span class="comment"># 下三角 * 上三角</span></span><br><span class="line">        <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h4><span id="剑指-offer-49丑数"></span></h4>
<p>我们<strong>把只包含质因子 2、3 和 5 的数称作丑数</strong>（Ugly
Number）。求按从小到大的顺序的第 n 个丑数。</p>
<ul>
<li>三指针、<strong>优先队列（质数的线性筛算法）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 维护3个 2，3，5的动态个数</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        p2 = p3 = p5 = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">          	<span class="comment"># </span></span><br><span class="line">            u2, u3, u5 = <span class="number">2</span> * dp[p2], <span class="number">3</span> * dp[p3], <span class="number">5</span> * dp[p5]</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(u2, u3, u5)</span><br><span class="line">            <span class="keyword">if</span> dp[i] == u5:</span><br><span class="line">                p5 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == u3:</span><br><span class="line">                p3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dp[i] == u2:</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        H = [(<span class="number">2</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">5</span>, <span class="number">5</span>)]</span><br><span class="line">        heapify(H)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">            num, p = heappop(H)</span><br><span class="line">            heappush(H, (num * <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> p &gt;= <span class="number">3</span>:</span><br><span class="line">                heappush(H, (num * <span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">                <span class="keyword">if</span> p &gt;= <span class="number">5</span>:</span><br><span class="line">                    heappush(H, (num * <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">        <span class="comment">#print(len(H)) #n = 1670时, H长度为162</span></span><br><span class="line">        <span class="keyword">return</span> num                </span><br></pre></td></tr></table></figure>
<h4><span id="剑指offer-60-n个骰子的点数"></span></h4>
<p><strong>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</strong></p>
<ul>
<li>已知n - 1个骰子的解为f(n - 1),
添加一个骰子，求n个骰子的点数和为x的概率f（n， x）</li>
</ul>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220608212653374.png" alt="image-20220608212653374" style="zoom:50%;"></p>
<p><img src="https://pic.leetcode-cn.com/1614960989-tpJNRQ-Picture2.png" alt="Picture2.png" style="zoom: 33%;"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dicesProbability</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        dp = [<span class="number">1</span> / <span class="number">6</span>] * <span class="number">6</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            tmp = [<span class="number">0</span>] * (<span class="number">5</span> * i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>): <span class="comment"># 防止越界</span></span><br><span class="line">                    tmp[j + k] += dp[j] / <span class="number">6</span></span><br><span class="line">            dp = tmp</span><br><span class="line">        <span class="keyword">return</span> dp</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/T623MZ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/T623MZ/" class="post-title-link" itemprop="url">深度学习-【draft】生成对抗网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-21 11:00:24" itemprop="dateCreated datePublished" datetime="2020-12-21T11:00:24+08:00">2020-12-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-01 18:47:37" itemprop="dateModified" datetime="2023-05-01T18:47:37+08:00">2023-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">【draft】深度学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/GAN/" itemprop="url" rel="index"><span itemprop="name">GAN</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1><span id="李宏毅-gan学习笔记"></span></h1>
<h3><span id="1-介绍gan">1. 介绍GAN</span></h3>
<ul>
<li>GAN的基本思想</li>
<li>为什么生成器不自己学？</li>
<li>为什么判别器不自己做?</li>
<li>具体算法</li>
<li>笔记： <a target="_blank" rel="noopener" href="https://blog.csdn.net/oldmao_2001/article/details/105887797">李宏毅学习笔记30.GAN.01.</a>
<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57174645">李宏毅GAN教程（1）</a></li>
</ul>
<h3><span id="2gan的数学原理gan背后的理论">2.
Gan的数学原理（GAN背后的理论）</span></h3>
<ul>
<li>笔记： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57184819">李宏毅GAN教程（2）</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/oldmao_2001/article/details/105918115">李宏毅学习笔记33.GAN.04.Theory
behind GAN</a></li>
</ul>
<h2><span id="3-conditional-gan-条件gan">3. Conditional GAN (条件GAN)</span></h2>
<ul>
<li>笔记： <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57308383">李宏毅GAN教程（5）</a> <a target="_blank" rel="noopener" href="https://blog.csdn.net/oldmao_2001/article/details/105903619">李宏毅学习笔记31.GAN.02.Conditional
Generation by GAN</a></li>
</ul>
<h2><span id="研讨厅思路">研讨厅思路：</span></h2>
<h3><span id="背景意义">背景意义</span></h3>
<p>Generative Adversarial
Network（GAN）<strong>被引次数：26083次</strong></p>
<p>Ian J. Goodfellow:phD</p>
<p><img src="apple/Desktop/GAN介绍/Goodlflow-phD.png" alt="Goodlflow-phD" style="zoom: 33%;"></p>
<p>https://github.com/hindupuravinash/the-gan-zoo</p>
<p><img src="https://github.com/hindupuravinash/the-gan-zoo/blob/master/cumulative_gans.jpg?raw=true" alt="cumulative_gans.jpg" style="zoom: 50%;"></p>
<h3><span id="gan的应用">GAN的应用</span></h3>
<h3><span id="gan的原理">GAN的原理</span></h3>
<p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20210105212933337.png" alt="image-20210105212933337" style="zoom:33%;"></p>
<p>调节Generator和Discrimnator的训练次数比。一般来说，<strong>Discrimnator要训练的比Genenrator多。比如训练五次Discrimnator，再训练一次Genenrator(WGAN论文
是这么干的)</strong>。这一条不一定对！</p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ebMei6bYeWw">GAN的训练过程</a></p>
<h3><span id="gan与vae的比较">GAN与VAE的比较</span></h3>
<p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20210109170402276.png" alt="image-20210109170402276" style="zoom: 33%;"><img src="/Users/apple/Library/Application Support/typora-user-images/image-20210109170435958.png" alt="image-20210109170435958" style="zoom: 25%;"></p>
<p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20210112105214591.png" alt="image-20210112105214591" style="zoom:50%;"></p>
<p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20210112110242541.png" alt="image-20210112110242541" style="zoom: 33%;"></p>
<h3><span id="gan的发展">GAN的发展</span></h3>
<p>http://nooverfit.com/wp/独家｜gan大盘点，聊聊这些年的生成对抗网络-lsgan-wgan-cgan-info/</p>
<p>10个必读的GAN</p>
<p>WGAN，DCGAN，CGAN,<strong>Improved Techniques for Training
GANs</strong></p>
<p>优化GAN的方法</p>
<p>（1) 结构上的改进CGAN</p>
<p>（2）除了结构上的改进还有，loss, 模型初始化和权重上的改进</p>
<p>（3）GAN的重要实现</p>
<p>目前各领域最先进的GAN</p>
<p>GAN研究方向汇总（附源码） - 清华阿罗的文章 - 知乎
https://zhuanlan.zhihu.com/p/69305310</p>
<figure>
<img src="/Users/apple/Library/Application%20Support/typora-user-images/image-20210110202318149.png" alt="image-20210110202318149">
<figcaption aria-hidden="true">image-20210110202318149</figcaption>
</figure>
<h1><span id="level-0-definition-of-gans">Level 0: Definition of GANs</span></h1>
<table>
<colgroup>
<col style="width: 4%">
<col style="width: 34%">
<col style="width: 10%">
<col style="width: 16%">
<col style="width: 34%">
</colgroup>
<thead>
<tr class="header">
<th>Level</th>
<th style="text-align: left;">Title</th>
<th>authors</th>
<th>Publication</th>
<th>Links</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Beginner</td>
<td style="text-align: left;">GAN : Generative Adversarial Nets</td>
<td>Goodfellow &amp; et al.</td>
<td>NeurIPS (NIPS) 2014</td>
<td><a target="_blank" rel="noopener" href="https://papers.nips.cc/paper/5423-generative-adversarial-nets.pdf">link</a></td>
</tr>
<tr class="even">
<td>Beginner</td>
<td style="text-align: left;">GAN : Generative Adversarial Nets
(Tutorial)</td>
<td>Goodfellow &amp; et al.</td>
<td>NeurIPS (NIPS) 2016 Tutorial</td>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1701.00160.pdf">link</a></td>
</tr>
<tr class="odd">
<td>Beginner</td>
<td style="text-align: left;">CGAN : Conditional Generative Adversarial
Nets</td>
<td>Mirza &amp; et al.</td>
<td>-- 2014</td>
<td><a target="_blank" rel="noopener" href="https://gist.github.com/shagunsodhani/5d726334de3014defeeb701099a3b4b3">link</a></td>
</tr>
<tr class="even">
<td>Beginner</td>
<td style="text-align: left;">InfoGAN : Interpretable Representation
Learning by Information Maximizing Generative Adversarial Nets</td>
<td>Chen &amp; et al.</td>
<td>NeuroIPS (NIPS) 2016</td>
<td></td>
</tr>
</tbody>
</table>
<h1><span id="level-1-improvements-ofgans-training">Level 1: Improvements of
GANs training</span></h1>
<p>然后看看 loss、参数、权重的改进：</p>
<table>
<colgroup>
<col style="width: 4%">
<col style="width: 31%">
<col style="width: 8%">
<col style="width: 24%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th>Level</th>
<th>Title</th>
<th>Co-authors</th>
<th>Publication</th>
<th>Links</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Beginner</td>
<td>LSGAN : Least Squares Generative Adversarial Networks</td>
<td>Mao &amp; et al.</td>
<td>ICCV 2017</td>
<td><a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/8237566">link</a></td>
</tr>
<tr class="even">
<td>Advanced</td>
<td>Improved Techniques for Training GANs</td>
<td>Salimans &amp; et al.</td>
<td>NeurIPS (NIPS) 2016</td>
<td><a target="_blank" rel="noopener" href="https://ceit.aut.ac.ir/http://papers.nips.cc/paper/6125-improved-techniques-for-training-gans.pdf">link</a></td>
</tr>
<tr class="odd">
<td>Advanced</td>
<td>WGAN : Wasserstein GAN</td>
<td>Arjovsky &amp; et al.</td>
<td>ICML 2017</td>
<td><a target="_blank" rel="noopener" href="http://proceedings.mlr.press/v70/arjovsky17a/arjovsky17a.pdf">link</a></td>
</tr>
<tr class="even">
<td>Advanced</td>
<td>WGAN-GP : improved Training of Wasserstein GANs</td>
<td>2017</td>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1704.00028v3.pdf">link</a></td>
<td></td>
</tr>
<tr class="odd">
<td>Advanced</td>
<td>Certifying Some Distributional Robustness with Principled
Adversarial Training</td>
<td>Sinha &amp; et al.</td>
<td>ICML 2018</td>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1710.10571.pdf">link</a><a target="_blank" rel="noopener" href="https://github.com/duchi-lab/certifiable-distributional-robustness">code</a></td>
</tr>
</tbody>
</table>
<h1><span id="level-2-implementation-skill">Level 2: Implementation skill</span></h1>
<p>GAN的实现</p>
<table style="width:100%;">
<colgroup>
<col style="width: 31%">
<col style="width: 13%">
<col style="width: 8%">
<col style="width: 31%">
<col style="width: 7%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Co-authors</th>
<th>Publication</th>
<th>Links</th>
<th>size</th>
<th>FID/IS</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Keras Implementation of GANs</td>
<td>Linder-Norén</td>
<td>Github</td>
<td><a target="_blank" rel="noopener" href="https://github.com/eriklindernoren/Keras-GAN">link</a></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>GAN implementation hacks</td>
<td>Salimans paper &amp; Chintala</td>
<td>World research</td>
<td><a target="_blank" rel="noopener" href="https://github.com/soumith/ganhacks">link</a><a target="_blank" rel="noopener" href="https://ceit.aut.ac.ir/~khalooei/tutorials/gan/#gan-hack-paper-2016">paper</a></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>DCGAN : Unsupervised Representation Learning with Deep Convolutional
Generative Adversarial Networks</td>
<td>Radford &amp; et al.</td>
<td>2015.11-ICLR 2016</td>
<td><a target="_blank" rel="noopener" href="https://github.com/carpedm20/DCGAN-tensorflow">link</a><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1511.06434.pdf">paper</a></td>
<td>64x64 human</td>
<td></td>
</tr>
<tr class="even">
<td>ProGAN:Progressive Growing of GANs for Improved Quality, Stability,
and Variation</td>
<td>Tero Karras</td>
<td>2017.10</td>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1710.10196.pdf">paper</a><a target="_blank" rel="noopener" href="https://github.com/tkarras/progressive_growing_of_gans">link</a></td>
<td>1024x1024 human</td>
<td>8.04</td>
</tr>
<tr class="odd">
<td>SAGAN：Self-Attention Generative Adversarial Networks</td>
<td>Han Zhang &amp; Ian Goodfellow</td>
<td>2018.05</td>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1805.08318.pdf">paper</a><a target="_blank" rel="noopener" href="https://github.com/taki0112/Self-Attention-GAN-Tensorflow">link</a></td>
<td>128x128 obj</td>
<td>18.65/52.52</td>
</tr>
<tr class="even">
<td>BigGAN:Large Scale GAN Training for High Fidelity Natural Image
Synthesis</td>
<td>Brock et al.</td>
<td>2018.09-ICLR 2019</td>
<td><a target="_blank" rel="noopener" href="https://tfhub.dev/deepmind/biggan-256">demo</a><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1809.11096.pdf">paper</a><a target="_blank" rel="noopener" href="https://github.com/AaronLeong/BigGAN-pytorch">link</a></td>
<td>512x512 obj</td>
<td>9.6/166.3</td>
</tr>
<tr class="odd">
<td>StyleGAN:A Style-Based Generator Architecture for Generative
Adversarial Networks</td>
<td>Tero Karras</td>
<td>2018.12</td>
<td><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1812.04948.pdf">paper</a><a target="_blank" rel="noopener" href="https://github.com/NVlabs/stylegan">link</a></td>
<td>1024x1024 human</td>
<td>4.04</td>
</tr>
</tbody>
</table>
<h1><span id="gan的应用-level-3-gansapplications">GAN的应用 Level 3： GANs
Applications</span></h1>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr class="header">
<th><a target="_blank" rel="noopener" href="https://github.com/weslynn/AlphaTree-graphic-deep-neural-network/tree/master/GAN对抗生成网络/Image-translation图像翻译">图像翻译
(Image Translation)</a></th>
<th><a target="_blank" rel="noopener" href="https://github.com/weslynn/AlphaTree-graphic-deep-neural-network/tree/master/GAN对抗生成网络/Super-Resolution超分辨率">超分辨率
(Super-Resolution)</a></th>
<th style="text-align: left;"><a target="_blank" rel="noopener" href="https://github.com/weslynn/AlphaTree-graphic-deep-neural-network/tree/master/GAN对抗生成网络/Colourful-Image%20Colorization图像上色">图像上色(Colourful
Image Colorization)</a></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a target="_blank" rel="noopener" href="https://github.com/weslynn/AlphaTree-graphic-deep-neural-network/blob/master/GAN对抗生成网络/Image%20Inpainting图像修复/README.md">图像修复(Image
Inpainting)</a></td>
<td><a target="_blank" rel="noopener" href="https://github.com/weslynn/AlphaTree-graphic-deep-neural-network/tree/master/GAN对抗生成网络/Image-denoising图像去噪">图像去噪(Image
denoising)</a></td>
<td style="text-align: left;"><a target="_blank" rel="noopener" href="https://github.com/weslynn/AlphaTree-graphic-deep-neural-network/tree/master/GAN对抗生成网络/交互式图像生成">交互式图像生成</a></td>
</tr>
</tbody>
</table>
<p>JS散度在没有重合的时候，是常数log2，分辨不出来</p>
<figure>
<img src="/Users/apple/Library/Application%20Support/typora-user-images/image-20210111131150941.png" alt="image-20210111131150941">
<figcaption aria-hidden="true">image-20210111131150941</figcaption>
</figure>
<h3><span id="lsgan">LSGAN</span></h3>
<figure>
<img src="/Users/apple/Library/Application%20Support/typora-user-images/image-20210111131817659.png" alt="image-20210111131817659">
<figcaption aria-hidden="true">image-20210111131817659</figcaption>
</figure>
<h3><span id="wgan">WGAN</span></h3>
<p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20210111135312650.png" alt="image-20210111135312650" style="zoom: 50%;"><img src="/Users/apple/Library/Application Support/typora-user-images/image-20210111135334561.png" alt="image-20210111135334561" style="zoom:50%;"></p>
<figure>
<img src="/Users/apple/Library/Application%20Support/typora-user-images/image-20210111134930564.png" alt="image-20210111134930564">
<figcaption aria-hidden="true">image-20210111134930564</figcaption>
</figure>
<h3><span id="cganamp-acgan"></span></h3>
<p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20210112232646090.png" alt="image-20210112232646090" style="zoom:33%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/26/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lzy</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

    </div>
  </footer>

  

  <a href="https://github.com/PowerLZY" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>




        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'powerlzy.github.io' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>
</html>
