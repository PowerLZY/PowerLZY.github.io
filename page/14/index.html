<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"powerlzy.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="相比到达的地方，同行的人更重要！">
<meta property="og:type" content="website">
<meta property="og:title" content="PowerLZY&#39;s Blog">
<meta property="og:url" content="https://powerlzy.github.io/page/14/index.html">
<meta property="og:site_name" content="PowerLZY&#39;s Blog">
<meta property="og:description" content="相比到达的地方，同行的人更重要！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://powerlzy.github.io/page/14/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/14/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PowerLZY's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">PowerLZY's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">本博客主要用于记录个人学习笔记（测试阶段）</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lzy"
      src="/images/cat_mac.jpg">
  <p class="site-author-name" itemprop="name">lzy</p>
  <div class="site-description" itemprop="description">相比到达的地方，同行的人更重要！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">254</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/PowerLZY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PowerLZY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3289218653@qq.com" title="E-Mail → mailto:3289218653@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/32X3GH2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/32X3GH2/" class="post-title-link" itemprop="url">深度学习（7）Seq2Seq</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-14 23:08:19" itemprop="dateCreated datePublished" datetime="2022-05-14T23:08:19+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-18 21:31:52" itemprop="dateModified" datetime="2023-04-18T21:31:52+08:00">2023-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">【draft】深度学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Seq2Seq/" itemprop="url" rel="index"><span itemprop="name">Seq2Seq</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="一-seq2seq">一、Seq2Seq</span></h2>
<blockquote>
<p>CS224n笔记[7]:整理了12小时，只为让你20分钟搞懂Seq2seq - 蝈蝈的文章 -
知乎 https://zhuanlan.zhihu.com/p/147310766</p>
<p>目录：</p>
<ul>
<li><p>机器翻译</p></li>
<li><ul>
<li>传统机器翻译，SMT</li>
<li>神经机器翻译，NMT</li>
</ul></li>
<li><p>Seq2seq</p></li>
<li><ul>
<li>Seq2seq结构详解</li>
<li>为什么训练和预测时的Decoder不一样？</li>
<li>Seq2seq的损失函数</li>
<li>Decoding和Beam Search</li>
</ul></li>
<li><p>总结</p></li>
<li><ul>
<li>NMT的优缺点</li>
<li>机器翻译的评价指标</li>
</ul></li>
</ul>
</blockquote>
<h3><span id="11-seq2seq结构详解">1.1 <strong>seq2seq结构详解</strong></span></h3>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182130235.png" alt="CS224n笔记[7]:整理了12小时，只为让你20分钟搞懂Seq2seq">
<figcaption aria-hidden="true">CS224n笔记[7]:整理了12小时，只为让你20分钟搞懂Seq2seq</figcaption>
</figure>
<p>这张图，展示了在<strong>「训练时」</strong>，seq2seq内部的详细结构。</p>
<p>在Encoder端，我们将source文本的词序列先经过embedding层转化成向量，然后输入到一个RNN结构（可以是普通RNN，LSTM，GRU等等）中。另外，这里的RNN也可以是多层、双向的。经过了RNN的一系列计算，最终隐层的输入，就作为源文本整体的一个表示向量，称为<strong>「context
vector」</strong>。</p>
<p>Decoder端的操作就稍微复杂一些了。首先，Decoder的输入是什么呢？Decoder的输入，训练和测试时是不一样的！
<strong>「在训练时，我们使用真实的目标文本，即“标准答案”作为输入」</strong>（注意第一步使用一个特殊的<code>&lt;start&gt;</code>字符，表示句子的开头）。每一步根据当前正确的输出词、上一步的隐状态来预测下一步的输出词。</p>
<p>下图则展示了在<strong>「预测时」</strong>，seq2seq的内部结构：</p>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182130580.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>预测时，Encoder端没什么变化，在Decoder端，由于此时没有所谓的“真实输出”或“标准答案”了，所以只能<strong>「自产自销：每一步的预测结果，都送给下一步作为输入」</strong>，直至输出<code>&lt;end&gt;</code>就结束。如果你对我之前写的笔记很熟悉的话，会发现，<strong>「这时的Decoder就是一个语言模型」</strong>。由于这个语言模型是根据context
vector来进行文本的生成的，因此这种类型的语言模型，被称为“条件语言模型”：Conditional
LM。正因为如此，在训练过程中，我们可以使用一些预训练好的语言模型来对Decoder的参数进行初始化，从而加快迭代过程。</p>
<h3><span id="12为什么训练和预测时的decoder不一样"><strong>1.2
为什么训练和预测时的Decoder不一样？</strong></span></h3>
<p>很多人可能跟我一样，对此感到疑惑：为什么在训练的时候，不能直接使用这种语言模型的模式，使用上一步的预测来作为下一步的输入呢？</p>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182130314.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>我们称这两种模式，根据标准答案来decode的方式为<strong>「teacher
forcing」</strong>，而根据上一步的输出作为下一步输入的decode方式为<strong>「free
running」</strong>。</p>
<p>其实，free
running的模式真的不能在训练时使用吗？——当然是可以的！从理论上没有任何的问题，又不是不能跑。但是，在实践中人们发现，这样训练太南了。因为没有任何的引导，一开始会完全是瞎预测，正所谓“一步错，步步错”，而且越错越离谱，这样会导致训练时的累积损失太大（<strong>「误差爆炸」</strong>问题，exposure
bias），训练起来就很费劲。这个时候，如果我们能够在每一步的预测时，让老师来指导一下，即提示一下上一个词的正确答案，decoder就可以快速步入正轨，训练过程也可以更快收敛。因此大家把这种方法称为teacher
forcing。所以，这种操作的目的就是为了使得训练过程更容易。</p>
<p><strong>所以，更好的办法，更常用的办法，是老师只给适量的引导，学生也积极学习</strong>。即我们设置一个概率p，每一步，以概率p靠自己上一步的输入来预测，以概率1-p根据老师的提示来预测，这种方法称为<strong>「计划采样」</strong>（scheduled
sampling）：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182130613.jpg" alt="img" style="zoom: 67%;"></p>
<p>另外有一个小细节：在seq2seq的训练过程中，decoder即使遇到了<code>&lt;end&gt;</code>标识也不会结束，因为训练的时候并不是一个生成的过程
，我们需要等到“标准答案”都输入完才结束。</p>
<h3><span id="13-seq2seq的损失函数">1.3 <strong>Seq2Seq的损失函数</strong></span></h3>
<p>在上面的图中，我们看到<strong>decoder的每一步产生隐状态后，会通过一个projection层映射到对应的词</strong>。那怎么去计算每一步的损失呢？实际上，<strong>这个projection层，通常是一个softmax神经网络层，假设词汇量是V，则会输出一个V维度的向量，每一维代表是某个词的概率</strong>。映射的过程就是把最大概率的那个词找出来作为预测出的词。</p>
<p>在计算损失的时候，我们使用交叉熵作为损失函数，所以我们要找出这个V维向量中，正确预测对应的词的那一维的概率大小<img src="https://www.zhihu.com/equation?tex=%5Chat%7Bp%7D" alt="[公式]">，则这一步的损失就是它的负导数<img src="https://www.zhihu.com/equation?tex=-log%28%5Chat%7Bp%7D%29" alt="[公式]">，将每一步的损失求和，即得到总体的损失函数：</p>
<figure>
<img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+J%26%3D-log%28p%28%5Chat%7By_1%7D%29%29-log%28p%28%5Chat%7By_2%7D%29%29-...-log%28p%28%5Chat%7By_n%7D%29%29-log%28p%28%5BEOS%5D%29%29+%5Cnonumber+%5C%5C+%26%3D+-%5Cfrac%7B1%7D%7BT%7D%5Csum%5E%7BT%7D_%7Bi%7Dlog%28p%28%5Chat%7By_i%7D%29%29+%5Cnonumber+%5Cend%7Balign%7D+%5C%5C" alt="[公式]">
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>其中T代表Decoder有多少步，[EOS]代表‘end of sentence’这个特殊标记.</p>
<h3><span id="14-decoding和beamsearch">1.4 <strong>Decoding和Beam
search</strong></span></h3>
<p>前面画的几个图展示的预测过程，其实就是最简单的decoding方式——<strong>「Greedy
Decoding」</strong>，即每一步，都预测出概率最大的那个词，然后输入给下一步。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182130276.jpg" alt="img" style="zoom:67%;"></p>
<p>这种Greedy的方式，简单快速，但是既然叫“贪心”，肯定会有问题，那就是<strong>「每一步最优，不一定全局最优」</strong>，这种方式很可能“捡了芝麻，丢了西瓜”。</p>
<p>改进的方法，就是使用<strong>「Beam
Search」</strong>方法：每一步，多选几个作为候选，最后综合考虑，选出最优的组合。</p>
<p>下面我们来具体看看Beam Search的操作步骤：</p>
<ul>
<li>首先，我们需要设定一个候选集的大小beam size=k；</li>
<li>每一步的开始，我们从每个当前输入对应的所有可能输出，计算每一条路的“序列得分”；</li>
<li>保留“序列得分”最大的k个作为下一步的输入；</li>
<li>不断重复上述过程，直至结束，选择“序列得分”最大的那个序列作为最终结果。</li>
</ul>
<p>这里的重点就在于这个“序列得分”的计算。</p>
<p>我们使用如下的score函数来定义<strong>「序列得分」</strong>：</p>
<figure>
<img src="https://www.zhihu.com/equation?tex=score%28y_1%2C...%2Cy_t%29%3D%5Csum%5E%7Bt%7D_%7Bi%3D1%7DlogP%28y_i%7Cy_1%2Cy_2%2C...%2Cy_%7Bi-1%7D%2Cx%29+%5C%5C" alt="[公式]">
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>这个score代表了当前到第t步的输出序列的一个综合得分，越高越好。其中<img src="https://www.zhihu.com/equation?tex=logP%28y_i%7Cy_1%2Cy_2%2C...%2Cy_%7Bi-1%7D%2Cx%29" alt="[公式]">类似于前面我们写的第t步的交叉熵损失的负数。所以这个score越到，就意味着到当前这一步为止，输出序列的累积损失越小。</p>
<p>再多描述不如一张图直观，我用下图描绘一个极简的案例（只有3个词的语料，k=2）：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182131550.jpg" alt="img" style="zoom: 67%;"></p>
<p>最后还有一个问题：由于会有多个分支，所以很有可能我们会遇到多个<code>&lt;end&gt;</code>标识，由于分支较多，如果等每一个分支都遇到<code>&lt;end&gt;</code>才停的话，可能耗时太久，因此一般我们会设定一些规则，比如已经走了T步，或者已经积累了N条已完成的句子，就终止beam
search过程。</p>
<p>在search结束之后，我们需要对已完成的N个序列做一个抉择，挑选出最好的那个，那不就是通过前面定义的score函数来比较吗？确实可以，但是如果直接使用score来挑选的话，会导致那些很短的句子更容易被选出。<strong>因为score函数的每一项都是负的，序列越长，score往往就越小。因此我们可以使用长度来对score函数进行细微的调整：对每个序列的得分，除以序列的长度。根据调整后的结果来选择best
one。</strong></p>
<p>Beam Search的使用，往往可以得到比Greedy
Search更好的结果，道理很容易理解，高手下棋想三步，深思熟虑才能走得远。</p>
<h3><span id="15-nmt的优缺点">1.5 <strong>NMT的优缺点</strong></span></h3>
<p>NMT相比于SMT，最大的优点当然就如前面所说的——简洁。我们<strong>不需要什么人工的特征工程，不需要各种复杂的前后组件，就是一个端到端的神经网络，整个结构一起进行优化</strong>。</p>
<p>另外，由于使用了深度学习的方法，我们可以引入很多语义特征，比如利用文本的相似度，利用文本内隐含的多层次特征，这些都是统计学方法没有的。</p>
<p>但是，没有什么东西是绝对好或绝对差的，NMT也有其不足。它的不足也是跟深度学习的黑箱本质息息相关。<strong>NMT的解释性差，难以调试，难以控制，我们谁也不敢保证遇到一个新的文本它会翻译出什么奇怪的玩意儿，所以NMT在重要场合使用是有明显风险的。</strong></p>
<h3><span id="16-nmt的评价">1.6 <strong>NMT的评价</strong></span></h3>
<p>机器翻译的效果如何评价呢？——<strong>「BLEU」</strong>指标。<strong>BLEU，全称是Bilingual
Evaluation
Understudy，它的主要思想是基于N-gram等特征来比较人工翻译和机器翻译结果的相似程度。</strong></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/3EQCSMJ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3EQCSMJ/" class="post-title-link" itemprop="url">深度学习（3）Normalization*</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-14 22:12:43" itemprop="dateCreated datePublished" datetime="2022-05-14T22:12:43+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-18 21:10:47" itemprop="dateModified" datetime="2023-04-18T21:10:47+08:00">2023-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">【draft】深度学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">理论基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>15k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="batchnormalization的原理作用和实现">BatchNormalization的原理、作用和实现</h1>
<blockquote>
<p>Transformer中的归一化(一)：什么是归一化&amp;为什么要归一化 - Gordon
Lee的文章 - 知乎 https://zhuanlan.zhihu.com/p/476102712</p>
<p>Transformer中的归一化(二)：机器学习中的特征归一化方法 - Gordon
Lee的文章 - 知乎 https://zhuanlan.zhihu.com/p/477116352</p>
<p>Transformer中的归一化(三)：特征归一化在深度神经网络的作用 - Gordon
Lee的文章 - 知乎 https://zhuanlan.zhihu.com/p/481179310</p>
<p><strong>Transformer中的归一化(四)：BatchNormalization的原理、作用和实现</strong>:https://zhuanlan.zhihu.com/p/481277619?utm_source=wechatMessage_undefined_bottom</p>
<p><strong>Transformer中的归一化(五)：Layer Norm的原理和实现 &amp;
为什么Transformer要用LayerNorm</strong> - Gordon Lee的文章 - 知乎
https://zhuanlan.zhihu.com/p/492803886</p>
</blockquote>
<h4 id="归一化的作用">归一化的作用：</h4>
<ul>
<li><strong>可解释性</strong>：<strong>回归模型</strong>中自变量X的量纲不一致导致了<strong>==回归系数无法直接解读==</strong>或者错误解读；需要将X都处理到统一量纲下，这样才可比【可解释性】；<strong>取决于我们的逻辑回归是不是用了正则化</strong>。如果你不用正则，标准化并不是必须的，如果用正则，那么标准化是必须的。</li>
<li><strong>距离计算</strong>：机器学习任务和统计学任务中有很多地方要用到<strong>==“距离”的计算==</strong>，比如<strong>PCA，比如KNN，比如kmeans</strong>等等，假使算欧式距离，不同维度量纲不同可能会导致距离的计算依赖于量纲较大的那些特征而得到不合理的结果；</li>
<li><strong>加速收敛（BN）</strong>：参数估计时使用<strong>==梯度下降==</strong>，在使用梯度下降的方法求解最优化问题时，
归一化/标准化后可以加快梯度下降的求解速度，即<strong>==提升模型的收敛速度==</strong>。</li>
</ul>
<h4 id="batch-normalization-作用">Batch Normalization 作用：</h4>
<ul>
<li><strong>更好的尺度不变性：</strong>也就是说不管低层的参数如何变化，逐层的输入分布都保持相对稳定。
<ul>
<li><strong><font color="red">尺度不变性能够提高梯度下降算法的效率，从而加快收敛</font></strong>;</li>
<li><strong><font color="red">归一化到均值为0，方差为1的分布也能够使得经过sigmoid，tanh等激活函数以后，尽可能落在梯度非饱和区，缓解梯度消失的问题。</font></strong>【<strong>bn和ln都可以比较好的抑制梯度消失和梯度爆炸的情况</strong>】;</li>
</ul></li>
<li><strong>更平滑的优化地形：</strong>更平滑的优化地形意味着<strong>局部最小值的点更少</strong>，能够使得梯度更加reliable和predictive，从而让我们有更大的”信心”迈出更大的step来优化，即可以使用更大的学习率来加速收敛。</li>
<li><strong><font color="red">
对参数初始化和学习率大小不太敏感：</font></strong>BN操作可以抑制参数微小变化随网络加深的影响，使网络可以对参数初始化和尺度变化适应性更强，从而可以使用更大的学习率而不用担心参数更新step过大带来的训练不稳定。</li>
<li><strong>隐性的正则化效果：（Batch）</strong>训练时采用随机选取mini-batch来计算均值和方差，不同mini-batch的均值和方差不同，近似于引入了随机噪音，使得模型不会过拟合到某一特定的均值和方差参数下，提高网络泛化能力。</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/3EQCSMJ/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/ZQ2GRE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/ZQ2GRE/" class="post-title-link" itemprop="url">异常检测（2）Isolation Forest</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-14 21:23:06" itemprop="dateCreated datePublished" datetime="2022-05-14T21:23:06+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-26 15:23:45" itemprop="dateModified" datetime="2023-04-26T15:23:45+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">异常检测</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3><span id="一-isolation-forest">一、Isolation Forest</span></h3>
<h4><span id="11-概述">1.1 概述</span></h4>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304261520459.png" alt="Isolation Forest算法梳理🌳" style="zoom: 67%;"></p>
<p><strong>异常检测 (anomaly
detection)</strong>，或者又被称为“<strong>离群点检测</strong>” (outlier
detection)，是机器学习研究领域中跟现实紧密联系、有广泛应用需求的一类问题。但是，什么是异常，并没有标准答案，通常因具体应用场景而异。如果要给一个比较通用的定义，很多文献通常会引用
Hawkins
在文章开头那段话。很多后来者的说法，跟这个定义大同小异。这些定义虽然笼统，但其实暗含了认定“异常”的两个标准或者说假设：</p>
<p><strong>孤立森林 (Isolation Forest) 是一个基于 Ensemble
的快速异常检测方法，具有线性时间复杂度和高精准度</strong>。其
可以用于网络安全中的攻击检测，金融交易欺计检测，疾病侦测，和噪声数据过滤等。</p>
<p>孤立森林算法的理论基础有两点：</p>
<ul>
<li>异常数据占总样本量的比列很小</li>
<li>异常点的特征值与正常点的差异很大</li>
</ul>
<h4><span id="12-itree的构建">1.2 iTREE的构建</span></h4>
<p><span class="math inline">\(i T r e e\)</span> 是一棵随机二叉树,
每一个节点要么有两个孩子, 要么就是叶子节点。假设给定一堆数据集 <span class="math inline">\(\mathbb{D} ，\)</span> 这里 <span class="math inline">\(\mathbb{D}\)</span> 的所有属性都是连续型的变量,
iTree 的构建过程如下:</p>
<ol type="1">
<li><p><strong>随机选择一个属性 Attr</strong> ；</p></li>
<li><p><strong>随机选择该属性的一个值 Value</strong>， <span class="math inline">\(\min \{A t t r\}&lt;\)</span> Value <span class="math inline">\(&lt;\max \{\)</span> Attr <span class="math inline">\(\}\)</span> ；</p></li>
<li><p><strong>根据 Attr 对每条记录进行分类，把 Attr 小于 Value
的记录放在左子树，把大于等于 Value 的记录放在右子树；</strong></p></li>
<li><p><strong>递归构造左右子树，直到满足下列条件：（1）传入的数据集只有一条记录或者多条同样的记录；
(2) 树的 深度达到了限定深度</strong>。</p></li>
</ol>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304261517402.jpg" alt="img" style="zoom: 33%;"></p>
<p>iTree 构建完成之后, 只需要追踪测试数据落在 iTree
哪个叶子节点上即可评估该数据是否为异常数据, 由图中 <span class="math inline">\(i T r e e\)</span>
的构造过程可以发现异常数据通常会很快被分配到叶子节点上,
因此可以使用叶子结点到根结点的路径长 度（即边的条数） <span class="math inline">\(h(x)\)</span> 来判断一条记录 <span class="math inline">\(x\)</span> 是否是异常点。</p>
<h4><span id="13-iforest-构建">1.3 iForest 构建</span></h4>
<p>由于 <span class="math inline">\(i T r e e\)</span>
是随机选择属性和随机选择属性值来构建的，因此可以预见对于单棵 <span class="math inline">\(i T r e e\)</span> 的预测效果肯定不会很理
想，因此通过引入多棵 iTree
共同来预测那么从效果上看肯定会更具有说服力。iForest 和 Random Forest 的
方法有些类似, 都是通过随机采样, 利用部分采样数据来构造每一棵树,
以保证不同树之间的差异性。在构建 <span class="math inline">\(i\)</span>
Forest 的过程中有, 采样的样本大小 <span class="math inline">\(\psi\)</span> 和 iTree 的数量 <span class="math inline">\(t\)</span> 这两个超参数需要确定, 样本采样大小超过
256 效 果就提升不大了。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182028401.jpg" alt="img" style="zoom:67%;"></p>
<p>通过采样数据不仅可以降低计算时间的上面的浪费，而且还能够解决一些其它的小问题：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182028205.jpg" alt="preview" style="zoom:67%;"></p>
<p>左图是原始数据, 右图是经过采样了的数据, 蓝色代表正常样本,
红色代表异常样本。可以看出, 在采样之前, 正 常样本和异常样本出现了重叠,
因此很难分开, 但通过采样之后, 异常样本和正常样本可以明显的分开。 <span class="math inline">\(t\)</span> 控制 了 iTree 的数量即 Ensemble size,
孤立森林算法提出者通过实验发现, 当 <span class="math inline">\(t=100\)</span> 之前时, 算法就会收玫, 故 通常设置
<span class="math inline">\(t\)</span> 为默认值 100 , 训练一个 iForest
最差情况下的时间复杂度为 <span class="math inline">\(\mathcal{O}\left(t
\psi^2\right)\)</span> 空间复杂度为 <span class="math inline">\(\mathcal{O}(t \psi)\)</span> 。</p>
<h4><span id="14-评估">1.4 评估</span></h4>
<p>为了更好的归一化和比较, <strong>孤立森林通过引入异常值函数</strong>
<span class="math inline">\(s(x, n)\)</span> 来衡量记录 <span class="math inline">\(x\)</span> 是否为异常点。</p>
<p>给定一个包含 <span class="math inline">\(n\)</span> 个样本的数据集,
<strong>树的平均路径长度为</strong>： <span class="math inline">\(c(\mathrm{n})\)</span> 。 <span class="math display">\[
c(n)=2 H(n-1)-\frac{2(n-1)}{n}
\]</span> 其中, <span class="math inline">\(H(*)\)</span> 为调和数,
<span class="math inline">\(H(*)=\ln (*)+\xi, \xi\)</span> 为欧拉常数,
约为 <span class="math inline">\(0.5772156649 。 c(n)\)</span>
为给定样本数 <span class="math inline">\(n\)</span> 时,
路径长度的平均值, 用来标准化记录 <span class="math inline">\(x\)</span>
的路径长度 <span class="math inline">\(h(x)\)</span> 。</p>
<p><font color="red">故记录 <span class="math inline">\(x\)</span>
的异常得分可以定义为： <span class="math inline">\(\mathbf{s}(\mathbf{x}, \mathbf{n})\)</span>. 其中,
<span class="math inline">\(E(h(x))\)</span> 为记录 <span class="math inline">\(x\)</span> 在多个 <span class="math inline">\(i T
r e e\)</span> 中的路径长度的期望值。</font>可视化 <span class="math inline">\(s(x, n)\)</span> 与 <span class="math inline">\(E(h(x))\)</span> 的关系: <span class="math display">\[
s(x, n)=2^{-\frac{E(h(x))}{c(n)}}
\]</span></p>
<p><img src="https://pic4.zhimg.com/80/v2-b7f0fe8132465c0b1919b7c283d1e887_1440w.jpg" alt="img" style="zoom: 67%;"></p>
<p><strong>可以得出以下结论:</strong></p>
<ul>
<li>当 <span class="math inline">\(E(h(x)) \rightarrow c(n)\)</span> 时,
<span class="math inline">\(s \rightarrow 0.5\)</span> ， 即记录 <span class="math inline">\(x\)</span> 的平均长度与树的平均路径长度相近时,
则不能区分是否为异 常;</li>
<li>当 <span class="math inline">\(E(h(x)) \rightarrow 0 ， s
\rightarrow 1\)</span> ，即记录 <span class="math inline">\(x\)</span>
的异常分数接近 1 时，被判定为异常数据；</li>
<li>当 <span class="math inline">\(E(h(x)) \rightarrow n-1\)</span> 时,
<span class="math inline">\(s \rightarrow 0\)</span> ，
被判定为正常数据。</li>
</ul>
<h3><span id="参考文献">参考文献</span></h3>
<ul>
<li>孤立森林(isolation Forest)-一个通过瞎几把乱分进行异常检测的算法 -
小伍哥聊风控的文章 - 知乎 https://zhuanlan.zhihu.com/p/484495545</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/131406753">Isolation
Forest算法梳理🌳</a>Isolation Forest算法梳理🌳</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/30CKG49/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/30CKG49/" class="post-title-link" itemprop="url">特征工程（6）Auto工具</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-14 19:33:31" itemprop="dateCreated datePublished" datetime="2022-05-14T19:33:31+08:00">2022-05-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-26 14:53:13" itemprop="dateModified" datetime="2023-04-26T14:53:13+08:00">2023-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">特征工程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3><span id="一-autoeda-工具">一、AutoEDA 工具</span></h3>
<blockquote>
<p>盘点Kaggle中常见的AutoEDA工具库：
https://zhuanlan.zhihu.com/p/444405236</p>
</blockquote>
<h4><span id="41-pandas-profiling">4.1 <strong>Pandas Profiling</strong></span></h4>
<ul>
<li><a href="http://link.zhihu.com/?target=https%3A//pandas-profiling.github.io/pandas-profiling/docs/master/index.html">https://pandas-profiling.github.io/pandas-profiling/docs/master/index.html</a></li>
</ul>
<p><strong>Pandas
Profiling</strong>是款比较成熟的工具，可以直接传入DataFrame即可完成分析过程，将结果展示为HTML格式，同时分析功能也比较强大。</p>
<ul>
<li>功能：<strong>字段类型分析、变量分布分析、相关性分析、缺失值分析、重复行分析</strong></li>
<li>耗时：较少</li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304261406349.jpg" alt="img" style="zoom: 67%;"></p>
<h4><span id="42-autoviz"><strong>4.2 AutoViz</strong></span></h4>
<ul>
<li><a href="http://link.zhihu.com/?target=https%3A//github.com/AutoViML/AutoViz">https://github.com/AutoViML/AutoViz</a></li>
</ul>
<p><strong>AutoViz是款美观的数据分析工具</strong>，在进行可视化的同时将结果保存为图片格式。</p>
<ul>
<li>功能：<strong>相关性分析、数值变量箱线图、数值变量分布图</strong></li>
<li>耗时：较多</li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304261406304.jpg" alt="img" style="zoom: 67%;"></p>
<h4><span id="43-dataprep">4.3 <strong>Dataprep</strong></span></h4>
<ul>
<li><a href="http://link.zhihu.com/?target=https%3A//dataprep.ai/">https://dataprep.ai/</a></li>
</ul>
<p><strong>Dataprep是款比较灵活也比较强大的工具，也是笔者最喜欢的。它可以指定列进行分析，同时也可以在Notebook中进行交互式分析。</strong></p>
<ul>
<li>功能：<strong>字段类型分析、变量分布分析、相关性分析、缺失值分析、交互式分析</strong>。</li>
<li>耗时：较多</li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304261406891.jpg" alt="img" style="zoom: 67%;"></p>
<h4><span id="44-sweetviz"><strong>4.4 SweetViz</strong></span></h4>
<ul>
<li><a href="http://link.zhihu.com/?target=https%3A//github.com/fbdesignpro/sweetviz">https://github.com/fbdesignpro/sweetviz</a></li>
</ul>
<p><strong>SweetViz是款强大的数据分析工具，可以很好的分析训练集和测试集，以及目标标签与特征之间的关系</strong>。</p>
<ul>
<li>功能：数据集对比分析、字段类型分析、变量分布分析、目标变量分析</li>
<li>耗时：中等<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304261406924.jpg" alt="img" style="zoom:67%;"></li>
</ul>
<h4><span id="45-d-tale">4.5 D-Tale</span></h4>
<ul>
<li><a href="http://link.zhihu.com/?target=https%3A//github.com/man-group/dtale">https://github.com/man-group/dtale</a></li>
</ul>
<p><code>D-Tale</code>是款功能最为强大的数据分析工具，对单变量的分析过程支持比较好。</p>
<ul>
<li>功能：字段类型分析、变量分布分析、相关性分析、缺失值分析、交互式分析。</li>
<li>耗时：中等</li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304261406335.jpg" alt="img" style="zoom:67%;"></p>
<h3><span id="二-警惕特征工程中的陷阱">二、警惕「特征工程」中的陷阱</span></h3>
<ul>
<li>https://zhuanlan.zhihu.com/p/33651227</li>
</ul>
<p>特征工程(Feature
Engineering)是机器学习中的重要环节。在传统的项目中，百分之七十以上的时间都花在了预处理数据上(Data
Preprocessing)，其中特征工程消耗了很多时间。</p>
<p><strong>一般来说, 特征工程涵盖的内容非常广泛,
包括从缺失值补全、特征选择、维度压缩, 到对输入数据的范围进行变 换 (Data
Scaling) 等</strong>。举个简单的例子, 一个K-近邻算法的输入数据有两个特征
<span class="math inline">\(X_1, X_2\)</span>, 但 <span class="math inline">\(X_1\)</span> 这个特征的 取值范围在 <span class="math inline">\([0,1]\)</span> 而 <span class="math inline">\(X_2\)</span> 的范围在 <span class="math inline">\([-1000,1000]\)</span> 。不可避免的,
K-近邻的结果取决于距离, 那么很容易被取值范 围大的特征, 也就是此处的
<span class="math inline">\(X_2\)</span> 所“垄断”。在这种情况下, 把
<span class="math inline">\(X_1, X_2\)</span>
的取值调整到可比较的范围上就成了必须。 常见的做法有归一化或者标准化,
此处不再赘述, 可以参考[1]。为了简化内容, 本文中的例子仅以归一化作为唯
一的特征工程。今天主要说的是: 特征工程中的面临的进退两难。</p>
<h4><span id="21-如何保证训练集-测试集-预测数据-有相同的输入">2.1 <strong>如何保证
训练集、测试集、预测数据 有相同的输入？</strong></span></h4>
<p>以刚才的例子为基础，我们把所有数据按照70:30的比例分为训练集和测试集，并打算使用K-近邻进行训练。那么一个令人困扰的问题是，对训练集的特征做归一化后，测试集的特征怎么办？这是一个非常关键的问题，因为训练集<strong>特征归一化</strong>后，测试集的特征范围可能就不同了，因此模型失效。一般有几种思路：</p>
<ul>
<li><strong>方法1：把训练集和测试集合在一起做归一化</strong>，这样特征范围就统一了。之后用训练集做训练，那测试集做测试。<strong>但很明显的，在训练模型时，不应该包括任何测试集的信息</strong>。这种做法会导致存在人为偏差的模型，不能用。</li>
<li><strong>方法2：对训练集单独做归一化，之后对测试集单独做归一化</strong>。这种看法看似也可以，重点在于数据量以及数据的排列顺序。<strong>在数据量大且数据被充分打乱的前提下，这种做法是可行的</strong>。但换句话说，如果有这样的前提假设，那么方法1的结论也是可行的。</li>
<li><strong>方法3：对训练集先做归一化，并保留其归一化参数（如最大、最小值），之后用训练集的归一化参数对测试集做处理。</strong>这种做法看似是可以的。<strong>但风险在于数据量有限的前提下，训练集的参数会导致测试集的结果异常，如产生极大或者极小的数值</strong>。</li>
</ul>
<blockquote>
<p>其实不难看出，从某种意义上说，三种做法是等价的。在数据量大且充分打乱的前提下，训练集和验证集有相同的分布假设，因此用任意一种其实差别不大。然而这样的假设过于乐观，<strong>且我们在真实情况下应该只有{训练集+1个测试数据}，因此方法2是明显不行的</strong>。</p>
<p>方法1常常被认为是错误的操作，原因是在训练阶段引入了测试数据，这属于未知数据。即使仅仅引入了1个测试数据，如果取值非常极端，依然会导致输出范围有较大的波动。其次，如果对于每一个测试数据都需要用整个训练集来归一的话，那么运算开销会非常大。</p>
<p>那么似乎备选的只有方案3，即保<strong>留验证集上的归一化参数</strong>，并运用于测试集。这样的做法看似可以，但有不少风险：</p>
<ul>
<li><strong>不是每种特征工程都可以保存参数，很多特征工程是非常繁复的</strong>。</li>
<li>如果测试集数据和训练集数据有很大的差别，那么用测试集的参数会产生异常数据。</li>
</ul>
</blockquote>
<h4><span id="22-可能的解决方案">2.2 可能的解决方案</span></h4>
<p>在<strong>模型评估阶段</strong>，如果我们假设拥有大量数据，且充分打乱其顺序。那么在划分训练集和测试集前，可以对整体数据进行统一的特征工程。不难看出，这和统计学的大数定理有异曲同工之妙。这种做法是最为高效的，需要的运算量最小。而将“测试数据”暴露给训练模型的风险也并不大，因为大数据量使得分布比较稳定，可以忽略。换个角度来看，当数据量非常大的时候，使用其他方法进行特征工程的开销会过大，不利于模型评估。因此，在<strong>模型评估阶段</strong>，如果符合以上假设，可以用这种方法（也就是上文的方法1）。但退一步说，如果满足这个条件，那么方法3也是等价的。</p>
<p>在<strong>预测阶段</strong>，每次假设我们只有1个测试点，那么最佳方案还是保存训练集上特征工程的参数或者模型，并直接用于未知数据的特征工程（也就是上文的方法3）。</p>
<p>但在<strong>预测阶段</strong>，一个一个数据的预测是非常昂贵的，我们一般会做<strong>“批处理”(batch
operation)</strong>。换句话说，就是攒够一定量的预测数据后统一进行预测。在这种情况下，我们：</p>
<ul>
<li>利用方法3，按照顺序对每个训练数据进行处理</li>
<li>利用方法1，风险在于（方法1）会影响训练数据且需要重新训模型</li>
<li><strong>利用方法2，此时较为稳妥</strong>。在批的尺寸较大，且与训练数据分布相同（接近）时，效果应该与方法3一致，但效率可以得到提升</li>
</ul>
<h4><span id="23-总结"><strong>2.3 总结</strong></span></h4>
<p>这篇文章的重点是：“特征工程虽然重要，但极容易在使用中带来风险。”比如在训练时同时误用了测试数据进行特征工程，也叫做数据泄露(data
leakage)。但数据泄露其实也是个伪命题，<strong>当数据量大且分布相同时，使用哪一种方法得到结果应该都近似等价，而更重要的是运行效率</strong>。分类讨论的话，方法1、2、3都有可能是适合的方法。</p>
<p>但我们依然希望能避免类似的风险，因此尽量避免不必要的特征工程，有以下建议：</p>
<ul>
<li><strong>选择对于特征学习能力强的模型，在数据量允许的情况下可以选择深度学习</strong></li>
<li><strong>避免不必要的特征工程，数据范围比较良好的情况下省略某些特征工程</strong></li>
<li><strong>优先选择对于特征工程要求低的模型，如xgboost等</strong></li>
</ul>
<h3><span id="三-业务角度看特征工程">三、业务角度看特征工程</span></h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/505480353">如何从业务角度看特征工程</a></p>
<p>前两天刷某知名社交软件的时候看到有人问特征工程现在还重要吗？觉得是个很有意思的事情。其实工业界能够支持的起大规模稀疏向量的场景大概并不是想象中的那么多，大多数场景面对极为稀疏的行为数据下都很难在ID层面得到很好的emb表达。在这个前提下，没有好的特征工程，其余的模型结构优化或者各种花里胡哨的模型结构都是纸上谈兵。真正被小场景捶打过的朋友，比如我，绝对会在一次又一次的生活毒打中明白，抛弃那些ppt上的高级多塔多注意力，直面特征工程的人生吧！</p>
<p>有竞赛经验的小伙伴都明白，一个强特能一飞冲天，一个灵机一动能直上top榜。但是，长久的可持续的特征工程决不能够靠简单的灵机一动来实现，特别是当手上有无数的芝麻大小的场景时，一个系统的特征工程思维就尤为重要了。本文将从以下几个方面来阐述特征工程中的方方面面。提前说明的是，一般的特征工程常用方法，例如one-hot，hash-encoding，分桶等等不会作为本文的重点，因为这是器的维度，文末有一篇非常全面的文章供参考，本文主要聚焦在术的维度，也就是怎么去思考和选用方法的层面。<strong>首先，我会给出一个特征工程树，这个属于一个主流版本，希望在屏蔽场景特殊性的情况下，给出一般场景的思考方法</strong>。接下来，我会介绍上文提到的特征树的细节，包括涉及到的具体特征例子。第三部分，则包括特征之间可能存在的相互作用和不同特征适合的模型类型。最后，我给出了一个具体场景的具体例子，并说明这个场景的一般性和特殊性，给出针对具体业务场景的特征工程思路。</p>
<p>此外，一个基础认知是，这里的特征是指输入模型的信息，包括偏置或者先验，这些特征的使用方式除了作为模型的输入，也可以通过其他的方式引入，例如样本工程或者损失函数，这个就不在本文讨论范围之内了。当然还是那句老话，个人的认知是有限的，欢迎有经验的小伙伴交流和指正。</p>
<h4><span id="31-基础特征树">3.1 基础特征树</span></h4>
<p>不管是基于已有的模型迭代优化，又或者是从0到1构建一个场景的全部特征，都需要自己梳理一个完整的基础特征树。这是了解一个场景的开始。做这件事情我推荐的方法是<strong>先体验这个场景，然后分类列出所有可能影响你优化目标决策的因素以及优化目标的历史信息</strong>。</p>
<p>对于绝大多数业务来讲，基础的特征树都可以分为以下3大部分。</p>
<ul>
<li><strong>供给侧</strong>：对于大部分to
c的互联网应用，供给侧都是item，可能是音乐，doc或者一条推送消息。</li>
<li><strong>消费侧</strong>：有关用户的一切描述，其中比较特殊的是序列特征。</li>
<li><strong>上下文</strong>：场景测的因素，包括特定的时刻，特定的展现形式等。</li>
<li><strong>交叉特征</strong>：以上三个部分任意两部分或全部的交叉特征。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/21E1VBV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/21E1VBV/" class="post-title-link" itemprop="url">深度学习（10）AutoEncoder</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-13 19:15:40" itemprop="dateCreated datePublished" datetime="2022-05-13T19:15:40+08:00">2022-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-15 21:23:07" itemprop="dateModified" datetime="2022-06-15T21:23:07+08:00">2022-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">【draft】深度学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/Seq2Seq/" itemprop="url" rel="index"><span itemprop="name">Seq2Seq</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>21 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="自编码器autoencoder">自编码器（AutoEncoder）</span></h2>
<h4><span id="引言">引言</span></h4>
<p>    当你在看论文的时候，经常会遇到编码器、解码器、自编码器（Autoencoder）这些字眼，它们到底是干什么的呢？其主要作用又是什么呢？那么本篇主要带大家了解自编码器（Autoencoder）。</p>
<h3><span id="一-自编码器autoencoder介绍">一、自编码器（Autoencoder）介绍</span></h3>
<p>暂且不谈神经网络、深度学习等，仅仅是自编码器的话，其原理其实很简单。自编码器可以理解为一个试图去还原其原始输入的系统。自编码器模型如下图所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-f4444b7343ef311fd04f0dc0dc1db3b7_1440w.jpg" alt="img" style="zoom:67%;"></p>
<p>从上图可以看出，自编码器模型主要由编码器（Encoder）和解码器（Decoder）组成，其主要目的是将输入x转换成中间变量y，然后再将y转换成
<img src="https://www.zhihu.com/equation?tex=%5Coverline+x" alt="[公式]"> ，然后对比输入x和输出 <img src="https://www.zhihu.com/equation?tex=%5Coverline+x" alt="[公式]">
使得他们两个无限接近。</p>
<h4><span id="11-神经网络自编码模型">1.1 神经网络自编码模型</span></h4>
<p>在深度学习中，自动编码器是一种无监督的神经网络模型，它可以学习到输入数据的隐含特征，这称为编码(coding)，同时用学习到的新特征可以重构出原始输入数据，称之为解码(decoding)。从直观上来看，自动编码器可以用于特征降维，类似主成分分析PCA，但是其相比PCA其性能更强，这是由于神经网络模型可以提取更有效的新特征。除了进行特征降维，自动编码器学习到的新特征可以送入有监督学习模型中，所以自动编码器可以起到特征提取器的作用<strong>。举个例子，我有一张清晰图片，首先我通过编码器压缩这张图片的大小（如果展现出来可能比较模型），然后在需要解码的时候将其还原成清晰的图片</strong>。具体过程如下图所示。</p>
<h4><span id="12-神经网络自编码器三大特点">1.2 神经网络自编码器三大特点</span></h4>
<ul>
<li><strong>自动编码器是数据相关</strong>的（data-specific 或
data-dependent），这意味着自动编码器只能压缩那些与训练数据类似的数据。比如，使用人脸训练出来的自动编码器在压缩别的图片，比如树木时性能很差，因为它学习到的特征是与人脸相关的。</li>
<li><strong>自动编码器是有损的</strong>，意思是解压缩的输出与原来的输入相比是退化的，MP3，JPEG等压缩算法也是如此。这与无损压缩算法不同。</li>
<li>自动编码器是从数据样本中自动学习的，这意味着很容易对指定类的输入训练出一种特定的编码器，而不需要完成任何新工作。</li>
</ul>
<h4><span id="13-自编码器autoencoder搭建">1.3 自编码器（Autoencoder）搭建</span></h4>
<p>搭建一个自动编码器需要完成下面三样工作：搭建<strong>编码器</strong>，搭建<strong>解码器</strong>，设定一个<strong>损失函数，用以衡量由于压缩而损失掉的信息</strong>。编码器和解码器一般都是参数化的方程，并关于损失函数可导，典型情况是使用神经网络。编码器和解码器的参数可以通过最小化损失函数而优化，例如<strong>SGD</strong>。举个例子：根据上面介绍，自动编码器看作由两个级联网络组成。</p>
<ul>
<li>第一个网络是一个编码器，负责接收输入 x，并将输入通过函数 h
变换为信号 y：</li>
</ul>
<figure>
<img src="https://pic3.zhimg.com/80/v2-b9331fbb152409c69a14c056b6d56c52_1440w.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>第二个网络将编码的信号 y 作为其输入，通过函数f得到重构的信号
r：</li>
</ul>
<figure>
<img src="https://pic2.zhimg.com/80/v2-38e2787955e83ebf81b74992ac77da79_1440w.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<ul>
<li>定义误差 e 为原始输入 x 与重构信号 r
之差，e=x–r，网络训练的目标是减少<strong>均方误差（MSE）</strong>，同
MLP 一样，误差被反向传播回隐藏层。</li>
</ul>
<h4><span id="14-几种常见编码器">1.4 几种常见编码器</span></h4>
<p>自编码器（autoencoder）是神经网络的一种，经过训练后能尝试将输入复制到输出。自编码器（）autoencoder）内部有一个隐藏层
h，可以产生编码（code）表示输入。该网络可以看作由两部分组成：一个由函数
h = f(x) 表示的编码器和一个生成重构的解码器 r =
g(h)。如果一个自编码器只是简单地学会将处处设置为 g(f(x)) =
x，那么这个自编码器就没什么特别的用处。相反，<strong>我们不应该将自编码器设计成输入到输出完全相等</strong>。这通常需要向自编码器强加一些约束，使它只能近似地复制，并只能复制与训练数据相似的输入。这些约束强制模型考虑输入数据的哪些部分需要被优先复制，因此它往往能学习到数据的有用特性。</p>
<ul>
<li><strong>堆栈自动编码器</strong>
前面讲的自编码器只是简答的含有一层，其实可以采用更深层的架构，这就是堆栈自动编码器或者深度自动编码器，本质上就是增加中间特征层数。这里我们以MNIST数据为例来说明自动编码器，建立两个隐含层的自动编码器，如下图所示：</li>
</ul>
<figure>
<img src="https://pic4.zhimg.com/80/v2-e1b65e3d86fd1a8fbb56df20eeefd113_1440w.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p>    对于MNIST来说，其输入是<span class="math inline">\(28*28=784\)</span>维度的特征，这里使用了两个隐含层其维度分别为300和150，可以看到是不断降低特征的维度了。得到的最终编码为150维度的特征，使用这个特征进行反向重构得到重建的特征，我们希望重建特征和原始特征尽量相同。</p>
<ul>
<li><p><strong>欠完备自编码器</strong>从自编码器获得有用特征的一种方法是限制
h的维度比 x
小，这种编码维度小于输入维度的自编码器称为欠完备（undercomplete）自编码器。<strong>学习欠完备的表示将强制自编码器捕捉训练数据中最显著的特征</strong>。</p></li>
<li><p><strong>正则自编码器</strong>使用的损失函数可以鼓励模型学习其他特性（除了将输入复制到输出），而不必限制使用浅层的编码器和解码器以及小的编码维数来限制模型的容量。这些特性包括稀疏表示、表示的小导数、以及对噪声或输入缺失的鲁棒性。即使模型容量大到足以学习一个无意义的恒等函数，非线性且过完备的正则自编码器仍然能够从数据中学到一些关于数据分布的有用信息。</p></li>
<li><p><strong>去噪自编码器</strong>（denoisingautoencoder,
DAE）是一类接受损坏数据作为输入，并训练来预测原始未被损坏数据作为输出的自编码器。</p></li>
</ul>
<h2><span id="二-李宏毅-auto-encoder-p1">二、李宏毅-Auto-Encoder P1</span></h2>
<h3><span id="21-self-supervisedlearning-framework"><strong>2.1 Self-supervised
Learning Framework</strong></span></h3>
<p>在讲 Auto-Encoder 之前,其实 Auto-Encoder 也可以算是,Self-Supervised
Learning 的一环,所以再让我们用非常短的时间,来看一下Self-Supervised
Learning 的 Framework。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615182816027.png" alt="image-20220615182816027" style="zoom:50%;"></p>
<p>首先你有大量的没有标注的资料,用这些没有标注的资料,你可以去训练一个模型,你必须发明一些不需要标注资料的任务,比如说做填空题,比如说预测下一个
Token。</p>
<p>这个不用标注资料的学习叫做,==Self-Supervised
Learning==,或者是也有人叫
==Pre-Training==,那用这些不用标注资料的任务,学完一个模型以后,它本身没有什麽用,BERT
只能做填空题,GPT
只能够把一句话补完,但是你可以把它用在其他下游的任务里面。你可以把
Self-Supervised Learning 的
Model,做一点点的微微的调整,就可以用在下游的任务里面。</p>
<p><strong><font color="red"> 在有 BERT 在有 GPT
之前,其实有一个更古老的任务,更古老的不需要用标注资料的任务,就叫做
Auto-Encoder,所以你也可以把 Auto-Encoder,看作是 Self-Supervised Learning
的,一种 Pre-Train 的方法。</font></strong></p>
<p>当然可能不是所有人都会同意这个观点,有人可能会说这个
Auto-Encoder,不算是 Self-Supervised Learning,这个 Auto-Encoder
很早就有了嘛,2006 年 15 年前就有了嘛,然后 Self-Supervised Learning 是,19
年才有这个词彙嘛,所以 Auto-Encoder,不算 Self-Supervised Learning
的一环。</p>
<p>那这个都是见仁见智的问题,这种名词定义的问题,真的我们就不用太纠结在这个地方,从
Self-Supervised Learning,它是不需要用 Label Data
来训练,这个观点来看,<strong>Auto-Encoder
我认为它可以算是,Self-Supervised Learning 的其中的一种方法,它就跟填空
预测,接下来的 Token
是很类似的概念,只是用的是另外不一样的想法</strong>。</p>
<h3><span id="22-auto-encoder">2.2 Auto-encoder</span></h3>
<p>Auto-Encoder 是怎麽运作的呢,那现在我们,因为刚才在讲 Self-Supervised
Learning 的时候,都是用文字做例子,那现在我们换成用影像来做例子：</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615183004489.png" alt="image-20220615183004489" style="zoom:50%;"></p>
<p>假设你有非常大量的图片,在 Auto-Encoder 里面你有两个 Network,一个叫做
Encoder,一个叫做 Decoder,他们就是两个 Network</p>
<ul>
<li><p><strong>Encoder 把一张图片读进来,它把这张图片变成一个向量,就
Encoder 它可能是很多层的
CNN,把一张图片读进来,它的输出是一个向量,接下来这个向量会变成 Decoder
的输入</strong></p></li>
<li><p><strong>Decoder 会产生一张图片,所以 Decoder 的 Network
的架构,可能会像是 GAN 里面的 Generator,它是 11
个向量输出一张图片</strong></p></li>
</ul>
<p><strong><font color="red"> 训练的目标是希望,Encoder 的输入跟 Decoder
的输出,越接近越好，假设你把图片看作是一个很长的向量的话,我们就希望这个向量跟
Decoder
的输出,这个向量,这两个向量他们的距离越接近越好,也有人把这件事情叫做
==Reconstruction==,叫做重建。</font></strong></p>
<p>所以它是一个 <strong>Unsupervised Learning 的方法</strong>,跟
Self-Supervised 那一系列,Pre-Training
的做法一样,你<strong>完全不需要任何的标注资料</strong>。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615183155224.png" alt="image-20220615183155224" style="zoom: 50%;"></p>
<p>那像这样子这个 <strong>Encoder 的输出,有时候我们叫它
Embedding</strong>,我们在讲 BERT 的时候,也提过 Embedding
这个词彙了,那有的人叫它 Representation,有的人叫它 Code,因为 Encoder
是一个编码嘛,所以这个有人把这个 Vector 叫做
Code,那其实指的都是同一件事情。</p>
<h5><span id="怎麽把train-的-auto-encoder用在-downstream-的任务里面呢">怎麽把
Train 的 Auto-Encoder,用在 Downstream 的任务里面呢？</span></h5>
<p>常见的用法就是,原来的图片,你也可以把它看作是一个很长的向量,但这个<strong>向量太长了不好处理</strong>,那怎麽办呢？你把这个图片丢到
<strong>Encoder
以后,输出另外一个向量,这个向量你会让它比较短</strong>,比如说只有 10 维
只有 100
维,那你拿这个新的向量来做你接下来的任务,也就是图片不再是一个很高维度的向量,它通过
Encoder
的压缩以后,变成了一个低维度的向量,你再拿这个低维度的向量,来做接下来想做的事情,这就是常见的,Auto-Encoder用在
Downstream 的任务,用在下游任务的方法。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615183309937.png" alt="image-20220615183309937" style="zoom:50%;"></p>
<p><strong><font color="red"> 而 Encoder
做的事情,是把本来很高维度的东西,转成低维度的东西,把高维度的东西转成低维度的东西又叫做
==Dimension Reduction==。</font></strong></p>
<p>Dimension Reduction 这个技术,我相信你在 Machine Learning
相关的应用上,应该常常听到这个名词,那有关 Dimension Reduction
的技术,它其实牵涉的非常非常地广,所以我们这边就不再细讲,因为这门课,我们只专注在深度学习相关的技术,你可以把
Auto-Encoder 的 Encoder,当作拿来做 Dimension
Reduction,那其他还有很多不是 Deep Learning
Base的,不是以深度学习为基础的,Dimension Reduction的技术。<strong>比如说
PCA 比如说 T-SNE</strong>。</p>
<h3><span id="24-de-noising-auto-encoder">2.4 De-noising Auto-encoder</span></h3>
<p>那 Auto-Encoder 还有一个常见的变形,叫做 De-Noising 的
Auto-Encoder</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615185731272.png" alt="image-20220615185731272" style="zoom:67%;"></p>
<p>De-Noising 的 Auto-Encoder 是说,我们把原来要输进去给 Encoder
的图片,<strong>加上一些杂讯</strong>,就自己随便找一个杂讯把它加进去,然后一样通过
Encoder,一样再通过 Decoder,试图还原原来的图片。那我们现在还原的,不是
Encoder 的输入,Encoder 的输入的图片是有加杂讯的,我们要还原的不是 Encoder
的输入,我们<strong>要还原的是加入杂讯之前的结果</strong>。</p>
<p>所以你会发现说,现在 Encoder 跟
Decoder,除了还原原来的图片这个任务以外,它还<strong>多了一个任务</strong>,这个任务是什麽,这个任务就是,它必须要<strong>自己学会把杂讯去掉</strong>。Encoder
看到的是没有杂讯的图片,但 Decode要还原的目标是,Encoder
看到的是有加杂讯的图片,但 Decoder 要还原的目标是,没有加杂讯的图片,所以
Encoder 加
Decoder,他们合起来必须要联手能够把杂讯去掉,这样你才能够把,De-Noising 的
Auto-Encoder 训练起来。</p>
<p>但是如果你看今天的 BERT 的话,其实你也可以把它看作就是一个,De-Noising
的 Auto-Encoder：</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615185813727.png" alt="image-20220615185813727" style="zoom:50%;"></p>
<p>输入我们会加 Masking,那些 <strong>Masking 其实就是
Noise</strong>,BERT 的模型就是 Encoder,它的输出就是 Embedding。在讲 BERT
的技术的时候,我们就告诉你说这个输出就叫做 Embedding,接下来有一个 Linear
的模型,就是Decoder,所以我们可以说,BERT 其实就是一个,De-Noising 的
Auto-Encoder。</p>
<h2><span id="三-auto-encoder-p2">三、Auto-Encoder P2</span></h2>
<h3><span id="31-feature-disentangle">3.1 Feature Disentangle</span></h3>
<p><strong><font color="red"> 除了 Aauto-Encoder,可以用来做当 strime
的任务以外,我还想跟大家分享一下,Aauto-Encoder 其他有意思的应用：
==Feature Disentanglement==。Disentangle
的意思就是,把一堆本来纠缠在一起的东西把它解开。</font></strong></p>
<h5><span id="那为什么会有disentangle-这个议题呢我们来想想看aauto-encoder它在做的事情是什么">那为什么会有
Disentangle 这个议题呢,我们来想想看,Aauto-Encoder
它在做的事情是什么？</span></h5>
<h5><span id="auto-encoder-在做的事情是">Auto-Encoder 在做的事情是：</span></h5>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615190047133.png" alt="image-20220615190047133" style="zoom: 67%;"></p>
<ul>
<li>如果是图片的话,就是把一张图片变成一个 Code,再把 Code 呢
变回图片,既然这个 Code 可以变回图片,代表说这个 Code
里面啊,有很多的资讯,包含图片里面所有的资讯,举例来说,图片里面有什么样的东西啊,图片的色泽纹理啊等等</li>
<li>Auto-Encoder
这个概念也不是只能用在影像上,如果用在语音上,你可以把一段声音丢到 Encoder
里面,变成向量 再丢回
Decoder,变回原来的声音,代表这个向量包含了,语音里面所有重要的资讯,包括这句话的内容是什么,就是
Encoder 的资讯,还有这句话是谁说的,就是 Speaker 语者的资讯</li>
<li>那如果今天是一篇文章,丢到 Encoder 里面变成向量,这个向量通过 Decoder
会变回原来的文章,那这个向量里面有什么,它可能包含文章里面,文句的句法的资讯,也包含了语意的资讯,但是这些资讯是全部纠缠在一个向量里面,我们并不知道一个向量的哪些维,代表了哪些资讯</li>
</ul>
<p>举例来说,如果我们今天把一段声音讯号丢进
Encoder,它会给我们一个向量,但是这个向量里面,哪些维度代表了这句话的内容,哪些维度代表这句话的语者,也就是谁说的,我们没有这样的资讯。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615190127357.png" alt="image-20220615190127357" style="zoom:67%;"></p>
<p>而 Feature Disentangle 想要做到的事情就是,我们有没有可能想办法,在
Train 一个 Aauto-Encoder 的时候,同时有办法知道,这个
Representation,或又叫做 Embedding,或又叫做 Code,我们这个
<strong><font color="red"> Embedding
的哪些维度代表了哪些资讯呢？</font></strong></p>
<p>这边举一个语音上的应用,这个应用叫做 Voice Conversion,Voice Conversion
的中文叫做语者转换,所以也许你没有听过语者转换这个词彙,但是你一定看过它的应用,它就是柯南的领结变身器。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615190304137.png" alt="image-20220615190304137" style="zoom:67%;"></p>
<p>这个在二十年前,阿笠博士就已经做得很成功了啦</p>
<p>那只是过去,阿笠博士在做这个 Voice Conversion
的时候啊,我们需要成对的声音讯号,也就是假设你要把 A 的声音转成 B
的声音,你必须把 A 跟 B 都找来,叫他唸一模一样的句子。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615190330572.png" alt="image-20220615190330572" style="zoom:67%;"></p>
<p>就 A 说好 How are you,B 也说好 How are you,A 说 Good morning,B 也说
Good morning,他们两个各说一样的句子,说个 1000 句,接下来呢,就结束了,就是
<strong>Supervised Learning 的问题</strong>啊,你有成对的资料,Train 一个
Supervised 的 Model,把 A 的声音丢进去,输出就变成 B 的声音,就结束了。</p>
<p>但是如果 A 跟 B 都需要唸一模一样的句子,念个 500 1000
句,显然是不切实际的,举例来说,假设我想要把我的声音转成新垣结衣的声音,我得把新垣结衣找来,更退一万步说,假设我真的把新垣结衣找来,她也不会说中文啊,所以她没有办法跟我唸一模一样的句子</p>
<p>而今天有了 Feature Disentangle
的技术以后,也许我们期待机器可以做到,<strong>就给它 A 的声音 给它 B
的声音,A 跟 B
不需要唸同样的句子,甚至不需要讲同样的语言,机器也有可能学会把 A
的声音转成 B 的声音</strong></p>
<p>那实际上是怎么做的呢,假设我们收集到一大堆人类的声音讯号,然后拿这堆声音讯号呢,去
Train 一个 Aauto-Encoder,同时我们又做了 Feature Disentangle
的技术,所以我们<strong>知道在 Encoder
的输出里面,哪些维度代表了语音的内容,哪些维度代表了语者的特徵</strong>。接下来,我们就可以<strong>把两句话,声音跟内容的部分互换</strong>。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615191019338.png" alt="image-20220615191019338" style="zoom: 67%;"></p>
<p>举例来说,这边是我的声音,我说 How are you,丢进 Encoder
以后,那你就可以抽出,你就知道说这个 Encoder 里面,<strong>某些维度代表 How
are you 的内容,某些维度代表我的声音</strong>。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615191033830.png" alt="image-20220615191033830" style="zoom:67%;"></p>
<p>今天你把这个你老婆的声音丢进
Encoder,它就知道某一些维度,代表你老婆说的话的内容,某一些维度,代表你老婆声音的特徵,接下来我们只要<strong>把我说话的内容的部分取出来</strong>,<strong>把你老婆说话的声音特徵的部分取出来,把它拼起来</strong>,丢到
Decoder
里面,就可以用<strong>你老婆的声音,讲我说的话的内容</strong>。</p>
<p>这件事情真的有可能办到吗,以下是真正的例子,听起来像是这个样子,Do you
want to study a PhD,这个是我的声音，那把我的声音丢到 Encoder
里面以后呢,你可以想像说在 Encoder
里面,我们知道哪些维度代表了念博班这件事,哪些维度代表了我的声音。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615191448638.png" alt="image-20220615191448638" style="zoom: 67%;"></p>
<p>那为了简化起见,它输出 100 维的向量,前 50 维代表内容,后 50
维代表说话人的特徵,好 接下来这句话是你老婆说的,仕事忙しいのがな,不知道
不太确定在说什么,就是日文啊</p>
<p>接下来呢,就把我的声音的前 50
维,代表内容的部分取出来,把你老婆的,把你老婆的声音丢进 Encoder 以后,后 50
维的部分抽出来,拼起来,一样是一个 100 维的向量,丢到 Decoder
里面,看看输出来的声音,是不是就是你老婆叫你念博班的声音,听起来像是这个样子,Do
you want to study a PhD</p>
<p>那其实反过来也可以啦,就是换成把日文的部分拿出来,把我的声音的特徵拿出来,一样串成一个
100 维的向量,丢到 Decoder
里面,它听起来就会变成这样,仕事忙しいのがな,我也不知道自己在说什么就是了</p>
<p>所以确实用 Feature Disentangle,你有机会做到 Voice
Conversion,那其实在影像上,在 NLP
上,也都可以有类似的应用,所以可以想想看,Feature Disentangle
可以做什么样的事情</p>
<h3><span id="32-discrete-latentrepresentation">3.2 Discrete Latent
Representation</span></h3>
<p>下一个要跟大家讲的应用,叫做 Discrete Latent
Representation。到目前为止我们都假设这个
Embedding,它就是一个向量,这样就是一串数字,它是 Real
Numbers,那它可不可以是别的东西呢？</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615191527797.png" alt="image-20220615191527797" style="zoom:67%;"></p>
<ul>
<li>举例来说,它可不可以是 Binary,Binary
的好处也许是说,每一个维度,它就代表了某种特徵的有或者是没有,举例来说,输入的这张图片,如果是女生,可能第一维就是
1,男生第一维就是 0,如果有戴眼镜,就是第三维 1,没有戴眼镜 就是第三维是
0,也许我们把这个向量,这个 Embedding 变成 Binary,变成只有 0 跟 1
的数字,可以让我们再解释 Encoder 输出的时候,更为容易</li>
<li>甚至有没有可能这个向量,强迫它一定要是 One-Hot 呢,也就只有一维是
1,其他就是 0,如果我们强迫它是
One-Hot,也就是每一个东西图片丢进去,你只可以有,你的 Embedding
里面只可以有一维是 1,其他都是 0
的话,那可以做到什么样的效果呢,也许可以做到 unSupervised
的分类,举例来说,假设你有一大堆的,假设你想要做那个手写数字辨识,你有 0 到
9 的图片,你把 0 到 9 的图片统统收集起来,Train 一个这样子的
Aauto-Encoder,然后强迫中间的 Latent Representation,强迫中间的这个 Code
啊,一定要是 One-Hot Vector,那你这个 Code 正好设个 10 维,也许每一个
One-Hot 的 Code,所以这 10 维,就有 10 种可能的 One-Hot 的 Code,也许每一种
One-Hot 的 Code,正好就对应到一个数字也说不定,所以今天如果用 One-Hot 的
Vector,来当做你的 Embedding 的话,也许就可以做到完全在没有,完全没有Llabel
Data 的情况下,让机器自动学会分类。</li>
</ul>
<p>其实还有其他,在这种啊 Discrete 的 Representation
的这个,技术里面啊,其中最知名的就是 ==VQVAE==,Vector Quantized
Variational Aauto-Encoder,VQVAE
啊,是这样子运作的,就是你输入一张图片,Encoder 呢
输出一个向量,这个向量它是一般的向量,它是 Continuous 的,但接下来你有一个
==Codebook==。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615191635308.png" alt="image-20220615191635308" style="zoom:67%;"></p>
<p>所谓 Codebook 的意思就是,你有一排向量,这排向量也是 Learn 出来的,你把
Encoder
的输出,去跟这排向量都去算个<strong>相似度</strong>,那你发现这件事情啊,其实跟
Self-attention 有点像,上面这个 Vector 就是 Query,下面这些 Vector 就是
Key,那接下来呢就看这些 Vector
里面,谁的<strong>相似度最大</strong>,那你把相似度最大的那个 Vector
拿出来。==【类似self-attention】==</p>
<p>这边就是那个,这个 Key 跟那个 Value,是等于是共用同一个 Vector。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615191720041.png" alt="image-20220615191720041" style="zoom:67%;"></p>
<p>如果你把这整个 Process,用 Self-attention 来比喻的话,那就等于是 Key 跟
Value 是共同的 Vector,然后把这个 Vector 呢,丢到 Decoder
里面,然后要它输出一张图片,然后接下来 Training
的时候,就是要让输入跟输出越接近越好</p>
<p>这一个 Decoder,这个 Encoder,这一个
Codebook,都是一起从资料里面被学出来的,这样做的好处就是你就可以,你就有
Discrete 的这个 Latent Representation,也就是说这边 Decoder
的输入,一定是这边这个 Codebook,里面的向量的其中一个,假设你 Codebook
里面有 32 个向量,那你 Decoder 的输入,就只有 32
种可能,你等于就是让你的这个
Embedding,它是离散的,它没有无穷无尽的可能,它只有 32 种可能而已</p>
<p>那其实像这样子的技术啊,如果你拿它
把它用在语音上,你就是一段声音讯号输进来,通过 Encoder
以后产生一个向量,接下来呢,你去计算这个相似度,把最像的那个向量拿出来丢给
Decoder,再输出一样的声音讯号,这个时候你会发现说你的 Codebook
啊,可能可以学到最基本的发音部位</p>
<p>举例来说 你的,这个最基本的发音单位啊,又叫做
==Phonetic==,那如果你不知道 Phonetic 是什么的话,你就把它想成是 KK
音标,那你就会发现说,这个 Codebook 里面每一个
Vector,它就对应到某一个发音,就对应到 KK 音标里面的某一个符号,这个是
VQVAE。</p>
<h3><span id="33-anomalydetection"><strong><font color="red"> 3.3 Anomaly
Detection </font></strong></span></h3>
<p>那接下来,就是我们在作业里面要使用的技术,在作业里面我们会拿
Aauto-Encoder,来做 Anomaly 的
Detection,那我在规划作业的时候,其实就是想要 Aauto-Encoder 出一个作业,那
Aauto-Encoder 的技术很多,那最后我决定做 Anomaly 的
Detection，因为这个是你在非常多的场合,都有机会应用到的一个技术。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615194339007.png" alt="image-20220615194339007" style="zoom:67%;"></p>
<p>Anomaly 的 Detection ,假设你有一堆的训练资料,这边用 X1 到 XN
来表示我们的训练资料,而 Anomaly
Detection,它的中文通常翻译成异常检测。</p>
<p><strong><font color="red">
异常检测要做的事情就是,来了一笔新的资料,它到底跟我们之前在训练资料里面看过的资料,相不相似呢？</font></strong>也就是说你需要找出,你需要有一个异常检测的系统,这个异常检测的系统,是透过大量你已经看过的资料训练出来的。</p>
<ul>
<li>给它一笔新的资料,如果这笔新的资料,看起来像是训练资料里面的
Data,就说它是正常的</li>
<li>如果看起来不像是训练资料里面的 Data,就说它是异常的</li>
</ul>
<p>那其实 Anomaly,Anomaly
这个词啊,有很多不同的其他的称呼,比如说有时候你会叫它
<strong>Outlier</strong>,有时候你会叫它 Novelty,有时候你会叫它
Exceptions,但其实指的都是同样的事情,你就是要看某一笔新的资料,它跟之前看过的资料到底相不相似,但是所谓的<strong>相似这件事啊,其实并没有非常明确的定义</strong>,它是见仁见智的,会根据你的应用情境而有所不同。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615194546961.png" alt="image-20220615194546961" style="zoom:67%;"></p>
<p>举例来说</p>
<ul>
<li>假设现在你的训练资料这个都是雷丘,那这个皮卡丘就算是异常的东西</li>
<li>但是假设你的训练资料里面,你所有的动物都是皮卡丘,那雷丘就是异常的东西,所以我们并不会说,某一个东西它一定就是
Normal,一定就是
Anomaly,我们不会说某个东西它一定是正常或异常,它<strong>是正常或异常,取决于你的训练资料长什么样子</strong></li>
<li>或者是说假设你的训练资料里面,通通都是宝可梦,那雷丘跟皮卡丘通通都算是正常的,而可能数码宝贝,亚古兽知道吗,这应该是亚古兽
对不对,亚古兽算是异常的</li>
</ul>
<h4><span id="那个这个异常检测有什么样的应用呢">那个这个异常检测有什么样的应用呢？</span></h4>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615194611806.png" alt="image-20220615194611806" style="zoom:67%;"></p>
<ul>
<li>举例来说,它可以来做<strong>诈欺侦测</strong>,假设你的训练资料里面,有一大堆信用卡的交易纪录,那我们可以想像说,多数信用卡的交易都是正常的,那你拿这些正常的信用卡训练的交易纪录,来训练一个异常检测的模型,那有一笔新的交易纪录进来,你就可以让机器帮你判断说,这笔纪录算是正常的
还是异常的,所以这种异常检测的技术,可以拿来做诈欺侦测。</li>
<li>或者是它可以拿来做网路的这个<strong>侵入侦测</strong>,举例来说,你有很多连线的纪录资料,那你相信多数人连到你的网站的时候,他的行为都是正常的,多数人都是好人,你收集到一大堆正常的连线的纪录,那接下来有一笔新的连线进来,你可以根据过去正常的连线,训练出一个异常检测的模型,看看新的连线,它是正常的连线
还是异常的连线,它是有攻击性的
还是正常的连线,或者是它在医学上也可能有应用,你收集到一大堆正常细胞的资料,拿来训练一个异常检测的模型,那也许看到一个新的细胞,它可以知道这个细胞有没有突变,也许有突变,它就是一个癌细胞等等。</li>
</ul>
<p>那讲到这边有人可能会想说,Anomaly Detection
异常检测的问题,我们能不能够把它当做<strong>二元分类</strong>的问题来看啊？</p>
<figure>
<img src="../../../../../Library/Application%20Support/typora-user-images/image-20220615194724455.png" alt="image-20220615194724455">
<figcaption aria-hidden="true">image-20220615194724455</figcaption>
</figure>
<p>你说你要做诈欺侦测,你就收集一大堆正常的信用卡纪录,一堆诈欺的信用卡纪录,训练一个
Binary 的
Classifier,就结束啦,就这样子不是吗？比较<strong>难点就是你要收资料</strong>。</p>
<p>这种异常检测的问题它的难点,正在就在收资料上面,通常你<strong>比较有办法收集到正常的资料,你比较不容易收集到异常的资料</strong>,你可能有一大堆信用卡交易的纪录,但是多数信用卡交易的纪录可能都是正常的,异常的资料相较于正常的资料,可能非常地少,甚至有一些异常的资料混在正常的里面,你也不太可,你可能也完全没有办法侦测出来,所以在这一种异常检测的问题里面。</p>
<p><strong><font color="red">
我们往往假设,我们有一大堆正常的资料,但我们几乎没有异常的资料,所以它不是一个一般的分类的问题,这种分类的问题又叫做
==One Class
的分类问题==。</font></strong>就是我们只有一个类别的资料,那你怎么训练一个模型,因为你想你要训练一个分类器,你得有两个类别的资料,你才能训练分类器啊,如果只有一个类别的资料,那我们可以训练什么东西,这个时候就是
Aauto-Encoder,可以派得上用场的时候了。</p>
<p>举例来说,假设我们现在想要做一个系统,这个系统是要侦测说一张图片：</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615194856711.png" alt="image-20220615194856711" style="zoom:67%;"></p>
<p>举例来说,它是不是真人的人脸,那你可以找到一大堆图片,它都是真正的人脸,那我们就拿这些真人的人脸,来训练一个
Aauto-Encoder。这个是你老婆的照片,那你可以拿它来训练一个
Aauto-Encoder,那你训练完这个 Aauto-Encoder
以后,在测试的时候,如果进来的也是你老婆的照片,那因为在训练的时候有看过这样的照片,所以它可以顺利地被还原回来。</p>
<p>你可以计算这一张照片通过 Encoder,再通过 Decoder
以后,它的变化有多大,你可以去<strong>计算这个输入的照片,跟这个输出的照片,它们的差异有多大</strong>,如果差异很小,你的
Decoder
可以顺利地还原原来的照片,代表这样类型的照片,是在训练的时候有看过的,不过反过来说,假设有一张照片是训练的时候没有看过的。</p>
<p><img src="../../../../../Library/Application Support/typora-user-images/image-20220615195012966.png" alt="image-20220615195012966" style="zoom:67%;"></p>
<p>她是那个凉宫春日,但是她不是真人,她是一个动画的人物,她是二次元的人物,一个二次元人物的照片,输入
Encoder 再输出 Decoder
以后,因为这是没有看过的东西,这是训练的时候没有看过的照片,那你的
Decoder,就很难把它还原回来,<strong>如果你计算输入跟输出的差异,发现差异非常地大</strong>,那就代表说,现在输入给
Encoder
的这张照片,可能是一个异常的状况,可能是训练的时候没有看过的状况,所以你就可以<strong>看
reconstruction 的 loss</strong>,这个 reconstruction
的好坏,来决定说你现在在测试的时候,看到这张照片,是不是训练的时候有看过同类型的照片。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/1114KVN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/1114KVN/" class="post-title-link" itemprop="url">高级威胁发现（1）【安全场景】基于溯源图的入侵检测</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-13 14:35:37" itemprop="dateCreated datePublished" datetime="2022-05-13T14:35:37+08:00">2022-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:54:42" itemprop="dateModified" datetime="2023-04-19T15:54:42+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url" rel="index"><span itemprop="name">应用场景</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="基于溯源图的入侵检测">基于溯源图的入侵检测</span></h2>
<blockquote>
<ul>
<li>浙大：https://www.zhihu.com/people/li-zhen-yuan-20/posts</li>
<li>武大：</li>
<li>中科院：</li>
</ul>
</blockquote>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191553343.png" alt="image-20230320161317805">
<figcaption aria-hidden="true">image-20230320161317805</figcaption>
</figure>
<p>从早期的对恶意程序的动静态分析，到现在业界比较热门的对攻击链的检测，这个议题已经历很多很多。但很多现有的研究因为开销和误报问题并没有被真正的用于生产环境。而现有的安全产品大多基于静态分析和简单的动态分析，并不能很好的为攻击建模，已经越来越难适应复杂多变的攻击形式和攻击场景；</p>
<blockquote>
<p><strong>2019 CCS 议题 Cyber Threat
共有四篇文章</strong>，列举如下：</p>
<ol type="1">
<li><strong>Log2vec: A Heterogeneous Graph Embedding Based Approach for
Detecting Cyber Threats within Enterprise</strong>, Fucheng Liu, Yu Wen,
Dongxue Zhang, Xihe Jiang (Chinese Academy of Science),Xinyu Xing (The
Pennsylvania State University),Dan Meng (Chinese Academy of
Science)</li>
<li><strong>POIROT: Aligning Attack Behavior with Kernel Audit Records
for Cyber Threat Hunting</strong>, Sadegh M. Milajerdi (UIC),Birhanu
Eshete (University of Michigan-Dearborn),Rigel Gjomemo (UIC),V.N.
Venkatakrishnan (UIC)</li>
<li><strong>Effective and Light-Weight Deobfuscation and Semantic-Aware
Attack Detection for PowerShell Scripts</strong>, Zhenyuan LI (Zhejiang
University),Qi Alfred Chen (University of California, Irvine),Chunlin
Xiong (Zhejiang University),Yan Chen (Northwestern University),Tiantian
Zhu (Zhejiang University of Technology),Hai Yang (MagicShield Inc)</li>
<li><strong>MalMax: Multi-Aspect Execution for Automated Dynamic Web
Server Malware Analysis</strong>, Abbas Naderi-Afooshteh (University of
Virginia),Yonghwi Kwon (University of Virginia),Jack Davidson
(University of Virginia),Anh Nguyen-Tuong (University of Virginia),Ali
Razmjoo-Qalaei,Mohammad-Reza Zamiri-Gourabi (ZDResearch)</li>
</ol>
</blockquote>
<p>其中，前两篇都用图表示攻击流程，然后分别采用机器学习的方法和图匹配的类规则方法进行检测。而后两篇则将关注点放在脚本类的恶意程序上。前者（也就是我们的工作）用主要是静态分析的方法解决混淆问题，而后者则用动态方法分析了恶意程序变体的问题。下面我们分两组讨论这四篇文章。</p>
<h3><span id="前言">前言：</span></h3>
<h4><span id="网络空间威胁检测面临的一些研究问题">网络空间威胁检测面临的一些研究问题？</span></h4>
<ul>
<li><strong>缓慢又隐蔽的高级持续性威胁的检测难题</strong>：高级持续性威胁（Advanced
Persistent
Threat）往往采用隐蔽的攻击形式，在很长的一段时间内缓慢的渗透入目标系统并长期潜伏以达到攻击目的。因为其缓慢又隐蔽的特性，传统的防御手段往往很难对其实施有效的监控。正所谓“我设置阈值过高，就会错过攻击；我设置阈值过低，就没空管理系统（误报太多）”。</li>
<li><strong>用什么数据什么结构准确度表示一个威胁行为的问题</strong>：用什么方式表示一个威胁或攻击行为一直以来被研究者关注。不同的表示方式都有其优点与缺点，很难给出一个绝对的判断，应该根据不同场景做不同选择。举例来说，<strong>现在常用的威胁情报（IoC）使用非常简单的数据，包括恶意的IP、恶意文件的Hash，几乎没有任何鲁棒性可言</strong>，但却是现实中常用的安全工具，有效的保护了许多系统的安全。其他常见的方式还包括，系统调用的序列、API调用树、代码动态执行图等。一般而言，简单的结构意味着更高的效率，但表达能力更差，误报的概率更高。而复杂的结构，表达能力更好的同时检测效率却受到影响。</li>
<li><strong>如何设计检测算法权衡威胁检测的响应速度与检测精度矛盾</strong>：威胁检测的系统的响应速度很大程度的影响了该系统的应用场景和价值。响应速度越快，就能越早的定位并阻止进一步的攻击发生，从而尽可能的减小损失。但是鱼与熊掌往往不可得兼，效率高、响应速度快的速度在检测能力上往往不如响应速度慢、收集数据更加全面的系统。现有的系统都尝试在响应速度和检测精度之间找到一个行之有效的平衡点。</li>
<li><strong>如何设计存储系统以权衡存储空间与查询效率之间的矛盾</strong>：如前面所说，高级持续性威胁往往是“low
and
slow”的，攻击的周期可能长达几十天。此外，为了保护系统安全，日志系统往往需要保存很长一段时间内的日志以便事后的取证（Digital
Forensic）分析。因此系统有很强的存储的日志的需求。对一个大公司来说，这可能以为着PB级的存储以及百万美元的开销。因此<strong>日志存储系统的设计和针对性的数据压缩算法</strong>也是必不可少的。</li>
</ul>
<h4><span id="1-溯源图">1、溯源图</span></h4>
<p>溯源图（Provenance
Graph）描述计算机中的事件并在图中进行威胁检测是最近几年学术界和工业界都很关注的一个课题。使用图的形式，相比于之前常用的序列有更加好的表达能力。但是图上计算的复杂性，也给研究人员带来了许多的挑战，很多研究组在近几年带来了许多的研究成果（我可能会在后面展开讲讲这方面工作，也是一个很有意思的题目）。<strong>值得一提的是本议题第二篇文章
POIROT（大侦探波罗）的“侦探”三部曲（SLEUTH，HOLMES，POIROT）都发表在四大会上，有兴趣的同学可以在<a href="http://link.zhihu.com/?target=https%3A//www.researchgate.net/profile/Sadegh_Milajerdi%3FenrichId%3Drgreq-edb099d62869d1044744443018cd8dac-XXX%26enrichSource%3DY292ZXJQYWdlOzMzNjA1NzMyNztBUzo4MDcyNjA4MTMwMjUyODJAMTU2OTQ3NzM4NDE2Ng%3D%3D%26el%3D1_x_5%26_esc%3DpublicationCoverPdf">这里</a>找到更多。</strong></p>
<p><strong><font color="red">
溯源图是由计算机中的实体为节点（进程、文件、网络套接字）、将实体间的操作（进程文件、开启新的进程）视为节点之间的边，这样就构成了一个有向信息图。</font></strong>溯源图可以用来表示系统中的各种行为，包括各种攻击行为。</p>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191553381.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191553747.jpg" alt="img" style="zoom:50%;"></p>
<h4><span id="2-如何在溯源图中高效的定位威胁呢">2、如何在溯源图中高效的定位威胁呢？</span></h4>
<h5><span id="poirot-签名匹配">POIROT 签名匹配：</span></h5>
<p>在 POIROT 中，作者们创新的提出了另一种和溯源图类似的图 --
查询图。<strong>他们先人工的分析 APT
攻击白皮书，入侵报告等威胁情报并手工提取出其中涉及的实体和实体间的操作，构成查询图（Gq）</strong>。然后给出了一个专门设计的图匹配算法，从而实现了个高效的检测。这其实是一种类似<strong>签名匹配的检测算法</strong>，因此优点在于较高的效率和低的误报率。但是缺点也很明显，这种方法无法检测未知的攻击，对变体的抵抗能力也比较弱。而且提取特征的过程全是手工完成的，人力成本较高。</p>
<h5><span id="log2vec-异常检测">==Log2vec 异常检测：==</span></h5>
<p>首先值得一提的是，这也是一片国内的文章，出自中科院信工所。他们将最近在机器学习领域很火的
Graph Embedding
方法迁移到了“溯源图”上（这里需要说明，他们说使用的图结构在溯源图的基础上加上了很多额外的联系，因此联系更紧密）。他们的主要贡献在于证明了
Graph Embedding
在可以用于加强版的溯源图，使得生成的向量有很好的表达能力，可以用于攻击的检测。</p>
<h4><span id="3-溯源图在检测上的优势待补充">3、溯源图在检测上的优势？【待补充】</span></h4>
<p>利用这些边和节点，溯源图可以表示出系统对象之间的数据流与控制流关系，从而<strong>将存在因果联系（Causality）的节点连接起来，无论两个节点之间相隔多少的其他节点，或者发生时间相差多少</strong>。以RQ1中的高级持续性威胁为例，无论攻击如何隐蔽与缓慢，我们都可以在溯源图中找到对应的节点与因果联系，从而对其进行有效的检测。</p>
<p>溯源图包含着丰富的系统行为语义，也有很强的<strong>关联分析能力</strong>，因此在检测未知威胁和告警关联、<strong>误报过滤方面</strong>有着很强能力、很好的效果。</p>
<h4><span id="4-基于溯源图做入侵检测-关联分析和告警消减中的常见问题和可能的风险">4、基于溯源图做入侵检测、关联分析和告警消减中的常见问题和可能的风险</span></h4>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191553024.png" alt="基于溯源图做入侵检测、关联分析和告警消减中的常见问题和可能的风险">
<figcaption aria-hidden="true">基于溯源图做入侵检测、关联分析和告警消减中的常见问题和可能的风险</figcaption>
</figure>
<blockquote>
<p><strong>基于溯源图的入侵检测和告警关联分析方案已经越来越多的被各大安全厂商采纳作为新的检测引擎核心</strong>。溯源图包含着丰富的系统行为语义，也有很强的关联分析能力，因此在检测未知威胁和告警关联、误报过滤方面有着很强能力、很好的效果。然而基于系统溯源图的检测系统本身也会引入新的问题，一些错误的使用可能会导致新的风险。本文整理归纳了利用系统溯源图做威胁检测过程中可能遇到的一些常见问题，和潜在的攻击方式，希望引起大家重视。</p>
</blockquote>
<h4><span id="41用溯源图进行检测过程中遇到的问题">4.1
用溯源图进行检测过程中遇到的问题</span></h4>
<p><strong><font color="red">
利用溯源图进行检测的最大问题，或者说挑战，就是性能问题。主要表现在两个方面：</font></strong></p>
<ul>
<li><p>数据量过大带来的<strong>数据收集开销</strong>：为了构建完整的系统溯源图，检测系统需要收集大量的数据，一般来说单台主机一天收集的数据量会在GB这一数量级。因此存储和处理数据会带来很大的开销。</p></li>
<li><p>图结构处理带来的<strong>计算开销</strong>：因为溯源图原始的图结构，完整的处理其信息会引入大量的开销。</p></li>
</ul>
<h4><span id="42带有风险的缓解措施和针对性的绕过手段">4.2
带有风险的缓解措施和针对性的绕过手段</span></h4>
<p>对于安全系统，尤其是面向业界的安全系统而言，性能就是生命，直接决定了乙方会不会接受安全产品。所以，从业者采用了各种方式来缓解性能压力，这些方法从原理上来说可以分为两大类：<strong>“剪枝”</strong>与<strong>“衰减”</strong>。</p>
<p><strong>“剪枝”就是将被认为无关的攻击路径整条排除</strong>，不予考虑；<strong>“衰减”则是认为局部的可疑行为只会与临近的行为关联</strong>，所以行为的影响力会随着图中距离的变远而逐步减小。（具体的实现比较复杂，不再赘述。）实际情况中，这两种方法往往可以一起使用使性能最优。</p>
<p>然而，需要注意的是这两种方案都有可能导致攻击漏报，而攻击者也完全可以利用这两个特性来针对性的构造攻击。事实上，了解原理后，有些攻击的构造会相当的容易。接下来我会由简单到复杂介绍几个具体的缓解方法和对应的攻击构造思路：</p>
<ul>
<li>利用包括<strong>数字签名</strong>在内的<strong>简单白名单策略</strong>进行<strong>剪枝</strong>：<strong>利用白名单进行初步的数据过滤是一种很直接也很有效的方法，但是过于简单的白名单策略可能导致攻击者很容易的绕过</strong>。以数字签名为例，绕过数字签名的方式有很多：包括签名伪造、DLL
Side loading以及最近很火的供应链攻击方案。</li>
<li>基于<strong>局部异常行为</strong>的<strong>剪枝</strong>：攻击行为往往会导致异常的系统行为（溯源图中的边），比如不应该出现的进程对文件访问等。部分工作针对这一特性认为“常见的系统行为就是相对安全的，因此可以忽略”。针对这一类的缓解方案，攻击者可以采用Live-off-the-Land的攻击思路，即尽可能的采用系统中原有的数据访问路径。<strong><font color="red">
比如说经典的Gitpwn攻击，利用Git的代码提交流程完成源代码的窃取和上传。可以避免异常的文件访问和网络传输流程，从而完成攻击。</font></strong></li>
<li><strong>衰减</strong>：利用衰减的思路，<strong>安全分析人员通过控制检测点的传播轮数（保留时间）</strong>，可以有效控制每次需要处理的图的规模，从而大幅度的降低的算法的复杂度。然而攻击者可以通过加长攻击链（增加攻击间隔）来避免被检测。需要注意的是加长攻击需要使得溯源图中节点的距离变大，如下图所示，常规的有核心控制节点的攻击图并不能真正拉长攻击链。这里可以使用的攻击技术报告DLL
side
loading、注册表自启动等等。值得一提的是，基于衰减的压缩方案往往和剪枝的方案共同使用，也意味着双倍的风险。</li>
</ul>
<p>上面几点仅仅是抛砖引玉，除此之外，其他的安全风险还包括：<strong>1）不完整的因果关系数据；2）受限的攻击案例分析等。</strong>可以看到，引入溯源图在解决部分问题的同时也引入了新的安全问题，构建真正安全系统的路还很长。希望大家也可以提出自己的看法，多多交流。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/368N99B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/368N99B/" class="post-title-link" itemprop="url">安全场景（2）恶意加密流量检测*</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-13 12:49:05" itemprop="dateCreated datePublished" datetime="2022-05-13T12:49:05+08:00">2022-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-09-19 00:12:59" itemprop="dateModified" datetime="2022-09-19T00:12:59+08:00">2022-09-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url" rel="index"><span itemprop="name">应用场景</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="基于机器学习的恶意加密流量检测">基于机器学习的恶意加密流量检测</span></h2>
<p>[1] Anderson B, McGrew D. Identifying encrypted malware traffic with
contextual flow data[C]//Proceedings of the 2016 ACM workshop on
artificial intelligence and security. 2016: 35-46.</p>
<figure>
<img src="image-20220516100235456.png" alt="image-20220516100235456">
<figcaption aria-hidden="true">image-20220516100235456</figcaption>
</figure>
<h4><span id="在进行tls握手时会进行如下几个步骤">在进行TLS握手时，会进行如下几个步骤：</span></h4>
<ol type="1">
<li><strong>Client Hello</strong>，客户端提供支持的加密套件数组（cipher
suites）；</li>
<li><strong>Server
Hello</strong>，由服务器端选择一个加密套件，传回服务器端公钥，并进行认证和签名授权（<strong>Certificate</strong>
+ Signature）；</li>
<li>客户端传回客户端公钥（<strong>Client Key
Exchange</strong>），客户端确立连接；</li>
<li>服务器端确立连接，开始 HTTP 通信。</li>
</ol>
<p><img src="https://pic4.zhimg.com/80/v2-a10c338f4c3e283b3b29d0e5752f1beb_1440w.jpg" alt="img" style="zoom:50%;"></p>
<h3><span id="一-特征提取">一、特征提取</span></h3>
<h4><span id="11-可观察的数据元统计特征">1.1 可观察的数据元统计特征</span></h4>
<ul>
<li><strong>传统流数据</strong> (Flow Meta)
<ul>
<li>流入和流出的字节数和数据包数</li>
<li>源端口和目的端口</li>
</ul></li>
<li><strong>字节分布</strong> (BD, Byte Distribution)
<ul>
<li>数据包有效负载中遇到的每个字节值的计数</li>
<li>提供了大量<strong>数据编码</strong>和<strong>数据填充</strong>的信息</li>
<li>字节分布概率 ≈ 字节分布计数 / 分组有效载荷的总字节数</li>
<li>特征表示：1×256维字节分布概率序列</li>
</ul></li>
<li><strong>分组长度和分组到达间隔时间的序列 </strong>(SPLT, Sequence of
Packets Length and Times)
<ul>
<li><strong>==使用马尔可夫链模型建模==</strong></li>
</ul></li>
</ul>
<h4><span id="12-未加密的tls头部信息特征">1.2 未加密的TLS头部信息特征</span></h4>
<p><img src="../../../../../../Library/Application Support/typora-user-images/image-20220516101251514.png" alt="image-20220516101251514" style="zoom: 33%;"></p>
<blockquote>
<p><strong>TLS/SSL协议 过程</strong></p>
<ul>
<li>两层子协议：握手协议和记录协议</li>
<li>握手协议特点
<ul>
<li>加密明文但不加密握手过程</li>
<li>有多个版本但握手参数不变</li>
</ul></li>
</ul>
</blockquote>
<ul>
<li><strong>Client Hello</strong>
<ul>
<li>列出的密码套件列表(Cipher Suites)
<ul>
<li>密钥交换算法、加密算法</li>
<li>报文认证消息码(MAC)算法</li>
</ul></li>
<li>支持的扩展列表(Extensions)
<ul>
<li>提供额外功能或设定</li>
</ul></li>
</ul></li>
<li><strong>Server Hello</strong>：选定的密码套件和TLS扩展</li>
<li><strong>Certificate</strong>：服务器签发的证书信息</li>
<li><strong>Client Key Exchange</strong>：使用的密钥交换算法参数</li>
</ul>
<figure>
<img src="../../../../../../Library/Application%20Support/typora-user-images/image-20220516101639662.png" alt="image-20220516101639662">
<figcaption aria-hidden="true">image-20220516101639662</figcaption>
</figure>
<h4><span id="13-上下文数据">1.3 上下文数据</span></h4>
<ul>
<li><strong>DNS上下文流</strong>
<ul>
<li>基于目标IP地址与TLS相关的DNS响应
<ul>
<li>域名长度</li>
<li>DNS响应返回的IP地址数</li>
<li>DNS TTL值</li>
<li>域名在Alexa榜的排名</li>
</ul></li>
<li>补充了加密流中可能缺失的信息</li>
</ul></li>
<li><strong>HTTP上下文流</strong>
<ul>
<li>在TLS流5min窗口内的<strong>相同源IP地址的所有HTTP流</strong></li>
<li>恶意软件可能<strong>利用HTTP的头部字段</strong>来发起恶意活动
<ul>
<li>Content-Type、Server、Code</li>
</ul></li>
</ul></li>
</ul>
<h3><span id="二-工业落地">二、工业落地</span></h3>
<p>然而，AI技术如没有得到有效运用，也无法在实战中检测到加密的威胁行为。例如无监督学习可以定位未知威胁，但精准度待提升；有监督学习精确度高，却无法覆盖未知威胁。</p>
<h4><span id="21如何在实战中精准识别加密流量攻击">2.1
<strong>如何在实战中精准识别加密流量攻击？</strong></span></h4>
<p><strong>深信服安全团队经过7000+用户实践发现，只有将无监督学习和有监督学习智能化结合，才能最大限度提升加密流量攻击的识别率。</strong></p>
<figure>
<img src="https://mmbiz.qpic.cn/mmbiz_png/EJiaEo3Lq9kqe1fjo1Clib3ZyjiaxESYbUib3sYpbgKND3aB0b2gRURRDxECcT3mmFicMQdhdOaPDn2QVjyZ2rV8VrQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<h4><span id="22有监督学习精准识别已知加密流量">2.2
<strong>有监督学习精准识别已知加密流量</strong></span></h4>
<p>有监督机器学习通过将已知、带标签的行为数据输入系统，学习分析数据行为，并根据数据标签来检测、识别特定的高级威胁。深信服NDR（全流量高级威胁检测系统）应用AI模型，基于有监督机器学习抓取所有上下行流量，<strong>提取1000+维度特征</strong>，同时增加了模型训练算法LightGBM学习特征的权重，对已知高级威胁的检测更为精准。传统的检测方式基于一个模型检测多个场景，不同场景的特征不尽相同，因此误报率很高。<strong><font color="red">
深信服NDR基于AI模型有监督学习进行场景化建模，一个模型对应一个场景，根据场景特征进行针对性检测</font></strong>，<strong>模型检测精准率能够达到98%</strong>。</p>
<h4><span id="23无监督学习提前发现未知加密流量">2.3
<strong>无监督学习提前发现未知加密流量</strong></span></h4>
<p>无监督的机器学习覆盖了聚类、神经网络等方法，不依赖任何标签值，通过自主学习，挖掘数据内在特征，实现自动化全面检测，更合理地利用资源，提升效率。</p>
<p>深信服NDR基于AI模型无监督学习方法，通过聚类学习、特征映射等智能分析技术建立设备加密流量动态行为基线，筛选出异常的、可疑的行为，同时结合行为聚合与关联分析，<strong>检测出未知威胁的早期迹象，最大程度地实现自动化检测</strong>，可以快速检测出如下异常，帮助网络安全团队主动预防威胁：</p>
<ul>
<li>异常的网络设备JA3</li>
<li>异常的访问时间和访问频率</li>
<li>异常的上下行数据包比率</li>
<li>异常的证书签发机构</li>
</ul>
<p><strong>以常见的“服务器权限获取手法webshell加密通信”为例</strong>，攻击者通过渗透系统或网络安装webshell
，在应用服务器上执行敏感命令、窃取数据、植入病毒，危害极大。‍webshell具有很强的隐蔽性，<strong>传统的、基于单向数据流的流量检测方案，无法实时更新数据，难以有效检测webshell</strong>。</p>
<p>深信服NDR基于AI模型无监督学习的<strong><font color="red">
孤立森林异常点</font></strong>检测算法，可以构建特征向量，精准检测“孤立离群”的webshell访问行为，<strong>具有更高检出率，更低误报率</strong>。除了webshell加密通信场景外，深信服NDR同样支持隧道检测、CS漏洞、加密挖矿、加密反弹shell等威胁检测，覆盖多种加密威胁场景。</p>
<h2><span id="三-算法比赛总结">三、算法比赛总结</span></h2>
<blockquote>
<p><a href="../算法比赛/恶意加密流量（1）DataCon2020-恶意加密流量检测.md">恶意加密流量（1）DataCon2020-恶意加密流量检测.md</a></p>
<p><a href="../算法比赛/恶意加密流量（2）Datacon2021恶意加密流量检测.md">恶意加密流量（2）Datacon2021恶意加密流量检测.md</a></p>
<p><a href="../算法比赛/恶意加密流量（3）西湖论剑AI大数据安全分析赛.md">恶意加密流量（3）西湖论剑AI大数据安全分析赛.md</a></p>
<p>#### 流量处理的工具</p>
<p>#### <strong>zeek</strong>:https://github.com/zeek/zeek</p>
<p><a target="_blank" rel="noopener" href="https://darkdefender.medium.com/https-medium-com-melanijan93-analysing-pcaps-with-bro-zeek-33340e710012">使用
Bro/Zeek 分析 PCAP</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freebuf.com/sectool/235587.html">流量分析的瑞士军刀：Zeek</a></p>
<p>Zeek Analysis Tools (ZAT):</p>
<p>#### joy：</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/ahlashkari/CICFlowMeter">CICFlowMeter</a>：</p>
</blockquote>
<h3><span id="21-数据包级">2.1 数据包级</span></h3>
<h4><span id="1长度分布">（1）长度分布</span></h4>
<p>根据Cisco的研究【17】，<strong>恶意软件和普通软件在正向流和反向流中的数据包长度分布不同</strong>。<strong><font color="red">
例如，当我们使用谷歌搜索时，客户端向服务器发送少量数据包，然后服务器返回大量数据包。然而，恶意软件的作用恰恰相反：恶意软件通常让客户端将数据传输到服务器，然后服务器定期返回调度命令。</font></strong>无论是否加密，数据包长度始终可见，因此它适合作为一种功能。我们将数据包长度和方向编码为一维独立特征。我们推测，感染恶意软件的客户端和服务器之间的一些控制消息的长度总是相似且频繁的，这具有很好的区分程度。<strong>我们考虑每个可能的数据包长度和方向元组。由于Internet上的最大传输单元（MTU）是1500字节，并且数据包的方向有两个发送或接收方向，因此我们的长度分布特征是3000维。</strong>为了提取这些特征，我们计算具有不同长度的所有数据包的数量，并进行规范化以确保概率分布。我们使用随机森林（RF）算法来处理这些特征。因为它能更好地处理高维特征，并且具有可解释性。</p>
<h4><span id="2长度序列">（2）长度序列</span></h4>
<p>第二部分，在不使用序列信息的情况下，我们只使用了数据包长度的统计特征，这可能会在时间上丢失一些信息，因此我们提取了数据包长度序列。<strong>我们在每个客户端的双向上取前1000个数据包长度</strong>，并将其放入TextCNN算法中以提取局部序列关系。因为该算法运行速度快，精度高。文本数据的卷积神经网络TextCNN【22】是一种用于句子分类任务的有用的深度学习算法。<strong>在这种情况下，我们将每个数据包的长度视为一个单词，长度序列相当于一个句子</strong>。</p>
<h4><span id="3服务器ip">（3）服务器IP</span></h4>
<p>在我们的数据集中，服务器IP地址是一个重要的标识符。<strong>我们假设，在同一地区，如果客户端感染了相同的恶意软件，则可能会导致其访问相同的服务器IP地址</strong>。因此，我们还考虑了对服务器IP地址的访问。<strong>值1或0表示是否访问了特定的服务器IP地址（一个热编码）</strong>。我们使用朴素贝叶斯（NB）算法来处理这些特征。由于朴素贝叶斯算法是一种非参数算法，其本质是寻找特征和标签之间的关系。因此，它可以被视为一个黑名单。</p>
<h4><span id="4词频分类器">（4）词频分类器</span></h4>
<p><strong>X509证书在Internet上广泛使用</strong>。它们用于验证实体之间的信任。证书颁发机构通常将X509证书链接在一起。如图2所示。[23]，<strong>X509证书提供URL、组织、签名等信息</strong>。我们从培训集中每个客户端的TLS流中提取X509证书链，并获取证书中<strong>主题</strong>和<strong>颁发者</strong>中包含的单词。我们将所有单词组合在一起，并将客户的流量视为由这些单词组成的句子。与B部分类似，我们计算每个单词的数量并将其用作特征。0我们使用朴素贝叶斯（NB）算法来处理这些特征。如果测试集样本证书中的所有单词从未出现在训练集中，我们将直接推断它是恶意的。因为训练集包含最流行的域名。</p>
<p><img src="image-20220621131035005.png" alt="image-20220621131035005" style="zoom: 67%;"></p>
<h4><span id="5tcp状态马尔可夫">==（5）TCP状态马尔可夫==</span></h4>
<p>我们发现<strong>恶意流量和正常流量之间TCP连接状态的分布是不同的</strong>。表一说明了可能的TCP连接状态[24]。我们按照流出现的时间对其进行排序，然后使用马尔可夫随机场转移矩阵（MRFTM）对该特征进行编码。MRFTM在建模连接状态序列时很有用。MRFTM[i，j]中的每个条目统计第i个和第j个状态之间的转换次数。最后，我们对MRFTM的行进行规范化，以确保适当的马尔可夫链。然后我们将其重塑为一维向量，也就是说，我们使用MRFTM的条目作为特征。我们使用随机森林（RF）算法来处理这些特征。</p>
<h3><span id="22-会话流级">2.2 会话流级</span></h3>
<h4><span id="6会话流量统计">（6）会话流量统计</span></h4>
<p>在加密流量中，上述5种分类器在主机级使用不同的特征提取方法和分类方法。此外，为了进一步提高准确率，防止恶意软件由于缺乏领域知识而欺骗分类器，我们还提取了TLS握手中的明文信息。在这个分类器中，我们首先考虑流级特征。我们仅选择TLS流，并分析每个流。一旦推断流是恶意的，就会推断相应的客户端被感染。我们对TCP和TLS协议进行了深入分析，<strong>提取了1000多个维度的流级特征</strong>，包括以下部分：</p>
<ul>
<li><strong>TCP连接状态特性</strong>：如F部分所述，我们对每个流的TCP连接状态进行一次热编码。</li>
<li><strong>统计特征</strong>：我们还提取常规统计特征，表II显示了相关特征名称和描述。</li>
</ul>
<p><img src="../../../../../../Library/Application Support/typora-user-images/image-20220621141516374.png" alt="image-20220621141516374" style="zoom: 33%;"></p>
<ul>
<li><strong>长度马尔可夫特征</strong>：数据包长度序列的操作类似于F部分中的TCP连接状态序列。长度值被离散为大小相等的容器。长度数据马尔可夫链有10个箱子，每个箱子150字节。假设一个1500字节的MTU，任何观察到的大小大于1350字节的数据包都被放入同一个bin中。</li>
<li><strong>TLS握手功能</strong>：我们发现客户端和服务器的TLS协议版本在恶意和良性TLS流之间有不同的分布，因此我们对客户端和服务器的TLS版本进行了一次热编码。此外，由于恶意软件可能使用旧的密码套件，我们在客户端和服务器上都对密码套件和扩展进行n-hot编码，即将所有密码套件和扩展扩展扩展为一维0向量，如果当前流使用某个密码套件或扩展，则相应的位置集值为1。</li>
<li><strong>TLS证书特性</strong>：我们发现，在恶意流中，很大一部分叶证书是自签名的，或者自签名证书出现在证书链中。恶意软件喜欢利用的自签名证书的成本很低。因此，我们分析从服务器发送的证书：<strong>证书链是否包含自签名证书、叶证书是否过期、证书版本、证书有效期、公钥长度、是否发生警报</strong>。同时，考虑到之前的词频分类器，我们发现一些词无法区分恶意和良性，因此我们还将流词频添加到流特征中。</li>
</ul>
<h3><span id="23-主机级特征">2.3 主机级特征</span></h3>
<h4><span id="7主机级荷载无关特征聚合流级统计信息">（7）<strong>主机级荷载无关特征聚合</strong>
(流级统计信息)</span></h4>
<p><strong>单独的看每条流可能漏掉了流之间的关联行为即主机级别的行为</strong>，比如恶意软件在发出正常的访问谷歌流量后可能就要开始进行恶意传输。再比如，有少量正常流也会出现自
签名，如果我们单独看流，可能就会误判，但是如果我们基于主机提取特征发现同一
IP
下有多条流都是自签名，则我们就会有很大的信心认为这是恶意的。因此，我们将上一小节中流级别
的特征进行聚合，并以流为基本单位提取主机级别特征。</p>
<p><strong>主机级特征聚合部分主要考虑了如下的特征:</strong></p>
<ul>
<li><strong>总包个数</strong>，<strong>每条流的平均包个数</strong>，<strong>时间间隔、包长的均值</strong>，以及上一个小节中证书部分的相关特
征，即<strong>自签名流数量，过期流数量，有效期过长（比如
100年）的流数量及其均值。</strong></li>
<li>TLS 半连接 和无连接</li>
</ul>
<h3><span id="24-上下文信息特征">2.4 上下文信息特征</span></h3>
<h4><span id="8其他应用协议">（8）其他应用协议</span></h4>
<p><strong><font color="red">HTTP头部信息</font></strong></p>
<ul>
<li><strong>Content-Type</strong>，正常流量 HTTP 头部信息汇总值多为
<code>image/*</code>，而恶意流量为
<code>text/*、text/html、charset=UTF-8</code> 或者
<code>text/html;charset=UTF-8</code>。</li>
<li><strong>User-Agent</strong></li>
<li><strong>Accept-Language</strong></li>
<li><strong>Server</strong></li>
<li><strong>HTTP响应码</strong></li>
</ul>
<p><strong><font color="red"> DNS响应信息</font></strong></p>
<ul>
<li><strong>==域名的长度==</strong>：正常流量的域名长度分布为均值为6或7的高斯分布（正态分布）；而恶意流量的域名（FQDN全称域名）长度多为6（10）。</li>
<li><strong>==数字字符及非字母数字(non-alphanumeric
character)的字符占比==</strong>：正常流量的DNS响应中全称域名的数字字符的占比和非字母数字字符的占比要大。</li>
<li><strong>DNS解析出的IP数量</strong>：大多数恶意流量和正常流量只返回一个IP地址；其它情况，大部分正常流量返回2-8个IP地址，恶意流量返回4或者11个IP地址。</li>
<li><strong>TTL值</strong>：正常流量的TTL值一般为60、300、20、30；而恶意流量多为300，大约22%的DNS响应汇总TTL为100，而这在正常流量中很罕见。</li>
<li><strong>域名是否收录在Alexa网站</strong>：恶意流量域名信息很少收录在Alexa
top-1,000,000中，而正常流量域名多收录在其中。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/KK562V/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/KK562V/" class="post-title-link" itemprop="url">安全场景（2）离地攻击检测</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-13 12:49:05" itemprop="dateCreated datePublished" datetime="2022-05-13T12:49:05+08:00">2022-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-27 21:24:45" itemprop="dateModified" datetime="2022-05-27T21:24:45+08:00">2022-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url" rel="index"><span itemprop="name">应用场景</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="living-off-the-land恶意软件系统分析">Living-Off-The-Land
恶意软件系统分析</span></h2>
<blockquote>
<p>[][AI安全论文] <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&amp;mid=2247496069&amp;idx=1&amp;sn=f5aecaae5494b900b29f12078a2d632e&amp;chksm=cfcf4148f8b8c85ee56fbab09252bb4dc90f936cfb6decaa860b5e91457c9838cfb35179041a&amp;scene=178&amp;cur_album_id=1776483007625822210#rd">21.S&amp;P21
Survivalism经典离地攻击（Living-Off-The-Land）恶意软件系统分析</a>:S&amp;P21的离地攻击（Living-Off-The-Land）系统分析，这是一篇非常经典的论文，并且系统性分析文章是另一种讲故事的方式。</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXuMu3z61w35bGkJLmiaMzSMlbhFgicVxHG54dmR1ic5oqLlwSSzT28qicT2Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;"></p>
<blockquote>
<p>原文作者：Frederick Barr-Smith, Xabier Ugarte-Pedrero, et al.
<strong>原文标题</strong>：Survivalism: Systematic Analysis of Windows
Malware Living-Off-The-Land
<strong>原文链接</strong>：https://ieeexplore.ieee.org/document/9519480
<strong>发表会议</strong>：2021 IEEE Symposium on Security and Privacy
(SP)</p>
</blockquote>
<p><strong>文章目录：</strong></p>
<ul>
<li><p><strong>摘要</strong></p></li>
<li><p><strong>一.引言</strong></p>
<p>1.什么是离地攻击</p>
<p>2.APT中的离地攻击</p>
<p>3.提出五个关键问题</p>
<p>4.贡献（Contribution）</p></li>
<li><p><strong>二.背景和相关工作</strong></p>
<p>A.LotL Binaries</p>
<p>B.Scope of our Study</p>
<p>C.Related Work</p></li>
<li><p><strong>三.MOTIVATION: 杀毒软件产品 vs
离地攻击技术</strong></p></li>
<li><p><strong>四.离地攻击流行性评估</strong></p>
<p>A.Dataset Composition</p>
<p>B.Analysis Pipeline</p>
<p>C.LotL Technique Identification</p>
<p>D.Parameter Analysis to Identify Execution Purpose</p></li>
<li><p><strong>五.评估结果</strong></p>
<p>A.商用恶意软件中LotL技术的流行性（Prevalence）</p>
<p>B.Comparison of Benign and Malicious Samples</p>
<p>C.Prevalence of LotL techniques in APT Malware</p></li>
<li><p><strong>六.案例分析</strong></p></li>
<li><p><strong>七.要点和讨论</strong></p></li>
<li><p><strong>八.局限性和未来工作</strong></p></li>
<li><p><strong>九.个人感受</strong></p></li>
</ul>
<h3><span id="摘要">摘要</span></h3>
<p>随着恶意软件检测算法和方法变得越来越复杂（sophisticated），恶意软件作者也采用（adopt）同样复杂的逃避机制（evasion
mechansims）来对抗（defeat）它们。<strong>民间证据表明离地攻击技术（Living-Off-The-Land，LotL）是许多恶意软件攻击中最主要的逃避技术之一。这些技术利用（leverage）系统中已经存在的二进制文件来执行（conduct）恶意操作。</strong>基于此，我们首次对Windows系统上使用这些技术的恶意软件进行大规模系统地调查。</p>
<p>在本文中，我们分析了这些本地系统的二进制文件在多个恶意软件数据集上的使用情况，这些数据集共包含31,805,549个样本。我们发现平均流行率（prevalence）为9.41%。实验结果表明，LotL技术被大量的使用，特别是在高级持久性威胁（Advanced
Persistent Threat
，APT）恶意软件样本中，离地攻击占比为26.26%，是社区恶意软件的两倍多。</p>
<p><strong>为了验证（illustrate）LotL技术的逃逸潜力，我们在本地沙箱环境（sandboxed
environment）中对几个完全打补丁的Windows系统进行了离地攻击技术的测试，其结果表明在10个最流行的反病毒产品（anti-virus）中存在明显的gap。</strong></p>
<h3><span id="一-引言">一、引言</span></h3>
<h4><span id="11-什么是离地攻击">1.1 什么是离地攻击</span></h4>
<p>恶意软件开发和检测是猫和老鼠的游戏，恶意软件作者不断开发新技术来绕过（bypass）检测系统。像AV杀毒软件（anti-virus）这样的安全产品通过静态和启发式分析（heuristic
analysis）技术，以检测、分类和防止恶意软件有效执行。</p>
<p>在过去，许多解决方案严重依赖于基于签名的检测，但不幸的是，由于使用了<strong>多态性（polymorphism）和加壳程序（packers）</strong>，这些方法变得不再那么有效。相反，许多产品开始开发启发式分析解决方案，包括检测恶意行为的算法。这些算法已成为AV引擎的重要组成部分。随着时间的推移，这些算法越来越复杂，因此需要更多创新性的逃避技术。</p>
<p>恶意软件作者和红队经常研究和发现新方法来绕过安全解决方案。虽然它们的潜在目标本质上可能有所不同，但这两种类型的攻击者通常都利用（leverage）最先进（state-of-the-art）的逃避技术来实现目标。<strong>从防守者的角度来看，为了及时作出响应，了解这些攻击和研究它们的趋势是至关重要的（crucial）</strong>。其中，在红队和恶意软件作者中都流行的规避策略就是使用离地攻击（LotL）技术。</p>
<p>==<strong>离地攻击（LotL）技术是指使用系统中已经存在或易于安装的二进制文件（如已签名的合法管理工具）来执行后渗透活动（post-exploitation
activity）。</strong>==</p>
<ul>
<li>通过利用这些工具，攻击者可以<strong>实现注册表修改、持久化、网络或系统侦察，或执行其他恶意代码</strong>。它们甚至可以用来减少由恶意活动产生的事件日志，而不需要将其他文件下载到本地的系统中。</li>
</ul>
<h4><span id="12-apt中的离地攻击">1.2 APT中的离地攻击</span></h4>
<p>离地攻击并不是隐蔽的技术，它们在互联网上公开记录着。许多开源的攻击安全工具利用了LotL技术，并且经常被攻击者所使用，从合法的红队到业余的网络攻击者，以及有组织的APT团队。</p>
<ul>
<li><code>PoshSpy[15]</code>：是一个俄罗斯APT29攻击模块，它是第一个被检测到的APT组织使用的LotL技术，特别是在PowerShell和Windows
Management中。</li>
<li>伊朗威胁组织[1]、APT33、APT34和其他组织也以使用本地Windows二进制文件和其它签名工具而闻名，特别是PowerShell[8]。</li>
</ul>
<p>尽管“离地攻击”在信息安全界是一个相对知名的术语，但有时很难找到一个精确的定义。此外，据我们所知，没有任何研究包含了对LotL技术在恶意软件样本中的流行程度的系统分析。关于LotL技术的文档大多以博客的形式出现，并记录着某些恶意软件家族的在野发现，或者攻击者在远程访问受损系统中所使用技术的描述。</p>
<ul>
<li>例如，<code>Emotet</code> 和
<code>Trickbot</code>，两个最常见的远程访问木马（Remote Access
Trojans，RAT），据称是使用链接的LotL二进制文件来实现持久化。</li>
<li>作为一种对策，微软描述了对抗使用LotL技术商用RAT的基本步骤。高度逃逸的远程访问木马
<code>Astaroth</code>，<code>TA505</code>
组织的一些恶意软件库，<code>Dexphot cryptominer</code> 和
<code>Nodersok</code> 同期使用的多个LotL二进制文件。</li>
</ul>
<h4><span id="13-提出5个关键性问题">1.3 提出5个关键性问题</span></h4>
<p>在本文中，我们分析了LotL现象，即商用恶意软件中与离地攻击二进制文件利用相关的文件。我们首先描述了什么是LotL
binary以及它如何被恶意软件利用来实施恶意行为的。</p>
<p>本文的研究重点是以Windows为主导的操作系统下流行且恶意软件最常针对的目标。<strong>许多基于离地攻击的AV逃逸行为已被记录下来。因此（As
a
consequence），安全界很大程度上认为，LotL技术（如代理执行恶意软件）实际上对安全解决方案是有效的。</strong></p>
<p>首先，我们提出了第一个假设以及第一个研究问题：</p>
<blockquote>
<p>#### <strong>问题1：Can LotL techniques effectively evade commercial
AV?</strong></p>
<p>#### ==LotL技术能有效地逃避目前大部分安全厂商的杀毒软件检测吗？==</p>
</blockquote>
<p>为了回答这个问题，我们评估了一组具有代表性的安全产品，并展示了其中的一些技术，虽然这是攻击者和防御者所熟知的，但仍然是绕过安全解决方案的有效方法，因此对安全行业来说这仍是一个开放的挑战。</p>
<p><strong>事实上，LotL二进制文件经常被系统管理员和高级计算机用户使用来执行（perform）系统管理任务，这使得即使是对于训练有素的分析人员来说，区分（distinguish）合法行为和恶意行为也非常困难</strong>。我们负责任地向受影响的供应商披露了我们的发现并进行跟进，因此提高了他们的检测能力。</p>
<p>尽管现有的文档提供了这些技术使用的可靠证据，但仍然不清楚这种现象在恶意软件样本中有多普遍。因此（In
this way），我们就提出了第二个研究问题：</p>
<blockquote>
<p>#### <strong>问题2：How prevalent is the use of LotL binaries in
malware?</strong></p>
<p>#### ==在恶意软件中使用LotL二进制文件的情况有多普遍？==</p>
</blockquote>
<p>在此基础上，我们试图阐明当前威胁情景中的一些趋势，以确定（identify）：</p>
<blockquote>
<p>#### <strong>问题3：What purposes do malware binaries use LotL
techniques for?</strong></p>
<p>#### ==恶意软件的二进制文件使用LotL技术的目的是什么？==</p>
<p>#### <strong>问题4：Which malware families and types use LotL
binaries most prolifically and how does their usage differ?</strong></p>
<p>####
==哪些恶意软件家族和类型使用LotL二进制文件最多，它们的使用情况又有何不同？==</p>
</blockquote>
<p>此外，我们还调查（investigate）了为什么这些技术难以检测。部分杀毒软件公司参与了我们的披露，即将恶意攻击与系统管理员执行完全合法的管理任务区分开来是困难的。这就给我们带来了另一个问题：</p>
<blockquote>
<p><strong>问题5：What are the overlaps and differences in the behavior
of legitimate and malicious binaries with respect to the usage of LotL
binaries? How would this affect detection by heuristic AV
engines?</strong></p>
<p>####
==在使用LotL二进制文件方面，合法和恶意二进制文件的行为有哪些重叠和差异呢？这将如何影响启发式AV引擎的检测呢？==</p>
</blockquote>
<p>虽然恶意样本和良性样本之间的LotL二进制使用频率（prevalence）有一些明显的差异，但我们也注意到一些类别存在某些相似性，如<strong>代理执行（proxied
execution）</strong>。</p>
<p>最后，<strong>我们将注意力集中在高逃逸和高级持续威胁的恶意软件上，我们发现它利用离地攻击技术是商用恶意软件的两倍</strong>。在表1中列出了一些使用LotL技术进行攻击的APT组织。</p>
<h4><span id="14-贡献">1.4 贡献</span></h4>
<p>据我们所知，本文提出了迄今为止对商用和APT恶意软件使用LotL技术最大规模的系统分析。本文的核心（core
）贡献：</p>
<ul>
<li>我们通过测试一组最流行的AV引擎来对抗基于LotL技术部署的恶意载荷，以评估LotL技术的可行性，并展示了离地攻击检测的复杂性对行业仍是一个挑战。<strong>即使在披露9个月后，这些技术仍没有被发现</strong>。</li>
<li>我们对代表现代商用恶意软件的几个数据集进行了大规模的评估，并确定了LotL技术的流行程度，以及在不同恶意软件家族和类型之间的差异。我们还评估了LotL技术由于假阳性风险可能对行业产生的影响。</li>
<li>我们评估了一个APT恶意软件数据集，并将其公开以促进（facilitate）后续的研究，并确定它执行LotL技术的频率是商用恶意软件的两倍。此外，我们还确定了哪些APT组织最多地使用LotL技术。</li>
</ul>
<h3><span id="二-背景和相关工作">二、背景和相关工作</span></h3>
<p>我们首先定义LotL二进制文件，并枚举恶意软件使用这些二进制文件的目的。</p>
<h4><span id="21-lotl-binaries">2.1 LotL Binaries</span></h4>
<p>近年来，“<code>Living-Off-The-Land binary（LOLbin）</code>”已经成为一个常用词，用来指在网络攻击中广泛使用的二进制文件。历史上，“Living-Off-The-Land”一直被用来表示可以为农业或狩猎提供喂养土地或离地的概念。<strong>转换为恶意软件和入侵领域，攻击者可能利用那些已经可以使用的文件（即系统上已经存在或易于安装的）来发起攻击并躲避检测。</strong></p>
<p>在本文中，我们将LotL二进制定义为：</p>
<ul>
<li>==<strong>任何具有公认合法用途的二进制文件，在攻击期间利用它直接执行恶意行为，或间接协助一系列恶意行动，从而达到恶意结果。</strong>==</li>
</ul>
<blockquote>
<p>In this paper, we define a LotL binary as any binary with a
recognised legitimate use, that is leveraged during an attack to
directly perform a malicious action; or to assist indirectly, in a
sequence of actions that have a final malicious outcome.</p>
</blockquote>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXuuKVSBxwXyah6oA8o8y4YIcSszS9wu9wTcMpoVLldVNGWEmTcXX8Slw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;"></p>
<h4><span id="举例">举例：</span></h4>
<ul>
<li>在Windows系统上默认安装的二进制文件（binaries installed），如
<code>Reg.exe</code> 、<code>Sc.exe</code> 和 <code>Wmic.exe</code>
是最常被恶意软件执行的文件。</li>
<li>大多数默认安装的二进制文件都是由微软认证码签名的。认证码签名证明二进制文件没有在编译中被篡改或修改，这些二进制文件甚至可能被列为白名单。<strong>利用可信的LotL二进制文件的恶意软件可能因此避开杀毒软件</strong>。在Windows系统上使用系统二进制文件可以作为恶意软件操作的一部分，更重要的是，许多LotL技术使用系统二进制文件来实现这些二进制文件的目的。</li>
<li>此外，可以使用外部签名二进制文件（external signed binaries），如
<code>PsExec.exe</code>
或其他系统内部二进制文件。虽然它们使用频率不高，但本文的分析也囊括了这些文件。<strong>如APT组织在
<code>SoftCell</code> 和 <code>Havex</code> 中都使用
<code>PsExec.exe</code>
来秘密执行远程命令，从而实现网络中的横向移动。</strong></li>
<li>某些罕见情况，脆弱的（已签名）驱动程序被用来升级系统上的权限。这是
<code>RobbinHood</code> 勒索软件和各种 <code>APT wiper</code>
恶意软件样本所使用的一种技术，针对 <code>Saudi Arabian</code> 系统，包括
<code>Dustman</code> 、<code>Shamoon</code> 和
<code>Zerocleare</code>。</li>
</ul>
<h4><span id="可追溯性traceability"><strong>可追溯性（Traceability）：</strong></span></h4>
<ul>
<li>某些LotL二进制文件可能会比其他文件留下更多的系统日志，安全工具或取证分析人员可以利用这些日志来检测恶意操作。<strong>例如，可以将Powershell配置为具有全面的日志记录</strong>。</li>
<li>微软甚至建议<strong>阻止在系统上执行一些本机的二进制文件</strong>，除非有充分的理由。</li>
</ul>
<h4><span id="22-scope-of-our-study">2.2 Scope of our Study</span></h4>
<p>在本文中，我们关注的是Windows恶意软件执行系统二进制文件的目的。这些目的通常包括沿着
<strong>kill
chain</strong>的进展或逃避AV的检测。所有这些技术都被部署在系统的用户空间中。</p>
<p><code>hollowing</code> 和 <code>injection（注入）</code>
不在我们的研究范围内，尽管这是无文件恶意软件部署的常见技术。因为根据我们早期的定义，它们不是LotL技术。</p>
<h4><span id="23-related-work">2.3 Related Work</span></h4>
<blockquote>
<p>离地攻击相关工作较少，并且都非常经典，因此下面罗列了详细的相关研究，仅供自己后续深入，也希望对您有所帮助。</p>
</blockquote>
<ul>
<li>LotL恶意软件及其别名，“advanced volatile
threat”或“无文件”恶意软件在当前的学术文献中很少被提及。这主要受限于介绍分析少或描述为一个新兴的高逃逸恶意软件变体。</li>
<li>Li等[31]对恶意PowerShell脚本进行了分析，其中有一个小节专门描述了LotL攻击和无文件攻击作为近年来网络攻击的趋势。（<strong>作者第17篇博客详细介绍过PS经典</strong>）</li>
<li>Wang等[72]最近发表的一篇关于数据来源分析的论文指出，Living-Off-The-Land
是一种新兴的、突出的逃避型恶意软件子类（evasive malware
subtype）。（<strong>经典的You Are What You
Do后续即将分享</strong>）</li>
<li>先前的工作[64]进行了介绍性分析，然而LotL恶意软件还没有受到详细的学术分析。（An
emerging threat Fileless malware: a survey and research
challenges）</li>
<li>==<strong>赛门铁克</strong>[73,66]和<strong>思科Talos</strong>的[65]白皮书介绍了这个主题，并对多个数据集的流行性进行了分析。目前，没有论文对包含多个使用LotL技术的Windows恶意软件数据集进行大规模地系统分析。（<strong>经典</strong>）==
<ul>
<li>https://www.symantec.com/content/dam/symantec/docs/security-center/white-papers/istr-living-off-the-land-and-fileless-attack-techniques-en.pdf</li>
<li>https://www.symantec.com/content/dam/symantec/docs/white-papers/living-off-the-land-turning-your-infrastructure-against-you-en.pdf</li>
<li>https://blog.talosintelligence.com/2019/11/hunting-for-lolbins.html</li>
</ul></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXuo3I9Tc2Y5ic4biaG6jqMn0XNQbwVBw1LBM5ibErWYib2DDXc2avCPt2iaXQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;"></p>
<p>在一些论文中提到了LotL技术，强调了高隐蔽（stealthiness）和APT恶意软件曾使用。</p>
<ul>
<li><p>在一篇关于恶意软件分析工具Yara的论文中，Cohen[9]将LotL描述 “ LotL
as a trend that has been recently observed in the tactics used by elite
threat actors”，我们的分析结果进一步证实了该说法。</p></li>
<li><p>Hassan等[21]的研究表明，APT恶意软件使用LotL攻击策略来实现持续攻击并分析了两个活动，他们的工作还利用了MITRE
ATT&amp;CK框架[45]，通过MITRE定义了一个描述和分类知名攻击的分类方法。<strong>许多LotL技术在MITRE
ATT&amp;CK框架内被索引</strong>。Mitre公司及其常见CVE漏洞是安全领域的既定权威，他们囊括并描述许多LotL技术，这样表明离地攻击是一个值得深入分析的课题。</p></li>
<li><ul>
<li><strong>==W. U. Hassan, A. Bates, and D. Marino, “Tactical
Provenance Analysis for Endpoint Detection and Response Systems,” IEEE
Symposium on Security and Privacy, 2020.==</strong></li>
</ul></li>
</ul>
<p>==<strong>强烈推荐一个包含LotL二进制和ATT&amp;CK功能映射的资源</strong>：==</p>
<ul>
<li>https://github.com/LOLBAS-Project/LOLBAS</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXuicYc1hL2AJtlQRoibrRvWzTQjdOsicdTsl0q5kzawT3MibrOM71uREq5wQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;"></p>
<p>与我们研究相关的是对基于脚本的恶意软件分析和去混淆。使用LotL技术的恶意软件经常使用恶意脚本作为有效负载。（<strong>下列论文在作者第16篇PowerShell总结博客中详细介绍过</strong>）</p>
<ul>
<li>Ugarte等[67]通过识别可疑行为模式，测试了经
<code>Powershell.exe</code> 二进制调用的恶意脚本。</li>
<li><strong>Rubin等[61]将机器学习应用于检测PowerShell恶意软件（微软团队）</strong>。</li>
<li>Curtsinger[11]等人提出了恶意Javascript攻击的检测机制——ZOZZLE。</li>
</ul>
<p><strong>虽然这些论文提出了有效的检测方法，但是他们都是为狭隘的恶意载荷（payload）所用，他们没有分析更广泛的恶意软件生态系统和这些有效载荷是如何被LotL二进制文件触发的。</strong></p>
<h3><span id="三-动机">三、动机</span></h3>
<p><strong>安全研究人员已经记录了许多使用LotL技术成功躲避安全产品的案例</strong>。在许多情况下，这些<strong>LotL二进制文件被用来代理恶意载荷的执行，使其在一个合法的进程上下文中执行，或者作为一个合法系统进程的子进程生成一个新进程</strong>。在某些情况下，这些有效载荷作为LotL二进制调用的副作用被执行，而在其他情况下，它只是其主要记录行为的结果。此外，许多杀毒产品未能正确检测到这些技术。</p>
<figure>
<img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXuqG91IHaTia5YXypwibNOxcZymPMV5Ku4TjBhzZlOv1icJx9VnwDhZfVfw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片">
<figcaption aria-hidden="true">图片</figcaption>
</figure>
<p><strong>为了回答第一个问题，我们首先分析了当前AV产品是否将LotL技术作为恶意行为的指标。</strong></p>
<p>为此，我们首先选择了10个具有代表性的AV产品（详见附录C），并利用常见<strong>基于LotL的代理执行技术来实施反弹Shell的模拟攻击</strong>。此外，本研究的目的不是测试任何特定AV产品的检测能力或将它们相互比较，而是确定是否存在普遍的检测差距。</p>
<ul>
<li>实验在联网的Windows
10虚拟机执行，并将最新的本地AV产品连接到它们的云组件。</li>
<li>利用一个反弹Shell来评估AV系统在部署LotL技术的恶意软件中有多脆弱。本文认为能够允许远程执行命令的reverse
shell是成功执行代码的证明，这与许多远程访问木马（RAT）功能相同。</li>
<li>通过从不同LotL二进制文件中运行这个反弹shell来进行实验，以测试AV产品是否检测到离地攻击技术是恶意的。</li>
<li>我们在必要时混淆了反弹shell的有效载荷，并使用各种有效载荷类型来测试AV检测传递机制本身的能力，而不是通过静态签名传递的特定有效载荷（详见附录D）。</li>
</ul>
<h4><span id="实验结果如表2所示">实验结果如表2所示：</span></h4>
<ul>
<li><strong>可以发现大部分的AV引擎允许我们建立一个反弹Shell并执行命令，它们并没有检测出利用LotL技术的恶意软件，60个中只检测出4个。</strong></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXuoBzOPNqhU9ce1SlxeLjb0e6mb3RUz0rkP2wrKGjKibMMUltIvMvbUeA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;"></p>
<h4><span id="负责任的披露和回应">负责任的披露和回应：</span></h4>
<p>此后，我们向相关的AV供应商发布了一份文件，包含我们检查的结果并协助补救。9个月后，我们在Windows
10机器上重复了类似的测试，这允许我们测试AV供应商是否在他们的产品中包含了新的启发式规则来检测LotL二进制的使用。其结果如下：</p>
<ul>
<li><strong>可以发现在60个相同的有效载荷中检测到了25个</strong></li>
<li>在检测到的反弹shell测试中，我们修改了载荷（利用混淆或运行不同的载荷），同时为LotL二进制文件保持了完全相同的命令行参数，通过利用这些混淆和修改的有效载荷，我们成功地在这25个被拦截的实例中的19个执行了一个反向shell。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXuHRbN87ZFfsyVAYjqDAoDicE27vuhSBiaLf4zlGotKd2yrNfxA7Z3h2icw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;"></p>
<p>==<strong>实验结果表明，LotL技术仍然是杀毒软件供应商面临的一个重大挑战。合法用户通常以不可预知的方式使用这些工具，而安全公司很难在没有误报的情况下部署有效的检测策略。</strong>==</p>
<p>接下来将展示这些技术如何在商用恶意软件中是普遍存在的，以及离地攻击是不应该被安全社区忽视的问题。</p>
<h3><span id="四-离地攻击流行性评估">四、离地攻击流行性评估</span></h3>
<p>在本节中，我们测量了恶意软件中LotL技术的流行程度，并试图回答所提出的研究问题。</p>
<h4><span id="41-数据集描述">4.1 数据集描述</span></h4>
<p>评估工作是在9个独立的子数据集上进行的。我们总共收集了31,805,549个样本，其中我们从VirusTotal（VT）中获得了16,048,202份行为报告。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXulUhTGQG5b3yfdmTq4NIo8YaKGvb39A0WOwvqUft2aUEB7MwGebkjGw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;"></p>
<p>==<strong>Public Datasets</strong>==</p>
<p>公共恶意软件数据集，包括商用恶意软件、VirusShare语料库的二进制文件、窗口恶意PE文件、佐治亚理工学院发布的可执行文件、VX-Mumbal和MalShare共享的样本（两个重点的共有数据集）。</p>
<ul>
<li>https://impactcybertrust.org/dataset{ }view?idDataset=1143</li>
<li>https://vx-underground.org/samples.html</li>
<li>https://malshare.com</li>
</ul>
<p><strong>VirusTotal Balanced Dataset</strong></p>
<p>从VT中收集了237,288个hash值，利用 <code>AVClass</code>
预处理代码和打标签（家族分类），并平衡数据集中每个族。</p>
<p><strong>APT Malware</strong></p>
<p>我们根据一种类似于数据集论文dAPTaset[59]的方法收集了一个APT恶意软件的数据集。我们处理了HTML页面和pdf文件（<code>APTnotes</code>），并提取了这些文件中包含的所有恶意软件的hash值。</p>
<ul>
<li>https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-rezaeirad.pdf</li>
<li>https://github.com/aptnotes/data</li>
</ul>
<p>==<strong>Yara Rule Match Malware</strong>==</p>
<p>部署3个Yara规则来检测LotL二进制文件，并使用Livehunte来识别上传到VT的新的恶意软件hash，并使用LotL技术匹配恶意软件的行为特征。</p>
<h4><span id="42-analysis-pipeline">4.2 Analysis Pipeline</span></h4>
<p>当收集了由Windows
PE二进制文件组成的不同数据集，我们就分析样本的行为。包括三个阶段：</p>
<ul>
<li>data collection</li>
<li>data augmentation</li>
<li>data analysis</li>
</ul>
<blockquote>
<p>First Seen：首次发现病毒样本的时间戳 AVClass
Family：某恶意软件样本所属家族 <strong>Behavioural
Report：恶意行为报告，由特定恶意软件样本执行的进程和Shell命令的列表</strong></p>
</blockquote>
<h4><span id="43-lotl-techniqueidentification">4.3 LotL Technique
Identification</span></h4>
<p><strong>数据准备就绪，那么如何识别是否使用了LotL技术呢？</strong></p>
<p>我们使用<strong>模式匹配</strong>来识别恶意软件执行过程中对LotL二进制文件调用的情况，从而处理所有收集到的行为报告（<code>behavioural reports</code>）。行为报告包括两个指标：</p>
<ul>
<li><p><strong>Shell Commands（Shell命令）</strong></p>
<p><strong>恶意二进制文件在主机操作系统中执行的Shell命令</strong>，Shell命令日志可以通过引用系统二进制文件的绝对路径来显示它的执行情况。<strong>同时，Windows的命令提示符还包括许多别名，例如Reg.exe的reg</strong>。</p></li>
<li><p><strong>Processes（进程）</strong></p>
<p><strong>进程日志明确由恶意软件样本执行的系统二进制文件</strong>。执行的参数也包含在行为报告中的进程日志中。</p></li>
</ul>
<p>在我们的分析中，如果一个样本的行为报告包含至少一个LotL二进制文件的执行，那么它使用了LotL技术。<strong>我们记录了每一个LotL的执行及其参数细节，并将它们插入到数据库中。然后，我们分析了这些恶意软件样本的参数，以确定每个数据集中最==常见的参数类型和执行目的==。</strong></p>
<p>具体而言，我们确定了这两种独立类型的二进制文件：</p>
<ul>
<li><strong>Default System Binaries</strong></li>
<li><strong>Installed Signed Binaries</strong></li>
</ul>
<p>模式匹配优化：模式匹配方法在不断改进，直到所有识别的LotL命令被正确分类和映射到执行目的，并进行了数据清洗处理。</p>
<ul>
<li>不带参数的二进制执行移除</li>
<li>沙箱产物删除（如Explorer.exe和sha256），Web访问不处理</li>
<li>删除Verclsid.exe的实例</li>
</ul>
<h4><span id="44parameter-analysis-to-identify-execution-purpose">==4.4
Parameter Analysis to Identify Execution Purpose==</span></h4>
<p>==<strong>为了确定LotL技术的执行目的，我们观察了恶意软件样本提供的参数。</strong>==</p>
<p>图1说明了四个进程执行的映射。该映射通过识别单独的执行目的来在所有数据集上实施，<strong>例如执行Net.exe时使用stop参数表示任务停止。在将单个命令映射到执行目的之后，我们将为该二进制文件选择所有匹配的执行</strong>。我们在所有系统二进制执行中重复该步骤，直到每次执行被分类为属于特定的执行目的或被错误分类。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/0RFmxdZEDROicMJKf6AXIujWAvOnAhjXuHicN1aicniaStH5EZY1y22UBUzsMYXomMtNgYwuQYr1AZ8vWfRTPJOFPg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;"></p>
<p>按照这种方法，我们按目的将参数分为9个独立的类别。</p>
<p><strong>首先是三种与执行有关的类型：</strong></p>
<ul>
<li><strong>Proxied
Execution</strong>：代理执行，如Mshta.exe执行.hta文件，Rundll32.exe执行.dll文件</li>
<li><strong>Persistence</strong>：持久化：如果恶意代码配置或修改系统以在未来某个时间点执行命令或存储的作业，那么它就实现了持久性，比如Sc.exe带有创建参数的Bitsadmin.exe，或带有日期时间参数的Schtasks.exe/At.exe</li>
<li><strong>Delayed Execution</strong>：延迟执行，比如
Ping.exe执行-n</li>
</ul>
<p><strong>接着是三类与底层系统组件的修改有关。恶意软件通常从事这种行为，以便在机器上对目标进行==进一步的传播==或行动。</strong></p>
<ul>
<li><strong>Firewall Modification</strong>：防火墙修改，如Netsh.exe</li>
<li><strong>Registry Modification</strong>：注册表修改，如Reg.exe</li>
<li><strong>Permissions
Modification</strong>：权限修改，如Cacls.exe修改文件权限</li>
</ul>
<p><strong>最后是与执行或系统修改无关的三类。</strong></p>
<ul>
<li><strong>File Opening</strong>：打开文件，如Explorer.exe</li>
<li><strong>Reconnaissance</strong>：侦察，触发本地或远程配置的横向移动，如Net.exe</li>
<li><strong>Task
Stopping</strong>：使用LotL二进制文件秘密停止另一个进程或服务，如Taskkill.exe</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2ZDHNTC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2ZDHNTC/" class="post-title-link" itemprop="url">深度学习-NLP（1）词嵌入</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-13 11:14:54" itemprop="dateCreated datePublished" datetime="2022-05-13T11:14:54+08:00">2022-05-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-28 16:24:54" itemprop="dateModified" datetime="2022-06-28T16:24:54+08:00">2022-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">【draft】深度学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="nlpword2vecglovefasttextelmogptbert">nlp：word2vec/glove/fastText/elmo/GPT/bert</span></h2>
<blockquote>
<p>本文以QA形式对自然语言处理中的词向量进行总结：包含word2vec/glove/fastText/elmo/bert。</p>
<ul>
<li>https://zhuanlan.zhihu.com/p/56382372</li>
<li><strong>Bert之后，RoBERTa、XLNET、ALBERT、ELECTRA改进对比</strong> -
虹膜小马甲的文章 - 知乎 https://zhuanlan.zhihu.com/p/486532878</li>
</ul>
</blockquote>
<h3><span id="一-文本表示和各词向量间的对比"><strong>一、文本表示和各词向量间的对比</strong></span></h3>
<h4><span id="1-文本表示和各词向量间的对比"><strong>1、文本表示和各词向量间的对比</strong></span></h4>
<ul>
<li><strong>词袋模型</strong>：<strong>one-hot、tf-idf</strong>、textrank等；</li>
<li>主题模型：LSA（SVD）、pLSA、LDA；</li>
<li><strong>基于词向量的固定表征</strong>：<strong>word2vec、fastText</strong>、glove</li>
<li><strong>基于词向量的动态表征</strong>：elmo、<strong>GPT、bert</strong></li>
</ul>
<h4><span id="2-怎么从语言模型理解词向量怎么理解分布式假设"><strong>2、怎么从语言模型理解词向量？怎么理解分布式假设？</strong></span></h4>
<p>上面给出的4个类型也是nlp领域最为常用的文本表示了，文本是由每个单词构成的，而谈起词向量，one-hot是可认为是最为简单的词向量，但存在维度灾难和语义鸿沟等问题；通过构建共现矩阵并利用<strong>SVD求解构建词向量</strong>，则计算复杂度高<strong>；而早期词向量的研究通常来源于语言模型，比如NNLM和RNNLM</strong>，其主要目的是语言模型，而词向量只是一个副产物。</p>
<p>所谓==分布式假设，用一句话可以表达：<strong>相同上下文语境的词有似含义</strong>==。而由此引申出了word2vec、fastText，在此类词向量中，虽然其本质仍然是语言模型，但是它的目标并不是语言模型本身，而是词向量，其所作的一系列优化，都是为了更快更好的得到词向量。<strong>glove则是基于全局语料库、并结合上下文语境构建词向量，结合了LSA和word2vec的优点。</strong></p>
<h4><span id="3-传统的词向量有什么问题怎么解决各种词向量的特点是什么"><strong>3、传统的词向量有什么问题？怎么解决？各种词向量的特点是什么？</strong></span></h4>
<p><strong>上述方法得到的词向量是固定表征的，无法解==决一词多义==等问题</strong>，如“川普”。为此引入基于语言模型的动态表征方法：elmo、GPT、bert。</p>
<p><img src="https://pic2.zhimg.com/80/v2-80e28f4375302454947c9c8431564ed9_1440w.jpg" alt="img" style="zoom:50%;"></p>
<p><strong>各种词向量的特点：</strong></p>
<p>One-hot 表示 ：维度灾难、语义鸿沟；</p>
<p><strong>分布式表示 (distributed representation)</strong> ：</p>
<ul>
<li>矩阵分解（LSA）：利用全局语料特征，但SVD求解计算复杂度大；</li>
<li>基于NNLM/RNNLM的词向量：词向量为副产物，存在效率不高等问题；</li>
<li><strong>word2vec、fastText</strong>：优化效率高，但是基于局部语料；</li>
<li>glove：基于全局预料，结合了LSA和word2vec的优点；</li>
<li>elmo、GPT、bert：动态特征；</li>
</ul>
<h4><span id="4-word2vec和nnlm对比有什么区别word2vecvs-nnlm"><strong>4、word2vec和NNLM对比有什么区别？（word2vec
vs NNLM）</strong></span></h4>
<p>1）其本质都可以看作是语言模型；</p>
<p>2）词向量只不过NNLM一个产物，word2vec虽然其本质也是语言模型，但是其专注于词向量本身，因此做了许多优化来提高计算效率：</p>
<ul>
<li>与NNLM相比，词向量直接sum，不再拼接，并舍弃隐层；</li>
<li>考虑到sofmax归一化需要遍历整个词汇表，采用<strong>hierarchical
softmax</strong> 和<strong>negative
sampling</strong>进行优化，<strong>hierarchical softmax
实质上生成一颗带权路径最小的哈夫曼树，让高频词搜索路劲变小；negative
sampling更为直接，实质上对每一个样本中每一个词都进行负例采样；</strong></li>
</ul>
<h4><span id="5-word2vec和fasttext对比有什么区别word2vecvs-fasttext">5、<strong>word2vec和fastText对比有什么区别？（word2vec
vs fastText）</strong></span></h4>
<ul>
<li>都可以无监督学习词向量，
<strong>fastText训练词向量时会考虑subword</strong>；</li>
<li>fastText还可以进行==有监督学习==进行文本分类，其主要特点：
<ul>
<li>结构与<strong>CBOW类似</strong>，但学习目标是<strong>人工标注的分类结果</strong>；</li>
<li>采用hierarchical
softmax对输出的分类标签建立哈夫曼树，样本中标签多的类别被分配短的搜寻路径；</li>
<li><strong>引入N-gram，考虑词序特征</strong>；</li>
<li><strong>引入subword来处理长词，处理未登陆词问题</strong>；</li>
</ul></li>
</ul>
<h4><span id="6-glove和word2vec-lsa对比有什么区别word2vec-vs-glove-vs-lsa"><strong>6、glove和word2vec、
LSA对比有什么区别？（word2vec vs glove vs LSA）</strong></span></h4>
<ul>
<li><p><strong>glove vs LSA</strong></p>
<ul>
<li><p>LSA（Latent Semantic Analysis）可以基于co-occurance
matrix构建词向量，实质上是基于全局语料采用SVD进行矩阵分解，然而SVD计算复杂度高；</p></li>
<li><p>glove可看作是对LSA一种优化的高效矩阵分解算法，采用Adagrad对最小平方损失进行优化；</p></li>
</ul></li>
<li><p>==<strong>word2vec vs glove</strong>==</p>
<ul>
<li><p><strong>word2vec是局部语料库训练的，其特征提取是基于滑窗的</strong>；而glove的滑窗是为了构建co-occurance
matrix，是基于全局语料的，可见glove需要事先统计共现概率；因此，word2vec可以进行在线学习，glove则需要统计固定语料信息。</p></li>
<li><p>word2vec是无监督学习，同样由于不需要人工标注；glove通常被认为是无监督学习，但实际上glove还是有label的，即共现次数<img src="https://www.zhihu.com/equation?tex=log%28X_%7Bij%7D%29" alt="[公式]">。</p></li>
<li><p><strong>word2vec损失函数实质上是带权重的交叉熵，权重固定</strong>；<strong>glove的损失函数是最小平方损失函数，权重可以做映射变换。</strong></p></li>
<li><p>总体来看，<strong>==glove可以被看作是更换了目标函数和权重函数的全局word2vec==</strong>。</p></li>
</ul></li>
</ul>
<h4><span id="7-elmo-gpt-bert三者之间有什么区别elmo-vs-gpt-vsbert"><strong><font color="red">
7、 elmo、GPT、bert三者之间有什么区别？（elmo vs GPT vs
bert）</font></strong></span></h4>
<p>之前介绍词向量均是静态的词向量，无法解决一次多义等问题。下面介绍三种elmo、GPT、bert词向量，它们都是基于语言模型的动态词向量。下面从几个方面对这三者进行对比：</p>
<ul>
<li><strong>特征提取器</strong>：elmo采用<strong>LSTM</strong>进行提取，GPT和bert则采用<strong>Transformer</strong>进行提取。很多任务表明<strong>Transformer特征提取能力强于LSTM</strong>，elmo采用1层静态向量+2层LSTM，多层提取能力有限，而GPT和bert中的==Transformer==可采用多层，并行计算能力强。</li>
<li><strong>单/双向语言模型</strong>：GPT采用单向语言模型，elmo和bert采用双向语言模型。但是elmo实际上是两个单向语言模型（方向相反）的拼接，这种融合特征的能力比bert一体化融合特征方式弱。<strong>GPT和bert都采用Transformer，Transformer是encoder-decoder结构，GPT的单向语言模型采用decoder部分，decoder的部分见到的都是不完整的句子；bert的双向语言模型则采用encoder部分，采用了完整句子。</strong></li>
</ul>
<h3><span id="二-深入解剖word2vec"><strong>二、深入解剖word2vec</strong></span></h3>
<h4><span id="1-word2vec的两种模型分别是什么"><strong>1、word2vec的两种模型分别是什么？</strong></span></h4>
<p><strong>word2Vec</strong> 有两种模型：<strong>CBOW</strong> 和
<strong>Skip-Gram：</strong></p>
<ul>
<li><strong>CBOW 在已知 <code>context(w)</code> 的情况下，预测
<code>w</code>；在CBOW中，投射层将词向量直接相加而不是拼接起来，并舍弃了隐层，这些牺牲都是为了减少计算量</strong>。</li>
<li>Skip-Gram在已知 <code>w</code> 的情况下预测 <code>context(w)</code>
；</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-f1194171ee403f95c4131137ea1b52b3_1440w.jpg" alt="img" style="zoom: 67%;"></p>
<h4><span id="2-word2vec的两种优化方法是什么它们的目标函数怎样确定的训练过程又是怎样的">2、<strong>word2vec的两种优化方法是什么？它们的目标函数怎样确定的？训练过程又是怎样的？</strong></span></h4>
<p><strong>不经过优化的CBOW和Skip-gram中
,在每个样本中每个词的训练过程都要遍历整个词汇表</strong>，也就是都需要经过softmax归一化，计算误差向量和梯度以更新两个词向量矩阵（这两个词向量矩阵实际上就是最终的词向量，可认为初始化不一样），当语料库规模变大、词汇表增长时，训练变得不切实际。为了解决这个问题，word2vec支持两种优化方法：<strong>hierarchical
softmax</strong> 和<strong>negative
sampling</strong>。此部分仅做关键介绍，数学推导请仔细阅读《<a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/itplus/article/details/37969519">word2vec
中的数学原理详解</a>》。</p>
<ul>
<li><strong>hierarchical softmax</strong></li>
</ul>
<p><strong>hierarchical softmax</strong>
使用一颗二叉树表示词汇表中的单词，每个单词都作为二叉树的叶子节点。对于一个大小为V的词汇表，其对应的二叉树包含V-1非叶子节点。假如每个非叶子节点向左转标记为1，向右转标记为0，那么每个单词都具有唯一的从根节点到达该叶子节点的由｛0
1｝组成的代号（<strong>实际上为哈夫曼编码，为哈夫曼树，是带权路径长度最短的树，哈夫曼树保证了词频高的单词的路径短，词频相对低的单词的路径长，这种编码方式很大程度减少了计算量</strong>）。</p>
<ul>
<li><strong>negative sampling（拒绝采样）</strong></li>
</ul>
<p>negative sampling是一种不同于hierarchical
softmax的优化策略，相比于hierarchical softmax，negative
sampling的想法更直接——<strong>为每个训练实例都提供负例。</strong></p>
<p><strong><font color="red">
负采样算法实际上就是一个带权采样过程，负例的选择机制是和单词词频联系起来的。</font></strong>具体做法是以
<code>N+1</code> 个点对区间 <code>[0,1]</code>
做非等距切分，并引入的一个在区间 <code>[0,1]</code> 上的 <code>M</code>
等距切分，其中 <code>M &gt;&gt; N。</code>源码中取 M =
10^8。然后对两个切分做投影，得到映射关系：采样时，每次生成一个 [1, M-1]
之间的整数 i，则 Table(i)
就对应一个样本；当采样到正例时，跳过（<strong>拒绝采样</strong>）。</p>
<figure>
<img src="https://pic4.zhimg.com/80/v2-36547a4cd05365292830ad4b22ba4c93_1440w.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://pic3.zhimg.com/80/v2-a788595cc2611b0bfdac9e039a2e82fe_1440w.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="https://pic1.zhimg.com/80/v2-cfe67c913af37a9435f3331139abeab8_1440w.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3><span id="三-深入解剖glove详解"><strong>三、深入解剖Glove详解</strong></span></h3>
<p><strong>GloVe的全称叫Global Vectors for Word
Representation，它是一个基于全局词频统计（count-based &amp; overall
statistics）的词表征（word representation）工具。</strong></p>
<p><strong>1、GloVe构建过程是怎样的？</strong></p>
<p>（1）根据语料库构建一个共现矩阵，矩阵中的每一个元素 <img src="https://www.zhihu.com/equation?tex=X_%7Bij%7D" alt="[公式]">
代表单词 <img src="https://www.zhihu.com/equation?tex=i" alt="[公式]">
和上下文单词 <img src="https://www.zhihu.com/equation?tex=j" alt="[公式]"> 在特定大小的上下文窗口内共同出现的次数。</p>
<blockquote>
<p>共现矩阵:统计文本中两两词组之间共同出现的次数</p>
</blockquote>
<p>（2）构建词向量（Word
Vector）和共现矩阵之间的近似关系，其目标函数为：</p>
<figure>
<img src="https://www.zhihu.com/equation?tex=J+%3D+%5Csum_%7Bi%2Cj%3D1%7D%5EV+f%5CBig%28X_%7Bij%7D%5CBig%29%5CBig%28w_i%5ET%5Ctilde%7Bw_j%7D+%2B+b_i+%2B+b_j+-%5Clog%7BX_%7Bij%7D%7D+%5CBig%29%5E2" alt="[公式]">
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>这个loss function的基本形式就是最简单的mean square
loss，只不过在此基础上加了一个权重函数 <img src="https://www.zhihu.com/equation?tex=f%28x_%7Bij%7D%29" alt="[公式]"> :</p>
<figure>
<img src="https://www.zhihu.com/equation?tex=f%28x%29+%3D++%5Cbegin%7Bcases%7D+%28x%2Fx_%7B%5Cmax%7D%29%5E%5Calpha+%26+%5Ctext%7Bif+%7D+x%3Cx_%7B%5Cmax%7D+%5C%5C+1+%26+%5Ctext%7Botherwise.%7D+%5Cend%7Bcases%7D" alt="[公式]">
<figcaption aria-hidden="true">[公式]</figcaption>
</figure>
<p>根据实验发现 <img src="https://www.zhihu.com/equation?tex=x_%7B%5Cmax%7D" alt="[公式]">
的值对结果的影响并不是很大，原作者采用了 <img src="https://www.zhihu.com/equation?tex=x_%7B%5Cmax%7D%3D100" alt="[公式]"> 。而 <img src="https://www.zhihu.com/equation?tex=%5Calpha%3D3%2F4" alt="[公式]"> 时的结果要比 <img src="https://www.zhihu.com/equation?tex=%5Calpha%3D1" alt="[公式]">
时要更好。下面是 <img src="https://www.zhihu.com/equation?tex=%5Calpha%3D3%2F4" alt="[公式]"> 时 <img src="https://www.zhihu.com/equation?tex=f%28x%29" alt="[公式]">
的函数图象，可以看出对于较小的 <img src="https://www.zhihu.com/equation?tex=X_%7Bij%7D" alt="[公式]">
，权值也较小。这个函数图像如下所示：</p>
<figure>
<img src="https://pic3.zhimg.com/80/v2-2e2b198b3b7a7c4ace45648ff18dd2ca_1440w.jpg" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<blockquote>
<ol type="1">
<li>实质上还是监督学习：虽然glove不需要人工标注为无监督学习，但实质还是有label就是
<img src="https://www.zhihu.com/equation?tex=log%28X_%7Bij%7D%29" alt="[公式]"> 。</li>
<li>向量 <img src="https://www.zhihu.com/equation?tex=w" alt="[公式]">
和 <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bw%7D" alt="[公式]">为学习参数，本质上与监督学习的训练方法一样，采用了AdaGrad的梯度下降算法，对矩阵
<img src="https://www.zhihu.com/equation?tex=X" alt="[公式]">
中的所有非零元素进行随机采样，学习曲率（learning
rate）设为0.05，在vector
size小于300的情况下迭代了50次，其他大小的vectors上迭代了100次，直至收敛。</li>
<li>最终学习得到的是两个词向量是 <img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bw%7D" alt="[公式]">
和 <img src="https://www.zhihu.com/equation?tex=w+" alt="[公式]">
，因为 <img src="https://www.zhihu.com/equation?tex=X" alt="[公式]">
是对称的（symmetric），所以从原理上讲<img src="https://www.zhihu.com/equation?tex=%5Ctilde%7Bw%7D" alt="[公式]">
和 <img src="https://www.zhihu.com/equation?tex=w+" alt="[公式]">
，是也是对称的，他们唯一的区别是初始化的值不一样，而导致最终的值不一样。所以这两者其实是等价的，都可以当成最终的结果来使用。但是为了提高鲁棒性，我们最终会选择两者之和
<img src="https://www.zhihu.com/equation?tex=w%2B%5Ctilde%7Bw%7D" alt="[公式]">
作为最终的vector（两者的初始化不同相当于加了不同的随机噪声，所以能提高鲁棒性）。</li>
</ol>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/3VPSMN7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3VPSMN7/" class="post-title-link" itemprop="url">python-正则表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-12 18:22:55" itemprop="dateCreated datePublished" datetime="2022-05-12T18:22:55+08:00">2022-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-21 14:30:46" itemprop="dateModified" datetime="2023-04-21T14:30:46+08:00">2023-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">【draft】工程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%B7%A5%E7%A8%8B/%E6%B5%81%E7%A8%8B%E7%9A%84Python/" itemprop="url" rel="index"><span itemprop="name">流程的Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>98</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1><span id="python3爬虫笔记-正则表达式">Python3爬虫笔记 --
正则表达式</span></h1>
<p>https://blog.csdn.net/Sc0fie1d/article/details/102724298?spm=1001.2014.3001.5502</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lzy</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

    </div>
  </footer>

  

  <a href="https://github.com/PowerLZY" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>




        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'powerlzy.github.io' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>
</html>
