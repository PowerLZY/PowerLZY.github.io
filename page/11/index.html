<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"powerlzy.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="相比到达的地方，同行的人更重要！">
<meta property="og:type" content="website">
<meta property="og:title" content="PowerLZY&#39;s Blog">
<meta property="og:url" content="https://powerlzy.github.io/page/11/index.html">
<meta property="og:site_name" content="PowerLZY&#39;s Blog">
<meta property="og:description" content="相比到达的地方，同行的人更重要！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://powerlzy.github.io/page/11/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/11/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PowerLZY's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">PowerLZY's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">本博客主要用于记录个人学习笔记（测试阶段）</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lzy"
      src="/images/cat_mac.jpg">
  <p class="site-author-name" itemprop="name">lzy</p>
  <div class="site-description" itemprop="description">相比到达的地方，同行的人更重要！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">267</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/PowerLZY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PowerLZY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3289218653@qq.com" title="E-Mail → mailto:3289218653@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2MJ41K7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2MJ41K7/" class="post-title-link" itemprop="url">python-环境变量</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-06 15:22:38 / 修改时间：15:22:48" itemprop="dateCreated datePublished" datetime="2022-06-06T15:22:38+08:00">2022-06-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">【draft】工程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%B7%A5%E7%A8%8B/%E6%B5%81%E7%A8%8B%E7%9A%84Python/" itemprop="url" rel="index"><span itemprop="name">流程的Python</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/3JZF773/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3JZF773/" class="post-title-link" itemprop="url">恶意软件检测（7）【draft】CADE: Detecting and Explaining Concept Drift Samples for Security Applications</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-05 20:05:05" itemprop="dateCreated datePublished" datetime="2022-06-05T20:05:05+08:00">2022-06-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-06 16:35:43" itemprop="dateModified" datetime="2023-05-06T16:35:43+08:00">2023-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">恶意软件检测</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="cadedetecting-and-explaining-concept-drift-samples-for-securityapplications">CADE:
Detecting and Explaining Concept Drift Samples for Security
Applications</span></h2>
<p>原文作者：Limin Yang, <em>University of Illinois at
Urbana-Champaign</em></p>
<p>原文链接：https://www.usenix.org/conference/usenixsecurity21/presentation/yang-limin</p>
<p>发表会议：USENIXSec 2021</p>
<p><strong>代码地址</strong>：https://github.com/whyisyoung/CADE</p>
<h3><span id="摘要">摘要</span></h3>
<p>概念漂移对部署机器学习模型来解决实际的安全问题提出了严峻的挑战。<strong>由于攻击者（和/或良性对手）的动态行为变化，随着时间的推移，测试数据分布往往会从原始的训练数据转移，从而导致部署的模型出现重大故障</strong>。</p>
<p>为了对抗概念漂移，我们提出了一种新的系统CADE，旨在（1）<strong>检测偏离现有类别的漂移样本</strong>；（2）<strong>解释检测到漂移的原因</strong>。与传统方法不同（需要大量新标签来统计确定概念漂移），我们的目标是在单个漂移样本到达时识别它们。认识到高维离群空间带来的挑战，我们建议将数据样本映射到低维空间，并自动学习距离函数来度量样本之间的相异性。通过对比学习，我们可以充分利用训练数据集中现有的标签来学习如何对样本进行比较和对比。<strong>为了解释检测到的漂移的意义，我们开发了一种基于距离的解释方法</strong>。我们表明，在这个问题背景下，解释“距离”比传统方法更有效，传统方法侧重于解释“决策边界”。我们通过两个案例来评估CADE：Android恶意软件分类和网络入侵检测。我们进一步与一家安全公司合作，在其恶意软件数据库上测试CADE。我们的结果表明，CADE可以有效地检测漂移样本，并提供语义上有意义的解释。</p>
<h3><span id="一-说明">一、说明</span></h3>
<p>由于概念漂移，部署基于机器学习的安全应用程序可能非常具有挑战性。无论是恶意软件分类、入侵检测还是在线滥用检测[6、12、17、42、48]，基于学习的模型都是在“封闭世界”假设下工作的，期望测试数据分布与训练数据大致匹配。然而，部署模型的环境通常会随着时间的推移而动态变化。这种变化可能既包括良性玩家的有机行为变化，也包括攻击者的恶意突变和适应。因此，测试数据分布从原始训练数据转移，这可能会导致模型出现严重故障[23]。</p>
<blockquote>
<p>[23] A survey on concept drift adaptation. ACM computing surveys
(CSUR), 2014.</p>
</blockquote>
<p>为了解决概念漂移问题，大多数基于学习的模型需要<strong>定期重新培训</strong>[36、39、52]。然而，再培训通常需要标记大量新样本（昂贵）。更重要的是，还很难确定何时应该对模型进行再培训。延迟的再培训会使过时的模型容易受到新的攻击。</p>
<p><font color="red"><strong>我们设想，对抗概念漂移需要建立一个监控系统来检查传入数据流和训练数据（和/或当前分类器）之间的关系</strong></font>。图1说明了高级思想。当原始分类器在生产空间中工作时，另一个系统应定期检查分类器对传入数据样本做出决策的能力。<strong>A检测模块(1)
可以过滤正在远离训练空间的漂移样本</strong>。更重要的是，为了<strong>解释漂移的原因（例如，攻击者突变、有机行为变化、以前未知的系统错误）</strong>，我们需要一种解释方法(2)
将检测决策与语义上有意义的特征联系起来。这两项功能对于为开放世界环境准备基于学习的安全应用程序至关重要。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550835.png" alt="image-20220605202728095" style="zoom: 67%;"></p>
<p>之前的工作已经探索了通过直接检查原始分类器（0）的预测置信度来检测漂移样本的方法
<strong>[32]</strong>。置信度较低可能表明传入样本是漂移样本。然而，该置信度得分是基于所有类别已知（封闭世界）的假设计算的概率（总和为1.0）。不属于任何现有类别的漂移样本可能会被分配到错误的类别，并具有很高的置信度（已通过现有工作验证[25、32、37]）。最近的一项工作提出了计算传入样本和每个现有类之间的不一致性度量的想法，以确定适合度[38]。<strong>该不合格度量基于距离函数计算，以量化样本之间的不相似性</strong>。<strong>然而，我们发现这种距离函数很容易失效，尤其是当数据稀疏且维数较高时。</strong></p>
<blockquote>
<p><strong>[32] A baseline for detecting misclassified and
out-of-distribution examples in neural networks.</strong></p>
</blockquote>
<p><strong>我们的方法</strong>。在本文中，我们提出了一种检测漂移样本的新方法，并结合一种解释检测决策的新方法。我们共同构建了一个称为CADE的系统，它是“用于漂移检测和解释的对比自动编码器
(“<strong>Contrastive Autoencoder for Drifting detection and
Explanation</strong>)”的缩写关键的挑战是<strong>推导一个有效的距离函数来衡量样本的相异性</strong>。我们没有随意选取距离函数，而是利用对比学习的思想[29]，根据现有的标签，从现有的训练数据中学习距离函数。给定原始分类器的训练数据（多个类别），我们将训练样本映射到低维潜在空间。映射函数通过对比样本来学习，以扩大不同类样本之间的距离，同时减少同一类样本之间的距离。<strong>我们证明了在潜在空间中得到的距离函数可以有效地检测和排序漂移样本。</strong></p>
<p>评价我们使用两个数据集评估我们的方法，包括<strong>Android恶意软件数据集[7]和2018年发布的入侵检测数据集[57]</strong>。我们的评估表明，我们的漂移检测方法具有很高的准确性，F1平均得分为0.96或更高，优于各种基线和现有方法。我们的分析还表明，使用对比学习可以减少检测决策的模糊性。对于解释模型，我们进行了定量和定性评估。案例研究还表明，所选特征与漂移样本的语义行为相匹配。</p>
<p>此外，我们还与一家安全公司的合作伙伴合作，在其内部恶意软件数据库上测试CADE。作为初步测试，我们从395个家庭中获得了2019年8月至2020年2月出现的20613个Windows
PE恶意软件样本。这使我们能够在不同的环境中测试更多恶意软件系列的系统性能。结果很有希望。<font color="red"><strong>例如，CADE在10个家庭中进行训练并在160个以前未见过的家庭中进行测试时，F1成绩达到0.95分。这使得人们有兴趣在生产系统中进一步测试和部署CADE。</strong>
</font></p>
<h4><span id="贡献">贡献：</span></h4>
<p>本文有三个主要贡献。</p>
<ul>
<li>我们提出CADE来补充现有的基于监督学习的安全应用程序，以对抗概念漂移。提出了<strong>一种基于对比表征学习的漂移样本检测方法</strong>。</li>
<li>我们说明了监督解释方法在解释异常样本方面的局限性，并<strong>介绍了一种基于距离的解释方法</strong>。</li>
<li>我们通过两个应用对所提出的方法进行了广泛的评估。我们与一家安保公司的初步测试表明，CADE是有效的。我们在此处发布了CADE代码1，以支持未来的研究。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2MX2YPX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2MX2YPX/" class="post-title-link" itemprop="url">安全场景（6）PowerShell</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-03 15:27:51 / 修改时间：15:28:05" itemprop="dateCreated datePublished" datetime="2022-06-03T15:27:51+08:00">2022-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url" rel="index"><span itemprop="name">应用场景</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>0</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/30K2RMS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/30K2RMS/" class="post-title-link" itemprop="url">安全场景（5）恶意DNS检测</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-03 15:27:21" itemprop="dateCreated datePublished" datetime="2022-06-03T15:27:21+08:00">2022-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-06-25 22:19:34" itemprop="dateModified" datetime="2022-06-25T22:19:34+08:00">2022-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" itemprop="url" rel="index"><span itemprop="name">应用场景</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>122</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1><span id="datacon-2019-dns-analysis">DataCon 2019: DNS Analysis</span></h1>
<p>https://ixyzero.com/blog/archives/4473.html</p>
<ul>
<li>Datacon 2019：https://github.com/shyoshyo/DataCon-9102-DNS</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/CCPH1H/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/CCPH1H/" class="post-title-link" itemprop="url">模型训练（7）【draft】参数初始化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-29 18:37:10" itemprop="dateCreated datePublished" datetime="2022-05-29T18:37:10+08:00">2022-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-01 18:46:33" itemprop="dateModified" datetime="2023-05-01T18:46:33+08:00">2023-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">【draft】深度学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">训练技巧</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>349</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="参数初始化">参数初始化</span></h2>
<blockquote>
<ul>
<li>https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/model_tuning/weight_initializer.html</li>
</ul>
</blockquote>
<p>在我们开始训练神经网络之前，首先要做的是给网络中的每一个权重和偏置赋值，这个赋值的过程就是参数初始化。<strong>合理的初始化可以缩短神经网络的训练时间，而不合理的初始化可能使网络难以收敛</strong>。那么，我们要如何对参数进行初始化呢？或许你有想到过将全部参数都设置为0，这看起来是一个简单又方便的办法，但遗憾的是神经网络中不能对权重进行全零初始化。在讨论如何对参数进行初始化前，我们先来看看为什么不能进行全零初始化。</p>
<h4><span id="一-为什么不能全零初始化">一、为什么不能全零初始化？</span></h4>
<p>以一个三层网络为例，假设其具体的网络示意图如图1所示。</p>
<p><img src="https://paddlepedia.readthedocs.io/en/latest/_images/net_for_params_init.png" alt="net_for_params_init" style="zoom:50%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2APFWS8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2APFWS8/" class="post-title-link" itemprop="url">工业落地-Sophos《Learning from Context: Exploiting and Interpreting File Path Information for Better Malware Detection》</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-28 15:50:06" itemprop="dateCreated datePublished" datetime="2022-05-28T15:50:06+08:00">2022-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-18 15:10:01" itemprop="dateModified" datetime="2023-04-18T15:10:01+08:00">2023-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/" itemprop="url" rel="index"><span itemprop="name">工业落地</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">恶意软件检测</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="learningfrom-context-exploiting-and-interpreting-file-path-information-forbetter-malware-detection">Learning
from Context: Exploiting and Interpreting File Path Information for
Better Malware Detection</span></h2>
<ul>
<li>https://ai.sophos.com/presentations/learning-from-context-a-multi-view-deep-learning-architecture-for-malware-detection/</li>
</ul>
<blockquote>
<p>用于静态可移植可执行（PE）恶意软件检测的机器学习（ML）通常使用每个文件的数字特征向量表示作为训练期间一个或多个目标标签的输入。然而，可以从查看文件的上下文中收集到许多正交信息。在本文中，我们<strong>建议使用静态上下文信息源（PE文件的路径）作为分类器的辅助输入</strong>。虽然文件路径本身不是恶意或良性的，但它们确实为恶意/良性判断提供了有价值的上下文。与动态上下文信息不同，文件路径的可用开销很小，并且可以无缝集成到多视图静态ML检测器中，在非常高的吞吐量下产生更高的检测率，同时基础结构的更改也很小。在这里，我们提出了一种多视图神经网络，它从PE文件内容以及相应的文件路径中提取特征向量作为输入并输出检测分数。为了确保真实的评估，我们使用了大约1000万个样本的数据集—来自实际安全供应商网络的用户端点的文件和文件路径。<strong>然后，我们通过LIME建模进行可解释性分析，以确保我们的分类器已学习到合理的表示，并查看文件路径的哪些部分对分类器得分的变化贡献最大</strong>。我们发现，我们的模型学习了文件路径的有用方面以进行分类，同时还学习了测试供应商产品的客户的工件，例如，通过下载恶意软件样本目录，每个样本都命名为其哈希。我们从我们的测试数据集中删减了这些工件，并证明在10−3假阳性率（FPR），10时为33.1%−4
FPR，基于类似拓扑的单输入PE文件内容模型。</p>
</blockquote>
<h3><span id="摘要">摘要</span></h3>
<p>用于恶意软件检测的机器学习（ML）分类器通常在进行恶意/良性判断时使用每个文件内容的数字表示。<strong>然而，也可以从文件所在的上下文中收集相关信息，这些信息通常被忽略。<font color="red">
上下文信息的一个来源是文件在磁盘上的位置。</font></strong>例如，如果检测器可以清楚地利用有关其所在路径的信息，则伪装为已知良性文件（例如Windows系统DLL）的恶意文件更有可能显得可疑。了解文件路径信息还可以更容易地检测那些试图通过将自己放置在特定位置来逃避磁盘扫描的文件**。文件路径也可以使用，开销很小，并且可以无缝集成到多视图静态ML检测器中，在非常高的吞吐量和最小的基础结构更改下，可能产生更高的检测率。</p>
<p>在这项工作中，我们提出了一种 <strong>multi-view</strong>
深度神经网络结构，该结构将PE文件内容中的特征向量以及相应的文件路径作为输入并输出检测分数。我们对大约1000万个样本的商业规模数据集进行了评估，这些样本是来自实际安全供应商提供服务的用户端点的文件和文件路径。<strong>然后，我们通过LIME建模进行可解释性分析，以确保我们的分类器已学习到合理的表示，并检查文件路径如何在不同情况下改变分类器的分数</strong>。我们发现，与只对PE文件内容进行操作的模型相比，<strong>我们的模型学习了文件路径的有用方面，在0.001假阳性率（FPR）下，真阳性率提高了26.6%，在0.0001
FPR下，提高了64.6%</strong>。</p>
<p><strong>keyword</strong> :
静态PE检测、文件路径、深度学习、多视图学习、模型解释</p>
<h3><span id="一-说明">一、说明</span></h3>
<p>商用便携式可执行（PE）恶意软件检测器由静态和动态分析引擎组成。<strong>静态检测通常首先用于标记可疑样本，它可以快速有效地检测大部分恶意软件</strong>。它涉及分析磁盘上的原始PE映像，可以非常快速地执行，但易受代码混淆技术的影响，例如压缩和多态/变形转换<strong>[1]</strong>。相比之下，动态检测需要在模拟器中运行PE，并在运行时分析行为[2]。当动态分析工作时，它不太容易受到代码混淆的影响，但与静态方法相比，它需要更大的计算容量和执行时间。此外，有些文件很难在仿真环境中执行，但仍然可以进行静态分析。<strong>因此，静态检测方法通常是端点恶意软件预防（在执行恶意软件之前阻止恶意软件）管道中最关键的部分</strong>。最近，由于采用了机器学习，静态检测方法的性能有所提高[3]，其中高度表达的分类器（例如深层神经网络）适合于数百万个文件的标记数据集。训练这些分类器时，它们使用静态文件内容作为输入，但不使用辅助数据。<strong>然而，我们注意到，由于辅助数据（例如网络流量、系统调用等），动态分析工作得很好。</strong>在这项工作中，我们试图使用文件路径作为正交输入信息来增强静态ML检测器。<strong>文件路径是静态可用的，无需操作系统的任何附加工具</strong>。通过将文件路径作为辅助输入，我们希望能够将有关文件的信息与在特定位置看到此类文件的可能性的信息结合起来，<strong>并识别与已知恶意软件和良性文件相关的常见目录层次结构和命名模式。</strong></p>
<blockquote>
<p><strong>静态检测</strong>：通用模块，快速有效地标记可疑样本；易受代码混淆技术（压缩和多态/变形转换）的影响。</p>
<p>[1] A. Moser, C. Kruegel, and E. Kirda, “Limits of static analysis
for malware detection,” in Twenty-Third Annual Computer Security
Applications Conference (ACSAC 2007). IEEE, 2007, pp. 421–430.</p>
<p><strong>动态检测</strong>：分析模块，需要更大的计算容量和执行时间；有些文件很难在仿真环境中执行。</p>
</blockquote>
<p>我们将分析重点放在三个模型上：</p>
<ul>
<li>仅基线文件内容（PE）模型，仅将PE功能作为输入并输出恶意软件置信度得分。</li>
<li>另一个基准文件路径仅内容（FP）模型，仅将文件的文件路径作为输入，并输出恶意软件置信度得分。</li>
<li>我们提出的多视图PE文件内容+上下文文件路径（PE+FP）模型，该模型同时考虑PE文件内容特征和文件路径，并输出恶意软件置信度得分。</li>
</ul>
<p>三个模型的示意图如图1所示。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304181509919.png" alt="image-20220528162748125" style="zoom:50%;"></p>
<p>我们对从一家大型反恶意软件供应商的遥测数据中收集的时间分割数据集进行分析，发现我们在文件内容和上下文文件路径上训练的分类器在ROC曲线上，尤其是在低误报率（FPR）区域，产生了统计上显著更好的结果。</p>
<p><strong>本文的贡献如下：</strong></p>
<ul>
<li>我们从安全供应商的客户端点（而不是恶意软件/供应商标签聚合服务）获得一组真实、精心策划的文件和文件路径数据集。</li>
<li>我们证明，我们的多视图PE+FP恶意软件分类器在我们的数据集上的性能明显优于单独使用文件内容的模型。</li>
<li>我们将本地可解释模型不可知解释（LIME）<strong>[4]</strong>扩展到PE+FP模型，并使用它分析文件路径如何影响模型的恶意/良性决策。</li>
</ul>
<blockquote>
<p>[4] M. T. Ribeiro, S. Singh, and C. Guestrin, “Why should i trust
you?: Explaining the predictions of any classifier,” in Proceedings of
the 22nd ACM SIGKDD international conference on knowledge discovery and
data mining. ACM, 2016, pp. 1135–1144.</p>
</blockquote>
<p>本手稿的其余部分结构如下：第二节涵盖重要的背景概念和相关工作。第三节讨论数据集收集和模型制定。第四节将我们的新多视图方法与拓扑结构相似的纯内容基线模型进行了比较，并对我们的模型进行了可解释性分析。第五节结束。</p>
<h3><span id="二-背景和相关工作">二、背景和相关工作</span></h3>
<p>在本节中，我们将描述机器学习如何普遍应用于静态PE检测，以及我们的方法如何通过提供上下文信息作为辅助输入而在高层意义上有所不同。然后，我们介绍了其他机器学习领域的相关工作。</p>
<h4><span id="21-静态ml恶意软件检测">2.1 静态ML恶意软件检测</span></h4>
<p>机器学习已经应用于计算机安全领域多年了[5]，但在商业规模上使用ML的静态PE模型的破坏性性能突破是一个较新的现象。商业模型通常依赖深度神经网络[6]或增强的决策树集合[7]，并已扩展到其他静态文件类型，包括web内容[8]、[9]、office文档[10]和档案[10]。</p>
<p>大多数用于信息安全的静态ML（ML-Sec）分类器操作的是文件部分（例如，标题）上的学习嵌入[11]，整个文件上的学习嵌入[12]，或者最常见的是，操作的是设计用于总结每个文件内容的预设计数字特征向量[6]、[13]–[19]。预先构建的特征向量表示往往更具可伸缩性，可以快速从每个文件中提取内容，同时保留有用的信息。有很多方法可以构建特征向量，包括在滑动窗口上跟踪每字节统计信息【6】、【18】、字节直方图【7】、【18】、ngram直方图【13】、将字节视为图像中的像素值（文件内容的可视化）【13】、【18】、操作码和函数调用图统计信息【18】、符号统计信息【18】、哈希/数字元数据值【6】、【7】、【18】–例如。，入口点作为文件的一部分，或散列导入和导出，以及分隔标记的散列[10]、[19]。在实际应用中，从文件内容中提取的几种不同类型的特征向量通常连接在一起，以获得优异的性能。</p>
<h4><span id="22-learning-from-multiplesources">2.2 Learning from Multiple
Sources</span></h4>
<p>使用深度神经网络进行静态ML恶意软件检测的相关研究已经检验了从多个信息源学习的方法，但这些方法与我们的方法有根本不同：Huang等人【20】和Rudd等人【21】对多个辅助损失函数使用多目标学习【22】，【23】，他们发现这些函数在主要恶意软件检测任务中的性能有所提高。这两项工作都在培训期间使用元数据作为辅助目标标签，为模型提供额外的信息，并在部署时使用单个输入来做出分类决策。我们的方法利用了多种输入类型/模式——一种是以类似于[6]的PE特征向量的形式描述恶意样本的内容，另一种是将原始字符串提供给一个字符嵌入层（类似于[8]），该层提供了有关该样本出现位置的信息。这种技术是一种多视图学习方法[24]。顾名思义，多视图学习的大多数应用都是在计算机视觉中进行的，在计算机视觉中，多个视图实际上是由来自不同输入摄像头/传感器的视图或来自同一摄像头/传感器在不同时间的不同视图组成的。<strong>在ML-Sec空间中，我们只能找到两种专门将自己称为多视图的方法：即[25]，Narayanan等人将多内核学习依赖图应用于Android恶意软件分类，以及[26]，</strong>Bai等人将多视图集合用于PE恶意软件检测。虽然这些方法在某些方面与我们的方法相似，但据我们所知，我们是第一个在商业规模上使用外部上下文反馈到深层神经网络并结合文件内容特征来执行恶意软件检测多视图建模的方法。</p>
<blockquote>
<p>[25] A. Narayanan, M. Chandramohan, L. Chen, and Y. Liu, “A
multi-view context-aware approach to android malware detection and
malicious code localization,” Empirical Software Engineering, pp. 1–53,
2018.</p>
<p>[26] J. Bai and J. Wang, “Improving malware detection using
multi-view ensemble learning,” Security and Communication Networks, vol.
9, no. 17, pp. 4227–4241, 2016.</p>
</blockquote>
<h3><span id="三-实施细节">三、实施细节</span></h3>
<p>在本节中，我们将介绍我们的方法的实现细节，包括从客户端点获取PE文件和文件路径的数据收集过程、我们的特征化策略以及我们的多视图深度神经网络和比较基线的体系结构。</p>
<h4><span id="31-数据集">3.1 数据集</span></h4>
<p>在我们的实验中，我们从一家著名反恶意软件供应商的遥测数据中收集了三个不同的数据集：一个训练集、一个验证集和一个测试集。培训集由9148143个样本组成，这些样本首次出现在2018年6月1日至11月15日之间，其中693272个样本被标记为恶意样本。验证集包括在2018年11月16日至12月1日期间观察到的2225094个不同样本，其中85041个被标记为恶意样本。最后，测试集在2019年1月1日至1月30日期间共有249783个样本，其中38767个被标记为恶意。这些文件的恶意/良性标签是使用类似于[6]、[8]的标准计算的，但结合其他专有信息可以生成更准确的标签。</p>
<h4><span id="32-特征工程">3.2 特征工程</span></h4>
<p><strong>为了使用文件路径作为神经网络模型的输入，我们首先将可变长度字符串转换为固定长度的数字向量</strong>。我们使用类似于<strong>[8]</strong>的矢量化方案来实现这一点，方法是在每个字符上创建一个键控的查找表，该表用一个表示每个字符的数值（介于0和字符集大小之间）来表示。实际上，我们将此表实现为Python字典。在遥测和早期实验数据的指导下，我们将文件路径缩减到最后100个字符。短于100个字符的文件路径的功能用零填充。对于字符集，我们考虑整个Unicode字符集，但将词汇限制为150个最常见的字符。见附录？？供进一步讨论。作为PE文件内容的特征，我们使用了由四种不同特征类型组成的浮点1024维特征向量，类似于[6]。总的来说，我们将每个样本表示为两个特征向量：<strong>1024维的PE内容特征向量和100维的上下文文件路径特征向量。</strong></p>
<blockquote>
<p>[8] J. Saxe and K. Berlin, “expose: <strong>A character-level
convolutional neural network with embeddings for detecting malicious
urls, file paths and registry keys</strong>,” arXiv preprint
arXiv:1702.08568, 2017.</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304181509845.png" alt="image-20220530152922273" style="zoom: 25%;"></p>
</blockquote>
<h4><span id="33-网络体系结构">3.3 网络体系结构</span></h4>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304181509415.png" alt="image-20220528204724740" style="zoom:50%;"></p>
<p>我们的多视图体系结构如图2所示。该模型有两个输入，<strong>1024个元素的PE内容特征向量xPE和100个元素的文件路径整数向量xFP</strong>，如第III-B节所述。每个不同的输入分别通过一系列具有各自参数θPE和θFP的层，用于PE特征和FP用于文件路径特征，并在训练期间联合优化。然后将这些层的输出连接（串联）并通过一系列最终隐藏层，即参数θO的联合输出路径。网络的最终输出由密集层和sigmoid激活组成。</p>
<ul>
<li><strong>PE
特征</strong>：PE输入臂θPE使xPE通过一系列块，每个块由四层组成：一个完全连接的层，一个使用[27]中所述技术实现的层规范化层，一个丢失概率为0.05的丢失层，以及一个校正线性单元（ReLU）激活。其中五个块依次连接，密集层大小分别为1024、768、512、512和512个节点。</li>
<li><strong>文件路径</strong>：
<ul>
<li>文件路径输入arm θFP 将
xFP（<strong>长度为100的向量</strong>）传递到嵌入层 ？？？</li>
<li><strong>该嵌入层将文件路径的每个字符转换为32维向量，从而为整个文件路径生成100x32的嵌入张量</strong>。</li>
<li><strong>然后将该嵌入馈入4个单独的卷积块</strong>，其中包含一个具有128个滤波器的1D卷积层、一个层归一化层和一个1D求和层，以将输出平坦化为向量。4个卷积块包含卷积层，卷积层的大小分别为2、3、4和5，用于处理2、3、4和5克的输入文件路径。</li>
<li>然后将这些卷积块的平坦输出<strong>串联</strong>起来，作为大小为1024和512个神经元的两个密集块的输入（与PE输入臂中的形式相同）。</li>
</ul></li>
<li><strong>输出层</strong>：PE
arm和文件路径arm的完全连接块的输出随后被连接并传递到由θO参数化的联合输出路径。该路径由层大小为512、256和128的密集连接块（与PE输入arm中的形式相同）组成。然后将这些块的128D输出馈送至致密层，该致密层将输出投射至1D，然后进行sigmoid激活，以提供模型的最终输出。</li>
</ul>
<p>仅PE模型只是PE+FP模型，但没有FP臂，输入xPE并拟合θPE和θO参数。类似地，FP模型是PE+FP模型，但没有3个授权的许可PE
arm，采用输入xFP拟合θFP和θO参数。适当调整输出子网络的第一层，以匹配前一层的输出。我们使用二进制交叉熵损失函数拟合所有模型。给定标签为y的输入x的深度学习模型f（x；θ）的输出∈
{0，1}，模型参数θ损失为：</p>
<p><img src="../../../../../../Library/Application Support/typora-user-images/image-20220528171648185.png" alt="image-20220528171648185" style="zoom:50%;"></p>
<p>通过优化器，我们求解ˆθ的最佳参数集，以最小化数据集上的组合损失：</p>
<p><img src="../../../../../../Library/Application Support/typora-user-images/image-20220528171710886.png" alt="image-20220528171710886" style="zoom:50%;"></p>
<p>其中M是数据集中的样本数，y（i）和x（i）分别是第i个训练样本的标签和特征向量。我们使用Keras框架构建和训练模型，使用Adam优化器和Keras的默认参数和1024个小批量。每个模型都经过15个阶段的训练，我们确定这些阶段足以使结果收敛。</p>
<h3><span id="4-实验分析">4、实验分析</span></h3>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304181509685.png" alt="image-20220528172252766" style="zoom:50%;"></p>
<h3><span id="5-总结">5、总结</span></h3>
<p>我们已经证明，深度神经网络恶意软件检测器可以从合并来自文件路径的上下文信息中获益，即使这些信息本身不是恶意或良性的。<strong>将文件路径添加到我们的检测模型中不需要任何额外的端点检测，并且在整个相关FPR区域的总体ROC曲线中提供了统计上显著的改善</strong>。我们直接在客户端点分布上测量模型的性能这一事实表明，我们的多视图模型实际上可以部署到端点以检测恶意软件。我们在第IV-B节中进行的LIME分析表明，多视图模型能够提取暗示实际恶意/良性概念的上下文信息；不只是数据集的统计伪影，尽管正如我们所观察到的，它还可以学习这些伪影。除了端点部署之外，这项研究可以应用的另一个潜在领域是端点检测和响应（EDR）环境，在该环境中，我们的模型的输出可以用于根据事件的可疑程度对磁盘上的事件进行排序。有趣的是，石灰等技术在这方面也有应用。使用从LIME或类似方法得出的解释，可以创建分析工具，允许非恶意软件/取证专家的用户执行某种程度的威胁搜寻。如图4所示，重要性突出显示不仅对用户有用，而且是最近邻/相似性可视化方法的替代方法，该方法不会显示其他用户的潜在可识别信息（PII）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/7X1P6X/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/7X1P6X/" class="post-title-link" itemprop="url">恶意软件检测（4）【draft】You are What you Do</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-27 21:30:20" itemprop="dateCreated datePublished" datetime="2022-05-27T21:30:20+08:00">2022-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-06 16:36:44" itemprop="dateModified" datetime="2023-05-06T16:36:44+08:00">2023-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">恶意软件检测</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>173</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="youare-what-you-do-hunting-stealthy-malware-via-data-provenanceanalysis">You
Are What You Do: Hunting Stealthy Malware via Data Provenance
Analysis</span></h2>
<p>https://blog.csdn.net/ll14856lk/article/details/122151992</p>
<p>https://mzgao.blog.csdn.net/article/details/118355956</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2VH87R4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2VH87R4/" class="post-title-link" itemprop="url">深度学习-NLP（3）doc2vec（PV-DM）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-27 21:21:08" itemprop="dateCreated datePublished" datetime="2022-05-27T21:21:08+08:00">2022-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-12 16:38:06" itemprop="dateModified" datetime="2022-07-12T16:38:06+08:00">2022-07-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">【draft】深度学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95/%E3%80%90draft%E3%80%91%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/" itemprop="url" rel="index"><span itemprop="name">NLP</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="doc2vec">Doc2Vec</span></h2>
<blockquote>
<p>论文｜Doc2vec的算法原理、代码实现及应用启发 - Thinkgamer的文章 - 知乎
https://zhuanlan.zhihu.com/p/336921474</p>
</blockquote>
<p>Doc2vec主要为了解决word2vec只包含局部窗口内的语义信息的问题，在进行词向量表示的时候融入了句子的语义表示。</p>
<p><strong>Doc2vec其实包含了两种算法：</strong></p>
<ul>
<li>PV-DM（Distributed Memory Model of Paragraph
Vector）:PV-DM类似于Word2vec中的CBOW模型</li>
<li>PV-DBOW（Distributed Bag of Words version of Paragraph Vector）</li>
</ul>
<h4><span id="原理">原理</span></h4>
<p><strong>doc2vec与word2vec的不同点</strong>：在输入层增加了Paragraph
id向量，来作为句子的表示向量，该向量在<strong>同一句子的不同词训练</strong>中是<strong>权值共享</strong>的</p>
<p><strong>原因</strong>：在word2vec训练中，<strong>每次只会选择句子中窗口内的词来进行训练学习当前词的向量表达，而忽略了窗口外的词，最终的句子向量也只是每个词的简单累加，</strong>加入Paragraph
id向量在同一个句子的若干次训练中是共享的，所以同一句话会有多次训练，每次训练中输入都包含Paragraph
vector，它可以被看作是句子的主旨，这样训练在获得词向量的同时也能获得准确的句子向量表示。</p>
<p><img src="/Users/apple/Library/Application Support/typora-user-images/image-20220712163125902.png" alt="image-20220712163125902" style="zoom:50%;"></p>
<p><strong>PV-DM模型的输入是固定长度的，其从段落的上下文的滑动窗口中进行采样，这一点和Word2vec是一致的，在基于同一段落构造好的样本中，
段落的向量是共享的，但是在基于不同段落构造好的样本中，段落的向量是不共享的。在所有的样本中，word的向量是一致的（共享的）。</strong></p>
<p>在整个训练过程中，paragraph vector能够记忆整个句子的意义，word
vector则能够基于全局部分学习到其具体的含义。</p>
<h4><span id="训练">训练</span></h4>
<p>每次从一句话中滑动采样固定长度的词，取其中一个词作预测词，其他的作输入词。<strong>输入词对应的词向量word
vector和本句话对应的句子向量Paragraph
vector作为输入层的输入</strong>，将本句话的向量和本次采样的词向量相加求平均或者累加构成一个新的向量X，进而使用这个向量X预测此次窗口内的预测词（softmax）。</p>
<h4><span id="预测">预测</span></h4>
<p>首先将新句子对应的Paragraph
vector随机初始化，<strong>固定词向量还有投影层到输出层的softmax
weights参数</strong>，对句子中的单词进行预测，根据结果<strong>进行Paragraph
vector更新</strong>，获得最终的Paragraph vector。利用最终Paragraph
vector进行词向量预测。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/3403A74/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3403A74/" class="post-title-link" itemprop="url">恶意软件检测（3）Living-Off-The-Land 恶意软件系统分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-27 20:58:44" itemprop="dateCreated datePublished" datetime="2022-05-27T20:58:44+08:00">2022-05-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:49:25" itemprop="dateModified" datetime="2023-04-19T15:49:25+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">恶意软件检测</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="living-off-the-land恶意软件系统分析">Living-Off-The-Land
恶意软件系统分析</span></h2>
<blockquote>
<p>[][AI安全论文] <strong>1、<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg&amp;mid=2247496069&amp;idx=1&amp;sn=f5aecaae5494b900b29f12078a2d632e&amp;chksm=cfcf4148f8b8c85ee56fbab09252bb4dc90f936cfb6decaa860b5e91457c9838cfb35179041a&amp;scene=178&amp;cur_album_id=1776483007625822210#rd">21.S&amp;P21
Survivalism经典离地攻击（Living-Off-The-Land）恶意软件系统分析</a>:S&amp;P21的离地攻击（Living-Off-The-Land）系统分析，这是一篇非常经典的论文，并且系统性分析文章是另一种讲故事的方式。</strong></p>
<p>2、2021 RAID <strong>Living-Off-The-Land Command Detection Using
Active
Learning</strong>：https://dl.acm.org/doi/pdf/10.1145/3471621.3471858</p>
</blockquote>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548226.png" alt="图片" style="zoom:67%;"></p>
<blockquote>
<p>原文作者：Frederick Barr-Smith, Xabier Ugarte-Pedrero, et al.
<strong>原文标题</strong>：Survivalism: Systematic Analysis of Windows
Malware Living-Off-The-Land
<strong>原文链接</strong>：https://ieeexplore.ieee.org/document/9519480
<strong>发表会议</strong>：2021 IEEE Symposium on Security and Privacy
(SP)</p>
</blockquote>
<p><strong>文章目录：</strong></p>
<ul>
<li><p><strong>摘要</strong></p></li>
<li><p><strong>一.引言</strong></p>
<p>1.什么是离地攻击</p>
<p>2.APT中的离地攻击</p>
<p>3.提出五个关键问题</p>
<p>4.贡献（Contribution）</p></li>
<li><p><strong>二.背景和相关工作</strong></p>
<p>A.LotL Binaries</p>
<p>B.Scope of our Study</p>
<p>C.Related Work</p></li>
<li><p><strong>三.MOTIVATION: 杀毒软件产品 vs
离地攻击技术</strong></p></li>
<li><p><strong>四.离地攻击流行性评估</strong></p>
<p>A.Dataset Composition</p>
<p>B.Analysis Pipeline</p>
<p>C.LotL Technique Identification</p>
<p>D.Parameter Analysis to Identify Execution Purpose</p></li>
<li><p><strong>五.评估结果</strong></p>
<p>A.商用恶意软件中LotL技术的流行性（Prevalence）</p>
<p>B.Comparison of Benign and Malicious Samples</p>
<p>C.Prevalence of LotL techniques in APT Malware</p></li>
<li><p><strong>六.案例分析</strong></p></li>
<li><p><strong>七.要点和讨论</strong></p></li>
<li><p><strong>八.局限性和未来工作</strong></p></li>
<li><p><strong>九.个人感受</strong></p></li>
</ul>
<h3><span id="摘要">摘要</span></h3>
<p>随着恶意软件检测算法和方法变得越来越复杂（sophisticated），恶意软件作者也采用（adopt）同样复杂的逃避机制（evasion
mechansims）来对抗（defeat）它们。<strong>民间证据表明离地攻击技术（Living-Off-The-Land，LotL）是许多恶意软件攻击中最主要的逃避技术之一。这些技术利用（leverage）系统中已经存在的二进制文件来执行（conduct）恶意操作。</strong>基于此，我们首次对Windows系统上使用这些技术的恶意软件进行大规模系统地调查。</p>
<p>在本文中，我们分析了这些本地系统的二进制文件在多个恶意软件数据集上的使用情况，这些数据集共包含31,805,549个样本。我们发现平均流行率（prevalence）为9.41%。实验结果表明，LotL技术被大量的使用，特别是在高级持久性威胁（Advanced
Persistent Threat
，APT）恶意软件样本中，离地攻击占比为26.26%，是社区恶意软件的两倍多。</p>
<p><strong>为了验证（illustrate）LotL技术的逃逸潜力，我们在本地沙箱环境（sandboxed
environment）中对几个完全打补丁的Windows系统进行了离地攻击技术的测试，其结果表明在10个最流行的反病毒产品（anti-virus）中存在明显的gap。</strong></p>
<h3><span id="一-引言">一、引言</span></h3>
<h4><span id="11-什么是离地攻击">1.1 什么是离地攻击</span></h4>
<p>恶意软件开发和检测是猫和老鼠的游戏，恶意软件作者不断开发新技术来绕过（bypass）检测系统。像AV杀毒软件（anti-virus）这样的安全产品通过静态和启发式分析（heuristic
analysis）技术，以检测、分类和防止恶意软件有效执行。</p>
<p>在过去，许多解决方案严重依赖于基于签名的检测，但不幸的是，由于使用了<strong>多态性（polymorphism）和加壳程序（packers）</strong>，这些方法变得不再那么有效。相反，许多产品开始开发启发式分析解决方案，包括检测恶意行为的算法。这些算法已成为AV引擎的重要组成部分。随着时间的推移，这些算法越来越复杂，因此需要更多创新性的逃避技术。</p>
<p>恶意软件作者和红队经常研究和发现新方法来绕过安全解决方案。虽然它们的潜在目标本质上可能有所不同，但这两种类型的攻击者通常都利用（leverage）最先进（state-of-the-art）的逃避技术来实现目标。<strong>从防守者的角度来看，为了及时作出响应，了解这些攻击和研究它们的趋势是至关重要的（crucial）</strong>。其中，在红队和恶意软件作者中都流行的规避策略就是使用离地攻击（LotL）技术。</p>
<p><strong>离地攻击（LotL）技术是指使用系统中已经存在或易于安装的二进制文件（如已签名的合法管理工具）来执行后渗透活动（post-exploitation
activity）。</strong></p>
<ul>
<li>通过利用这些工具，攻击者可以<strong>实现注册表修改、持久化、网络或系统侦察，或执行其他恶意代码</strong>。它们甚至可以用来减少由恶意活动产生的事件日志，而不需要将其他文件下载到本地的系统中。</li>
</ul>
<h4><span id="12-apt中的离地攻击">1.2 APT中的离地攻击</span></h4>
<p>离地攻击并不是隐蔽的技术，它们在互联网上公开记录着。许多开源的攻击安全工具利用了LotL技术，并且经常被攻击者所使用，从合法的红队到业余的网络攻击者，以及有组织的APT团队。</p>
<ul>
<li><code>PoshSpy[15]</code>：是一个俄罗斯APT29攻击模块，它是第一个被检测到的APT组织使用的LotL技术，特别是在PowerShell和Windows
Management中。</li>
<li>伊朗威胁组织[1]、APT33、APT34和其他组织也以使用本地Windows二进制文件和其它签名工具而闻名，特别是PowerShell[8]。</li>
</ul>
<p>尽管“离地攻击”在信息安全界是一个相对知名的术语，但有时很难找到一个精确的定义。此外，据我们所知，没有任何研究包含了对LotL技术在恶意软件样本中的流行程度的系统分析。关于LotL技术的文档大多以博客的形式出现，并记录着某些恶意软件家族的在野发现，或者攻击者在远程访问受损系统中所使用技术的描述。</p>
<ul>
<li>例如，<code>Emotet</code> 和
<code>Trickbot</code>，两个最常见的远程访问木马（Remote Access
Trojans，RAT），据称是使用链接的LotL二进制文件来实现持久化。</li>
<li>作为一种对策，微软描述了对抗使用LotL技术商用RAT的基本步骤。高度逃逸的远程访问木马
<code>Astaroth</code>，<code>TA505</code>
组织的一些恶意软件库，<code>Dexphot cryptominer</code> 和
<code>Nodersok</code> 同期使用的多个LotL二进制文件。</li>
</ul>
<h4><span id="13-提出5个关键性问题">1.3 提出5个关键性问题</span></h4>
<p>在本文中，我们分析了LotL现象，即商用恶意软件中与离地攻击二进制文件利用相关的文件。我们首先描述了什么是LotL
binary以及它如何被恶意软件利用来实施恶意行为的。</p>
<p>本文的研究重点是以Windows为主导的操作系统下流行且恶意软件最常针对的目标。<strong>许多基于离地攻击的AV逃逸行为已被记录下来。因此（As
a
consequence），安全界很大程度上认为，LotL技术（如代理执行恶意软件）实际上对安全解决方案是有效的。</strong></p>
<p>首先，我们提出了第一个假设以及第一个研究问题：</p>
<blockquote>
<p>#### <strong>问题1：Can LotL techniques effectively evade commercial
AV?</strong></p>
<p>#### LotL技术能有效地逃避目前大部分安全厂商的杀毒软件检测吗？</p>
</blockquote>
<p>为了回答这个问题，我们评估了一组具有代表性的安全产品，并展示了其中的一些技术，虽然这是攻击者和防御者所熟知的，但仍然是绕过安全解决方案的有效方法，因此对安全行业来说这仍是一个开放的挑战。</p>
<p><strong>事实上，LotL二进制文件经常被系统管理员和高级计算机用户使用来执行（perform）系统管理任务，这使得即使是对于训练有素的分析人员来说，区分（distinguish）合法行为和恶意行为也非常困难</strong>。我们负责任地向受影响的供应商披露了我们的发现并进行跟进，因此提高了他们的检测能力。</p>
<p>尽管现有的文档提供了这些技术使用的可靠证据，但仍然不清楚这种现象在恶意软件样本中有多普遍。因此（In
this way），我们就提出了第二个研究问题：</p>
<blockquote>
<p>#### <strong>问题2：How prevalent is the use of LotL binaries in
malware?</strong></p>
<p>#### 在恶意软件中使用LotL二进制文件的情况有多普遍？</p>
</blockquote>
<p>在此基础上，我们试图阐明当前威胁情景中的一些趋势，以确定（identify）：</p>
<blockquote>
<p>#### <strong>问题3：What purposes do malware binaries use LotL
techniques for?</strong></p>
<p>#### 恶意软件的二进制文件使用LotL技术的目的是什么？</p>
<p>#### <strong>问题4：Which malware families and types use LotL
binaries most prolifically and how does their usage differ?</strong></p>
<p>####
哪些恶意软件家族和类型使用LotL二进制文件最多，它们的使用情况又有何不同？</p>
</blockquote>
<p>此外，我们还调查（investigate）了为什么这些技术难以检测。部分杀毒软件公司参与了我们的披露，即将恶意攻击与系统管理员执行完全合法的管理任务区分开来是困难的。这就给我们带来了另一个问题：</p>
<blockquote>
<p><strong>问题5：What are the overlaps and differences in the behavior
of legitimate and malicious binaries with respect to the usage of LotL
binaries? How would this affect detection by heuristic AV
engines?</strong></p>
<p>####
在使用LotL二进制文件方面，合法和恶意二进制文件的行为有哪些重叠和差异呢？这将如何影响启发式AV引擎的检测呢？</p>
</blockquote>
<p>虽然恶意样本和良性样本之间的LotL二进制使用频率（prevalence）有一些明显的差异，但我们也注意到一些类别存在某些相似性，如<strong>代理执行（proxied
execution）</strong>。</p>
<p>最后，<strong>我们将注意力集中在高逃逸和高级持续威胁的恶意软件上，我们发现它利用离地攻击技术是商用恶意软件的两倍</strong>。在表1中列出了一些使用LotL技术进行攻击的APT组织。</p>
<h4><span id="14-贡献">1.4 贡献</span></h4>
<p>据我们所知，本文提出了迄今为止对商用和APT恶意软件使用LotL技术最大规模的系统分析。本文的核心（core
）贡献：</p>
<ul>
<li>我们通过测试一组最流行的AV引擎来对抗基于LotL技术部署的恶意载荷，以评估LotL技术的可行性，并展示了离地攻击检测的复杂性对行业仍是一个挑战。<strong>即使在披露9个月后，这些技术仍没有被发现</strong>。</li>
<li>我们对代表现代商用恶意软件的几个数据集进行了大规模的评估，并确定了LotL技术的流行程度，以及在不同恶意软件家族和类型之间的差异。我们还评估了LotL技术由于假阳性风险可能对行业产生的影响。</li>
<li>我们评估了一个APT恶意软件数据集，并将其公开以促进（facilitate）后续的研究，并确定它执行LotL技术的频率是商用恶意软件的两倍。此外，我们还确定了哪些APT组织最多地使用LotL技术。</li>
</ul>
<h3><span id="二-背景和相关工作">二、背景和相关工作</span></h3>
<p>我们首先定义LotL二进制文件，并枚举恶意软件使用这些二进制文件的目的。</p>
<h4><span id="21-lotl-binaries">2.1 LotL Binaries</span></h4>
<p>近年来，“<code>Living-Off-The-Land binary（LOLbin）</code>”已经成为一个常用词，用来指在网络攻击中广泛使用的二进制文件。历史上，“Living-Off-The-Land”一直被用来表示可以为农业或狩猎提供喂养土地或离地的概念。<strong>转换为恶意软件和入侵领域，攻击者可能利用那些已经可以使用的文件（即系统上已经存在或易于安装的）来发起攻击并躲避检测。</strong></p>
<p>在本文中，我们将LotL二进制定义为：</p>
<ul>
<li><strong>任何具有公认合法用途的二进制文件，在攻击期间利用它直接执行恶意行为，或间接协助一系列恶意行动，从而达到恶意结果。</strong></li>
</ul>
<blockquote>
<p>In this paper, we define a LotL binary as any binary with a
recognised legitimate use, that is leveraged during an attack to
directly perform a malicious action; or to assist indirectly, in a
sequence of actions that have a final malicious outcome.</p>
</blockquote>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548420.png" alt="图片" style="zoom:50%;"></p>
<h4><span id="举例">举例：</span></h4>
<ul>
<li>在Windows系统上默认安装的二进制文件（binaries installed），如
<code>Reg.exe</code> 、<code>Sc.exe</code> 和 <code>Wmic.exe</code>
是最常被恶意软件执行的文件。</li>
<li>大多数默认安装的二进制文件都是由微软认证码签名的。认证码签名证明二进制文件没有在编译中被篡改或修改，这些二进制文件甚至可能被列为白名单。<strong>利用可信的LotL二进制文件的恶意软件可能因此避开杀毒软件</strong>。在Windows系统上使用系统二进制文件可以作为恶意软件操作的一部分，更重要的是，许多LotL技术使用系统二进制文件来实现这些二进制文件的目的。</li>
<li>此外，可以使用外部签名二进制文件（external signed binaries），如
<code>PsExec.exe</code>
或其他系统内部二进制文件。虽然它们使用频率不高，但本文的分析也囊括了这些文件。<strong>如APT组织在
<code>SoftCell</code> 和 <code>Havex</code> 中都使用
<code>PsExec.exe</code>
来秘密执行远程命令，从而实现网络中的横向移动。</strong></li>
<li>某些罕见情况，脆弱的（已签名）驱动程序被用来升级系统上的权限。这是
<code>RobbinHood</code> 勒索软件和各种 <code>APT wiper</code>
恶意软件样本所使用的一种技术，针对 <code>Saudi Arabian</code> 系统，包括
<code>Dustman</code> 、<code>Shamoon</code> 和
<code>Zerocleare</code>。</li>
</ul>
<h4><span id="可追溯性traceability"><strong>可追溯性（Traceability）：</strong></span></h4>
<ul>
<li>某些LotL二进制文件可能会比其他文件留下更多的系统日志，安全工具或取证分析人员可以利用这些日志来检测恶意操作。<strong>例如，可以将Powershell配置为具有全面的日志记录</strong>。</li>
<li>微软甚至建议<strong>阻止在系统上执行一些本机的二进制文件</strong>，除非有充分的理由。</li>
</ul>
<h4><span id="22-scope-of-our-study">2.2 Scope of our Study</span></h4>
<p>在本文中，我们关注的是Windows恶意软件执行系统二进制文件的目的。这些目的通常包括沿着
<strong>kill
chain</strong>的进展或逃避AV的检测。所有这些技术都被部署在系统的用户空间中。</p>
<p><code>hollowing</code> 和 <code>injection（注入）</code>
不在我们的研究范围内，尽管这是无文件恶意软件部署的常见技术。因为根据我们早期的定义，它们不是LotL技术。</p>
<h4><span id="23-related-work">2.3 Related Work</span></h4>
<blockquote>
<p>离地攻击相关工作较少，并且都非常经典，因此下面罗列了详细的相关研究，仅供自己后续深入，也希望对您有所帮助。</p>
</blockquote>
<ul>
<li>LotL恶意软件及其别名，“advanced volatile
threat”或“无文件”恶意软件在当前的学术文献中很少被提及。这主要受限于介绍分析少或描述为一个新兴的高逃逸恶意软件变体。</li>
<li>Li等[31]对恶意PowerShell脚本进行了分析，其中有一个小节专门描述了LotL攻击和无文件攻击作为近年来网络攻击的趋势。（<strong>作者第17篇博客详细介绍过PS经典</strong>）</li>
<li>Wang等[72]最近发表的一篇关于数据来源分析的论文指出，Living-Off-The-Land
是一种新兴的、突出的逃避型恶意软件子类（evasive malware
subtype）。（<strong>经典的You Are What You
Do后续即将分享</strong>）</li>
<li>先前的工作[64]进行了介绍性分析，然而LotL恶意软件还没有受到详细的学术分析。（An
emerging threat Fileless malware: a survey and research
challenges）</li>
<li><strong>赛门铁克</strong>[73,66]和<strong>思科Talos</strong>的[65]白皮书介绍了这个主题，并对多个数据集的流行性进行了分析。目前，没有论文对包含多个使用LotL技术的Windows恶意软件数据集进行大规模地系统分析。（<strong>经典</strong>）
<ul>
<li>https://www.symantec.com/content/dam/symantec/docs/security-center/white-papers/istr-living-off-the-land-and-fileless-attack-techniques-en.pdf</li>
<li>https://www.symantec.com/content/dam/symantec/docs/white-papers/living-off-the-land-turning-your-infrastructure-against-you-en.pdf</li>
<li>https://blog.talosintelligence.com/2019/11/hunting-for-lolbins.html</li>
</ul></li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548029.png" alt="图片" style="zoom:50%;"></p>
<p>在一些论文中提到了LotL技术，强调了高隐蔽（stealthiness）和APT恶意软件曾使用。</p>
<ul>
<li><p>在一篇关于恶意软件分析工具Yara的论文中，Cohen[9]将LotL描述 “ LotL
as a trend that has been recently observed in the tactics used by elite
threat actors”，我们的分析结果进一步证实了该说法。</p></li>
<li><p>Hassan等[21]的研究表明，APT恶意软件使用LotL攻击策略来实现持续攻击并分析了两个活动，他们的工作还利用了MITRE
ATT&amp;CK框架[45]，通过MITRE定义了一个描述和分类知名攻击的分类方法。<strong>许多LotL技术在MITRE
ATT&amp;CK框架内被索引</strong>。Mitre公司及其常见CVE漏洞是安全领域的既定权威，他们囊括并描述许多LotL技术，这样表明离地攻击是一个值得深入分析的课题。</p></li>
<li><ul>
<li><strong>W. U. Hassan, A. Bates, and D. Marino, “Tactical Provenance
Analysis for Endpoint Detection and Response Systems,” IEEE Symposium on
Security and Privacy, 2020.</strong></li>
</ul></li>
</ul>
<p><strong>强烈推荐一个包含LotL二进制和ATT&amp;CK功能映射的资源</strong>：</p>
<ul>
<li>https://github.com/LOLBAS-Project/LOLBAS</li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548854.png" alt="图片" style="zoom:50%;"></p>
<p>与我们研究相关的是对基于脚本的恶意软件分析和去混淆。使用LotL技术的恶意软件经常使用恶意脚本作为有效负载。（<strong>下列论文在作者第16篇PowerShell总结博客中详细介绍过</strong>）</p>
<ul>
<li>Ugarte等[67]通过识别可疑行为模式，测试了经
<code>Powershell.exe</code> 二进制调用的恶意脚本。</li>
<li><strong>Rubin等[61]将机器学习应用于检测PowerShell恶意软件（微软团队）</strong>。</li>
<li>Curtsinger[11]等人提出了恶意Javascript攻击的检测机制——ZOZZLE。</li>
</ul>
<p><strong>虽然这些论文提出了有效的检测方法，但是他们都是为狭隘的恶意载荷（payload）所用，他们没有分析更广泛的恶意软件生态系统和这些有效载荷是如何被LotL二进制文件触发的。</strong></p>
<h3><span id="三-动机">三、动机</span></h3>
<p><strong>安全研究人员已经记录了许多使用LotL技术成功躲避安全产品的案例</strong>。在许多情况下，这些<strong>LotL二进制文件被用来代理恶意载荷的执行，使其在一个合法的进程上下文中执行，或者作为一个合法系统进程的子进程生成一个新进程</strong>。在某些情况下，这些有效载荷作为LotL二进制调用的副作用被执行，而在其他情况下，它只是其主要记录行为的结果。此外，许多杀毒产品未能正确检测到这些技术。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548198.png" alt="图片" style="zoom:50%;"></p>
<p><strong>为了回答第一个问题，我们首先分析了当前AV产品是否将LotL技术作为恶意行为的指标。</strong></p>
<p>为此，我们首先选择了10个具有代表性的AV产品（详见附录C），并利用常见<strong>基于LotL的代理执行技术来实施反弹Shell的模拟攻击</strong>。此外，本研究的目的不是测试任何特定AV产品的检测能力或将它们相互比较，而是确定是否存在普遍的检测差距。</p>
<ul>
<li>实验在联网的Windows
10虚拟机执行，并将最新的本地AV产品连接到它们的云组件。</li>
<li>利用一个反弹Shell来评估AV系统在部署LotL技术的恶意软件中有多脆弱。本文认为能够允许远程执行命令的reverse
shell是成功执行代码的证明，这与许多远程访问木马（RAT）功能相同。</li>
<li>通过从不同LotL二进制文件中运行这个反弹shell来进行实验，以测试AV产品是否检测到离地攻击技术是恶意的。</li>
<li>我们在必要时混淆了反弹shell的有效载荷，并使用各种有效载荷类型来测试AV检测传递机制本身的能力，而不是通过静态签名传递的特定有效载荷（详见附录D）。</li>
</ul>
<h4><span id="实验结果如表2所示">实验结果如表2所示：</span></h4>
<ul>
<li><strong>可以发现大部分的AV引擎允许我们建立一个反弹Shell并执行命令，它们并没有检测出利用LotL技术的恶意软件，60个中只检测出4个。</strong></li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191549745.png" alt="图片" style="zoom:50%;"></p>
<h4><span id="负责任的披露和回应">负责任的披露和回应：</span></h4>
<p>此后，我们向相关的AV供应商发布了一份文件，包含我们检查的结果并协助补救。9个月后，我们在Windows
10机器上重复了类似的测试，这允许我们测试AV供应商是否在他们的产品中包含了新的启发式规则来检测LotL二进制的使用。其结果如下：</p>
<ul>
<li><strong>可以发现在60个相同的有效载荷中检测到了25个</strong></li>
<li>在检测到的反弹shell测试中，我们修改了载荷（利用混淆或运行不同的载荷），同时为LotL二进制文件保持了完全相同的命令行参数，通过利用这些混淆和修改的有效载荷，我们成功地在这25个被拦截的实例中的19个执行了一个反向shell。</li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191549539.png" alt="图片" style="zoom:50%;"></p>
<p><strong>实验结果表明，LotL技术仍然是杀毒软件供应商面临的一个重大挑战。合法用户通常以不可预知的方式使用这些工具，而安全公司很难在没有误报的情况下部署有效的检测策略。</strong></p>
<p>接下来将展示这些技术如何在商用恶意软件中是普遍存在的，以及离地攻击是不应该被安全社区忽视的问题。</p>
<h3><span id="四-离地攻击流行性评估">四、离地攻击流行性评估</span></h3>
<p>在本节中，我们测量了恶意软件中LotL技术的流行程度，并试图回答所提出的研究问题。</p>
<h4><span id="41-数据集描述">4.1 数据集描述</span></h4>
<p>评估工作是在9个独立的子数据集上进行的。我们总共收集了31,805,549个样本，其中我们从VirusTotal（VT）中获得了16,048,202份行为报告。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191549136.png" alt="图片" style="zoom:50%;"></p>
<p><strong>Public Datasets</strong></p>
<p>公共恶意软件数据集，包括商用恶意软件、VirusShare语料库的二进制文件、窗口恶意PE文件、佐治亚理工学院发布的可执行文件、VX-Mumbal和MalShare共享的样本（两个重点的共有数据集）。</p>
<ul>
<li>https://impactcybertrust.org/dataset{ }view?idDataset=1143</li>
<li>https://vx-underground.org/samples.html</li>
<li>https://malshare.com</li>
</ul>
<p><strong>VirusTotal Balanced Dataset</strong></p>
<p>从VT中收集了237,288个hash值，利用 <code>AVClass</code>
预处理代码和打标签（家族分类），并平衡数据集中每个族。</p>
<p><strong>APT Malware</strong></p>
<p>我们根据一种类似于数据集论文dAPTaset[59]的方法收集了一个APT恶意软件的数据集。我们处理了HTML页面和pdf文件（<code>APTnotes</code>），并提取了这些文件中包含的所有恶意软件的hash值。</p>
<ul>
<li>https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-rezaeirad.pdf</li>
<li>https://github.com/aptnotes/data</li>
</ul>
<p><strong>Yara Rule Match Malware</strong></p>
<p>部署3个Yara规则来检测LotL二进制文件，并使用Livehunte来识别上传到VT的新的恶意软件hash，并使用LotL技术匹配恶意软件的行为特征。</p>
<h4><span id="42-analysis-pipeline">4.2 Analysis Pipeline</span></h4>
<p>当收集了由Windows
PE二进制文件组成的不同数据集，我们就分析样本的行为。包括三个阶段：</p>
<ul>
<li>data collection</li>
<li>data augmentation</li>
<li>data analysis</li>
</ul>
<blockquote>
<p>First Seen：首次发现病毒样本的时间戳 AVClass
Family：某恶意软件样本所属家族 <strong>Behavioural
Report：恶意行为报告，由特定恶意软件样本执行的进程和Shell命令的列表</strong></p>
</blockquote>
<h4><span id="43-lotl-techniqueidentification">4.3 LotL Technique
Identification</span></h4>
<p><strong>数据准备就绪，那么如何识别是否使用了LotL技术呢？</strong></p>
<p>我们使用<strong>模式匹配</strong>来识别恶意软件执行过程中对LotL二进制文件调用的情况，从而处理所有收集到的行为报告（<code>behavioural reports</code>）。行为报告包括两个指标：</p>
<ul>
<li><p><strong>Shell Commands（Shell命令）</strong></p>
<p><strong>恶意二进制文件在主机操作系统中执行的Shell命令</strong>，Shell命令日志可以通过引用系统二进制文件的绝对路径来显示它的执行情况。<strong>同时，Windows的命令提示符还包括许多别名，例如Reg.exe的reg</strong>。</p></li>
<li><p><strong>Processes（进程）</strong></p>
<p><strong>进程日志明确由恶意软件样本执行的系统二进制文件</strong>。执行的参数也包含在行为报告中的进程日志中。</p></li>
</ul>
<p>在我们的分析中，如果一个样本的行为报告包含至少一个LotL二进制文件的执行，那么它使用了LotL技术。<strong>我们记录了每一个LotL的执行及其参数细节，并将它们插入到数据库中。然后，我们分析了这些恶意软件样本的参数，以确定每个数据集中最常见的参数类型和执行目的。</strong></p>
<p>具体而言，我们确定了这两种独立类型的二进制文件：</p>
<ul>
<li><strong>Default System Binaries</strong></li>
<li><strong>Installed Signed Binaries</strong></li>
</ul>
<p>模式匹配优化：模式匹配方法在不断改进，直到所有识别的LotL命令被正确分类和映射到执行目的，并进行了数据清洗处理。</p>
<ul>
<li>不带参数的二进制执行移除</li>
<li>沙箱产物删除（如Explorer.exe和sha256），Web访问不处理</li>
<li>删除Verclsid.exe的实例</li>
</ul>
<h4><span id="44-parameteranalysis-to-identify-execution-purpose">4.4 Parameter
Analysis to Identify Execution Purpose</span></h4>
<p><strong>为了确定LotL技术的执行目的，我们观察了恶意软件样本提供的参数。</strong></p>
<p>图1说明了四个进程执行的映射。该映射通过识别单独的执行目的来在所有数据集上实施，<strong>例如执行Net.exe时使用stop参数表示任务停止。在将单个命令映射到执行目的之后，我们将为该二进制文件选择所有匹配的执行</strong>。我们在所有系统二进制执行中重复该步骤，直到每次执行被分类为属于特定的执行目的或被错误分类。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191549986.png" alt="图片" style="zoom:50%;"></p>
<p>按照这种方法，我们按目的将参数分为9个独立的类别。</p>
<p><strong>首先是三种与执行有关的类型：</strong></p>
<ul>
<li><strong>Proxied
Execution</strong>：代理执行，如Mshta.exe执行.hta文件，Rundll32.exe执行.dll文件</li>
<li><strong>Persistence</strong>：持久化：如果恶意代码配置或修改系统以在未来某个时间点执行命令或存储的作业，那么它就实现了持久性，比如Sc.exe带有创建参数的Bitsadmin.exe，或带有日期时间参数的Schtasks.exe/At.exe</li>
<li><strong>Delayed Execution</strong>：延迟执行，比如
Ping.exe执行-n</li>
</ul>
<p><strong>接着是三类与底层系统组件的修改有关。恶意软件通常从事这种行为，以便在机器上对目标进行进一步的传播或行动。</strong></p>
<ul>
<li><strong>Firewall Modification</strong>：防火墙修改，如Netsh.exe</li>
<li><strong>Registry Modification</strong>：注册表修改，如Reg.exe</li>
<li><strong>Permissions
Modification</strong>：权限修改，如Cacls.exe修改文件权限</li>
</ul>
<p><strong>最后是与执行或系统修改无关的三类。</strong></p>
<ul>
<li><strong>File Opening</strong>：打开文件，如Explorer.exe</li>
<li><strong>Reconnaissance</strong>：侦察，触发本地或远程配置的横向移动，如Net.exe</li>
<li><strong>Task
Stopping</strong>：使用LotL二进制文件秘密停止另一个进程或服务，如Taskkill.exe</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/NFRYYZ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/NFRYYZ/" class="post-title-link" itemprop="url">恶意软件检测（2）Dynamic Malware Analysis with Feature Engineering and Feature Learning</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-26 16:04:26" itemprop="dateCreated datePublished" datetime="2022-05-26T16:04:26+08:00">2022-05-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:52:32" itemprop="dateModified" datetime="2023-04-19T15:52:32+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/" itemprop="url" rel="index"><span itemprop="name">【draft】应用</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E3%80%90draft%E3%80%91%E5%BA%94%E7%94%A8/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E6%A3%80%E6%B5%8B/" itemprop="url" rel="index"><span itemprop="name">恶意软件检测</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="dynamicmalware-analysis-with-feature-engineering-and-feature-learning">Dynamic
Malware Analysis with Feature Engineering and Feature Learning</span></h2>
<ul>
<li>项目：https://github.com/joddiy/DynamicMalwareAnalysis</li>
<li>文章：https://arxiv.org/abs/1907.07352</li>
</ul>
<h3><span id="摘要">摘要</span></h3>
<p>动态恶意软件分析在隔离的环境中执行程序，并监控其运行时行为（如系统<strong>API调用</strong>），以检测恶意软件。该技术已被证明对各种代码混淆技术和新发布的（“零日”）恶意软件有效。然而，现有的工作通常<strong>只考虑API名称而忽略参数</strong>，<strong>或者需要复杂的特征工程操作和专家知识来处理参数</strong>。在本文中，我们<strong>提出了一种新的、低成本的特征提取方法，以及一种有效的深度神经网络体系结构，用于准确、快速地检测恶意软件</strong>。具体而言，<strong>特征表示方法利用特征哈希技巧对与API名称关联的API调用参数进行编码</strong>。深度神经网络体系结构应用多个选通CNN（卷积神经网络）来转换每个API调用的提取特征。通过双向LSTM（长-短期内存网络）进一步处理输出，以<strong>了解API调用之间的顺序相关性</strong>。实验表明，我们的解决方案在大型真实数据集上的性能明显优于基线。从烧蚀研究中获得了有关特征工程和建筑设计的宝贵见解。</p>
<h3><span id="一-说明">一、说明</span></h3>
<p>网络安全给全世界带来了巨大的经济成本。美国政府的一份报告（CEA
2018）估计，2016年美国经济中恶意网络活动的成本在570亿美元至1090亿美元之间。恶意软件（或恶意软件）是快速发展的主要网络安全威胁之一。据报道，每年发现超过1.2亿个新的恶意软件样本（AV-TEST
2017）。因此，开发恶意软件检测技术是迫切而必要的。</p>
<p>数十年来，研究人员一直致力于恶意软件检测。主流解决方案包括静态分析和动态分析。静态分析方法扫描软件的二进制字节流以创建签名，如可打印字符串、n-gram、指令等（Kruegel等人，2005）。然而，基于签名的静态分析可能容易受到代码混淆的影响（Rhode、Burnap和Jones，2018；Gibert等人，2018），或者不足以检测新的（“zeroday”）恶意软件（Vinod等人，2009）。相反，动态分析算法在隔离的环境（例如沙盒）中执行每个软件，以收集其运行时行为信息。通过使用行为信息，动态分析的检测率更高，比静态分析更稳健（Damodaran
et al.2017）。在本文中，我们主要关注动态分析。</p>
<p>在行为信息中，<strong>系统API调用序列</strong>是最常用的数据源，因为它捕获了软件执行的所有操作（包括<strong>网络访问、文件操作等</strong>）。序列中的每个API调用都包含两个重要部分，即<strong>API名称和参数</strong>。每个API可能有零个或多个参数，每个参数都表示为<strong>名称-值对</strong>。为了处理行为信息，提出了许多特征工程方法。例如，如果我们将API名称视为一个字符串，则可以提取最多N个（例如1000个）频繁的N-gram特征（N=1，2.....)
从序列中。然而，从异构类型的参数（包括字符串、整数、地址等）中提取特征并非易事。最近，研究人员将深度学习模型应用于动态分析。卷积神经网络（CNN）和递归神经网络（RNN）等深度学习模型可以直接从序列数据中学习特征，而无需进行特征工程。尽管如此，计算机视觉和自然语言处理等传统深度学习应用程序的数据是同质的，例如图像（或文本）。<strong>使用深度学习模型处理异构API参数仍然具有挑战性</strong>。因此，大多数现有方法都忽略了这些参数。有几种利用API参数的方法（Tian
et al.2010；Fang et al.2017；Agrawal et
al.2018）。然而，这些方法要么将所有参数视为字符串（Tian et
al.2010；Agrawal et al.2018），要么只考虑参数的统计信息（Ahmed et
al.2009；Tian et al.2010；Islam et
al.2013）。因此，<strong>它们无法充分利用来自不同类型参数的异构信息</strong>。</p>
<p>在本文中，我们提出了一种<strong>新的特征工程方法</strong>和一种<strong>新的恶意软件检测深度学习体系结构</strong>。特别是，对于不同类型的参数，我们的特征工程方法<strong>利用哈希方法分别提取异构特征</strong>。<strong>从API名称、类别和参数中提取的特征将进一步串联并输入到深度学习模型中</strong>。我们使用多个选通CNN模型（Dauphin
et
al.2017）从每个API调用的高维哈希特征中学习抽象的低维特征。来自选通CNN模型的输出由双向LSTM处理，以提取所有API调用的顺序相关性。</p>
<p>我们的解决方案比所有基线都有很大的优势。通过广泛的烧蚀研究，我们发现特征工程和模型架构设计对于实现高泛化性能至关重要。本文的主要贡献包括：</p>
<ul>
<li>我们为系统API参数提出了一种新的特征表示。从我们的数据集中提取的特征将发布供公众访问。</li>
<li>我们设计了一种深度神经网络结构来处理提取的特征，它将多个门控CNN和一个双向LSTM相结合。它以巨大的利润超过了所有现有的解决方案。</li>
<li>我们在一个大型真实数据集1上进行了广泛的实验。通过消融研究，发现了有关特征和模型架构的宝贵见解。</li>
</ul>
<h3><span id="二-相关工作">二、相关工作</span></h3>
<p>在本节中，我们将从特征工程和深度学习的角度回顾动态恶意软件分析。</p>
<h4><span id="21-api调用的功能工程">2.1 API调用的功能工程</span></h4>
<p>（Trinius等人，2009）介绍了一种称为<strong>恶意软件指令集（MIST）</strong>的特征表示。MIST使用多个级别的功能来表示系统调用。第一级表示API调用的类别和名称。以下级别是为每个API调用手动指定的，以表示它们的参数。然而，对于不同的API，同一级别的特性可能表示不同类型的信息。这种不一致性给使用机器学习模型学习模式带来了挑战。</p>
<p>（Qiao等人，2013）扩展了MIST，提出了一种称为<strong>基于字节的行为指令集（BBIS）</strong>的表示。他们声称，只有MIST的第一级（API调用的类别和名称）是有效的。此外，他们还提出了一种算法<strong>CARL来处理连续重复的API调用</strong>。</p>
<p>统计特征是训练机器学习模型的常用方法。提取API调用名称及其参数中的字符串，以计算频率和分布，作为中的特征（Tian
et al.2010；Islam et al.2010；2013）。（Ahmed et
al.2009）还使用统计特征来捕获空间和时间信息。从参数中提取空间信息，如均值、方差和熵。时间信息来自ngram
API调用，包括两个n-gram API调用之间的相关性和转换可能性。</p>
<p>（Salehi、Ghiasi和Sami
2012）提出了一种将API调用与其参数关联起来的特性表示。它将每个参数与其API调用的名称连接起来，形成一个新的序列，然而，这种方法会导致一个非常长的特征向量，并且可能会丢失API调用序列的模式。</p>
<p>（Hansen等人，2016）提出了另外两种特征表示法。这些表示包括前200个API调用及其“参数”。但是，此“参数”仅指示此API调用是否与后一个API调用连接，而忽略原始参数。</p>
<h4><span id="22-deep-learning-basedapproaches">2.2 Deep Learning Based
Approaches</span></h4>
<p>（David and Netanyahu
2015）将<strong>沙盒报告视为一个完整的文本字符串</strong>，然后用任何特殊字符拆分所有字符串。他们计算每个字符串的频率，并使用20000位向量来表示最频繁的20000个字符串。他们的模型是一个<strong>深度信念网络（DBN）</strong>，由八层组成（从20000个大小的向量到30个大小的向量）。利用交叉熵损失对模型进行训练。在一个包含600个测试样本的小数据集上，它们的准确率达到98.6%。</p>
<p>（Pascanu et
al.2015）提出了两个阶段的方法，即特征学习阶段和分类阶段。在第一阶段，他们<strong>使用RNN根据之前的API调用序列预测下一个可能的API调用</strong>。在分类阶段，他们冻结RNN，并将输出输入最大池层，以转换特征进行分类。在75000个样本的数据集上，它们的召回率达到71.71%，假阳性率为0.1%。</p>
<p><strong>（Kolosnjaji et
al.2016）提出了一种将CNN与LSTM相结合的方法。他们的方法堆叠两个CNN层，每个CNN层使用一个3大小的内核来模拟3-gram方法。在CNN之后，附加一个具有100大小隐藏向量的LSTM来处理时间序列。以前的论文通常忽略了论点。</strong></p>
<p><strong>（Huang和Stokes
2016）使用了一种包含三个部分的特征表示，即参数中存在可运行代码、API调用名称与其中一个参数的组合（手动选择）以及3-gram的API调用序列</strong>。通过随机投影（random
projection），此特征表示从50000减少到4000。（Agrawal et
al.2018）提出了一种特征表示方法，<strong>该方法使用来自API调用名称的一个one-hot和参数字符串的前N个频繁N-gram</strong>。该模型使用了几个堆叠的LSTM，其性能优于（Kolosnjaji等人，2016）。他们还声称，多个LSTM不能提高性能。</p>
<h3><span id="三-系统框架">三、系统框架</span></h3>
<p>为了收集运行时API调用，我们实现了图1所示的系统。该系统由体育档案采集、行为信息采集、特征提取和模型训练三部分组成。</p>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191547460.png" alt="image-20220526165948643">
<figcaption aria-hidden="true">image-20220526165948643</figcaption>
</figure>
<h4><span id="31-pe文件收集">3.1 PE文件收集</span></h4>
<p>我们系统的工作流程从可移植可执行文件（PE）集合开始。在本文中，我们重点检测Windows系统中可移植可执行文件（PE）格式的恶意软件，这是最流行的恶意软件文件格式（AV-TEST
2017）。此收集部分已由新加坡SecureAge
Technology本地反病毒公司实施。此外，该公司还维护了一个包含12个防病毒引擎的平台，用于对PE文件进行分类。对分类结果进行聚合，以获得每个PE文件的标签，用于模型培训。一旦模型经过培训，它将作为第13个防病毒引擎添加到平台中。收集之后，将维护一个执行队列，以提交PE文件以供执行。它监视存储使用情况并决定是否执行更多PE文件。</p>
<h4><span id="32-行为信息收集">3.2 行为信息收集</span></h4>
<blockquote>
<p>https://cuckoosandbox.org/</p>
<p>json在线解析：http://www.jsons.cn/jsoncheck/</p>
</blockquote>
<p><strong>布谷鸟</strong>是一款开源软件，用于运行PE文件和收集执行日志。它在虚拟机内执行PE文件，并使用API挂钩监视API调用跟踪（即行为信息）。此外，布谷鸟模拟了一些用户行为，例如单击按钮、键入一些文本等。<strong>在我们的系统中，我们在每台服务器上维护了数十台虚拟机。所有虚拟机都安装了64位Windows
7系统和一些日常使用的软件</strong>。我们利用虚拟机的快照功能在执行后回滚它。<strong>所有生成的日志都存储在本地的布谷鸟服务器上</strong>。</p>
<h4><span id="33-特征提取和模型训练">3.3 特征提取和模型训练</span></h4>
<p>沙盒生成的执行日志包含<strong>PE文件的详细运行时信息</strong>，PE文件的大小从几KB到数百GB不等。我们设计了一个可以<strong>并行运行的特征工程解决方案</strong>，<strong>以有效地从原始执行日志中提取特征</strong>。提取特征后，我们在带有GPU的模型服务器上训练我们的深度学习模型，以进行恶意软件分类。</p>
<h3><span id="4-方法">4、方法</span></h3>
<blockquote>
<p>#### cuckoo json:</p>
<ul>
<li><p><strong>behavior</strong></p>
<ul>
<li><p>summary</p>
<ul>
<li>file_recreated</li>
<li>file_failed</li>
<li>dll_loaded</li>
<li>guid</li>
<li>file_opened</li>
<li>file_created</li>
<li>file_written</li>
</ul></li>
<li><p><strong>generic</strong></p>
<ul>
<li>process_path: 进程启动路径</li>
<li><strong>process_name</strong>: 进程执行程序名</li>
<li>pid: 进程id</li>
<li>first_seen: 进程启动时间戳</li>
<li>ppid: 父进程id</li>
</ul></li>
<li><p><strong>apistats</strong>：<strong>API名称的调用次数信息</strong></p></li>
<li><p><strong>processes</strong></p>
<ul>
<li><p>command_line</p></li>
<li><p><strong>calls</strong></p>
<blockquote>
<p>{ "<strong>api</strong>": "NtCreateFile",
"<strong>category</strong>": "file", "return_value": 0, "stacktrace": [
], "flags": { "desired_access":
"FILE_READ_ATTRIBUTES|READ_CONTROL|SYNCHRONIZE", "share_access":
"FILE_SHARE_READ", "file_attributes": "", "create_disposition":
"FILE_OPEN", "create_options":
"FILE_NON_DIRECTORY_FILE|FILE_SYNCHRONOUS_IO_NONALERT", "status_info":
"FILE_OPENED" }, "<strong>arguments</strong>": { "desired_access":
"0x00120080", "share_access": 1, "<strong>filepath_r</strong>":
"\??\C:\Users\xn\AppData\Local\Temp\0e823db8b1beaca62207e2a82a9cd691c7af44cd14b876cb9f823f29750dd008",
"<strong>filepath</strong>":
"C:\Users\xn\AppData\Local\Temp\0e823db8b1beaca62207e2a82a9cd691c7af44cd14b876cb9f823f29750dd008",
"file_attributes": 0, "create_disposition": 1, "file_handle":
"0x000004ac", "status_info": 1, "create_options": 96 }, "tid": 3564,
"status": 1, "time": 1622640835.384851 },</p>
</blockquote></li>
<li><p><strong>modules</strong>: <strong>样本运行时调用的系统文件信息,
包括被调用文件名/路径/基地址及其大小</strong></p></li>
<li><p>time: 运行时间</p></li>
</ul></li>
<li><p><strong>processtree</strong></p>
<ul>
<li>children: 子进程列表</li>
</ul></li>
</ul></li>
</ul>
</blockquote>
<h4><span id="41-特征工程">4.1 特征工程</span></h4>
<blockquote>
<ul>
<li><p><strong>FeatureHasher</strong>:
https://scikit-learn.org/dev/modules/generated/sklearn.feature_extraction.FeatureHasher.html#sklearn.feature_extraction.FeatureHasher</p></li>
<li><p><strong>Feature Hashing for Large Scale Multitask
Learning</strong> （2013）</p></li>
</ul>
</blockquote>
<p>以前的大多数工作（Qiao et al.2013；Pascanu et al.2015；Kolosnjaji et
al.2016）都<strong>忽略了API调用的参数</strong>，只考虑了API名称和类别。因此，一些重要（鉴别）信息丢失（Agrawal
et
al.2018）。例如，如果忽略文件路径参数，则两个写操作（API调用）的功能将完全相同。但是，当目标文件由程序本身创建时，写入操作可能是良性的，但如果目标文件是系统文件，则写入操作可能是恶意的。一些考虑到论点的著作（Trinius
et al.2009；Agrawal et al.2018；Huang and Stokes
2016）未能利用不同类型论点的异质信息。我们建议采用（Weinberger et
al.2009）中的哈希方法，<strong>分别对API的名称、类别和参数进行编码</strong>。</p>
<p>如下表所示，我们的特征表示由不同类型的信息组成。<strong>API名称有8维，API类别有4维。API参数部分有90个维，16个用于整数参数，74个用于字符串参数。对于字符串参数，将处理几种特定类型的字符串（文件路径、DLL等）。此外，从所可打印字符串中提取了10个统计特征</strong>。将所有这些特征串联起来，形成<strong>102维特征向量</strong>。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191547725.png" alt="image-20220526170451620" style="zoom:50%;"></p>
<ul>
<li><h4><span id="api名称和类别">API名称和类别</span></h4></li>
</ul>
<blockquote>
<p>单词拆分？fastext？<strong>删除循环调用？</strong></p>
</blockquote>
<p><strong>布谷鸟沙盒总共跟踪312个API调用，它们属于17个类别</strong>。每个API名称由多个单词组成，每个单词的第一个字母大写，例如“<strong>GetFileSize</strong>”。我们<strong>将API名称拆分为单词</strong>，然后应用下面的<strong>特性哈希技巧处理这些单词</strong>。对于API类别，由于该类别通常是单个单词，例如“<strong>network</strong>”，我们将该单词拆分为字符并应用特征哈希技巧。此外，我们<strong>计算API名称、类别和参数的MD5值，以删除任何连续重复的API调用</strong>。</p>
<p>我们使用方程1中的<strong>特征哈希</strong>（Weinberger et
al.2009）<strong>将字符串序列编码为固定长度的向量</strong>。随机变量x表示元素序列，其中每个元素要么是字符串，要么是字符。M表示维度数量，即8表示API名称，4表示API类别。第i个bin的值通过以下公式计算：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548610.png" alt="image-20220526172933876" style="zoom:50%;"></p>
<p>其中，h是将元素（例如xj）映射到自然数m的哈希函数∈
{1，…，M}作为bin索引；ξ是另一个将元素映射到{+-1}
。也就是说，对于x的每个元素xj，其bin索引h（xj）为i，我们将ξ（xj）添加到bin中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">APIName</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; api_name hash info &#x27;&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;api_name&#x27;</span></span><br><span class="line">    dim = <span class="number">8</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(FeatureType, self).__init__()</span><br><span class="line">        self._name = re.<span class="built_in">compile</span>(<span class="string">&#x27;^[a-z]+|[A-Z][^A-Z]*&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">raw_features</span>(<span class="params">self, input_dict</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        input_dict: string</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        tmp = self._name.findall(input_dict)</span><br><span class="line">        hasher = FeatureHasher(self.dim, input_type=<span class="string">&quot;string&quot;</span>).transform([tmp]).toarray()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> hasher</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_raw_features</span>(<span class="params">self, raw_obj</span>):</span><br><span class="line">        <span class="keyword">return</span> raw_obj</span><br><span class="line">      </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">APICategory</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; api_category hash info &#x27;&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;api_category&#x27;</span></span><br><span class="line">    dim = <span class="number">4</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(FeatureType, self).__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">raw_features</span>(<span class="params">self, input_dict</span>):</span><br><span class="line">        hasher = FeatureHasher(self.dim, input_type=<span class="string">&quot;string&quot;</span>).transform([input_dict]).toarray()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> hasher</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_raw_features</span>(<span class="params">self, raw_obj</span>):</span><br><span class="line">        <span class="keyword">return</span> raw_obj</span><br></pre></td></tr></table></figure>
<ul>
<li><h4><span id="api参数">API参数</span></h4></li>
</ul>
<figure>
<img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548031.png" alt="image-20230319160222991">
<figcaption aria-hidden="true">image-20230319160222991</figcaption>
</figure>
<p>至于API参数，只有两种类型的值，即<strong>整数</strong>和<strong>字符串</strong>。整数的单个值没有意义。需要参数名称才能获取值的含义。<strong>相同的整数值可能表示具有不同参数名称的完全不同语义</strong>。例如，<strong>名为“port”的数字22与名为“size”的数字不同</strong>。我们采用前面的特征哈希方法<strong>对整数的参数名称及其值进行编码</strong>，如等式2所示。我们使用参数名称来定位哈希容器。特别是，我们使用名称哈希值为i的所有参数通过求和更新第i个bin。对于每个这样的参数，我们计算对bin的贡献，如等式2所示，其中ξ(<span class="math inline">\(x_{name_j}\)</span>)是参数名称上的哈希函数，<span class="math inline">\(x_{value_j}\)</span>是整数参数的值。由于整数可能在某个范围内稀疏分布，因此我们使用对数对值进行规格化，以压缩该范围。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548958.png" alt="image-20220526174316254" style="zoom:50%;"></p>
<p>其中，h和ξ是与等式1中相同的哈希函数。<strong>对于API参数字符串，它们的值比整数更复杂。某些以“0x”开头的字符串包含某些对象的地址。还有一些可能包含文件路径、IP地址、URL或纯文本</strong>。此外，一些API参数甚至可能包含整个文件的内容。字符串的多样性使得处理它们具有挑战性。根据之前的工作（Tian
et al.2010；Islam et al.2010；2013；Ahmed et
al.2009），最重要的字符串是关于<strong>文件路径、DLL、注册表项、URL和IP地址的值</strong>。因此，我们使用<strong>方程1中的特征哈希方法【string】</strong>来提取这些字符串的特征。</p>
<p>为了捕获<strong>字符串中包含的层次信息</strong>，我们将整个字符串解析为几个子字符串，并分别对它们进行处理。例如，我们使用“C:\”来标识文件路径。所有这些子串都通过方程1进行处理</p>
<blockquote>
<p><strong>Path</strong>：<strong>对于像“C:\a\b\C”这样的路径，将生成四个子字符串，即“C:”、“C:\a”、“C:\a\b”和“C:\a\b\C”。</strong></p>
<p>dll：以“.dll”结尾的字符串</p>
<p>注册表：项通常以“HKEY”开头</p>
<p>IP：由点分隔的四个数字（范围从0到255）组成的字符串</p>
<p>URL：我们仅从URL的主机名生成子字符串。例如，对于“https://security.ai.cs.org/，将生成以下子字符串“org”、“cs.org”、“ai.cs.org”和“security.ai.cs.org”。</p>
</blockquote>
<p><strong>DLL、注册表项和IP也采用相同的处理方法</strong>。<strong>dll是以“.dll”结尾的字符串。注册表项通常以“HKEY”开头。IP是由点分隔的四个数字（范围从0到255）组成的字符串</strong>。URL略有不同，我们仅从URL的主机名生成子字符串。例如，对于“https://security.ai.cs.org/，将生成以下子字符串“org”、“cs.org”、“ai.cs.org”和“security.ai.cs.org”。这样，域和组织信息将对该功能贡献更多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PRUIInfo</span>(<span class="title class_ inherited__">FeatureType</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Path, Registry, Urls, IPs hash info &#x27;&#x27;&#x27;</span></span><br><span class="line">    name = <span class="string">&#x27;prui&#x27;</span></span><br><span class="line">    dim = <span class="number">16</span> + <span class="number">8</span> + <span class="number">12</span> + <span class="number">16</span> + <span class="number">12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(FeatureType, self).__init__()</span><br><span class="line">        self._paths = re.<span class="built_in">compile</span>(<span class="string">&#x27;^c:\\\\&#x27;</span>, re.IGNORECASE)</span><br><span class="line">        self._dlls = re.<span class="built_in">compile</span>(<span class="string">&#x27;.+\.dll$&#x27;</span>, re.IGNORECASE)</span><br><span class="line">        self._urls = re.<span class="built_in">compile</span>(<span class="string">&#x27;^https?://(.+?)[/|\s|:]&#x27;</span>, re.IGNORECASE)</span><br><span class="line">        self._registry = re.<span class="built_in">compile</span>(<span class="string">&#x27;^HKEY_&#x27;</span>)</span><br><span class="line">        self._ips = re.<span class="built_in">compile</span>(<span class="string">&#x27;^\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">raw_features</span>(<span class="params">self, input_dict</span>):</span><br><span class="line">        paths = np.zeros((<span class="number">16</span>,), dtype=np.float32)</span><br><span class="line">        dlls = np.zeros((<span class="number">8</span>,), dtype=np.float32)</span><br><span class="line">        registry = np.zeros((<span class="number">12</span>,), dtype=np.float32)</span><br><span class="line">        urls = np.zeros((<span class="number">16</span>,), dtype=np.float32)</span><br><span class="line">        ips = np.zeros((<span class="number">12</span>,), dtype=np.float32)</span><br><span class="line">        <span class="keyword">for</span> str_name, str_value <span class="keyword">in</span> input_dict.items():</span><br><span class="line">            <span class="keyword">if</span> self._dlls.<span class="keyword">match</span>(str_value):</span><br><span class="line">                tmp = re.split(<span class="string">&#x27;//|\\\\|\.&#x27;</span>, str_value)[:-<span class="number">1</span>]</span><br><span class="line">                tmp = [<span class="string">&#x27;\\&#x27;</span>.join(tmp[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(tmp) + <span class="number">1</span>)]</span><br><span class="line">                dlls += FeatureHasher(<span class="number">8</span>, input_type=<span class="string">&quot;string&quot;</span>).transform([tmp]).toarray()[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> self._paths.<span class="keyword">match</span>(str_value):</span><br><span class="line">                tmp = re.split(<span class="string">&#x27;//|\\\\|\.&#x27;</span>, str_value)[:-<span class="number">1</span>]</span><br><span class="line">                tmp = [<span class="string">&#x27;\\&#x27;</span>.join(tmp[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(tmp) + <span class="number">1</span>)]</span><br><span class="line">                paths += FeatureHasher(<span class="number">16</span>, input_type=<span class="string">&quot;string&quot;</span>).transform([tmp]).toarray()[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> self._registry.<span class="keyword">match</span>(str_value):</span><br><span class="line">                tmp = str_value.split(<span class="string">&#x27;\\&#x27;</span>)[:<span class="number">6</span>]</span><br><span class="line">                tmp = [<span class="string">&#x27;\\&#x27;</span>.join(tmp[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(tmp) + <span class="number">1</span>)]</span><br><span class="line">                registry += FeatureHasher(<span class="number">12</span>, input_type=<span class="string">&quot;string&quot;</span>).transform([tmp]).toarray()[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> self._urls.<span class="keyword">match</span>(str_value):</span><br><span class="line">                tmp = self._urls.split(str_value + <span class="string">&quot;/&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">                tmp = tmp.split(<span class="string">&#x27;.&#x27;</span>)[::-<span class="number">1</span>]</span><br><span class="line">                tmp = [<span class="string">&#x27;.&#x27;</span>.join(tmp[:i][::-<span class="number">1</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(tmp) + <span class="number">1</span>)]</span><br><span class="line">                urls += FeatureHasher(<span class="number">16</span>, input_type=<span class="string">&quot;string&quot;</span>).transform([tmp]).toarray()[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">elif</span> self._ips.<span class="keyword">match</span>(str_value):</span><br><span class="line">                tmp = str_value.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                tmp = [<span class="string">&#x27;.&#x27;</span>.join(tmp[:i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(tmp) + <span class="number">1</span>)]</span><br><span class="line">                ips += FeatureHasher(<span class="number">12</span>, input_type=<span class="string">&quot;string&quot;</span>).transform([tmp]).toarray()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> np.hstack([paths, dlls, registry, urls, ips]).astype(np.float32)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_raw_features</span>(<span class="params">self, raw_obj</span>):</span><br><span class="line">        <span class="keyword">return</span> raw_obj</span><br></pre></td></tr></table></figure>
<h4><span id="统计信息">统计信息</span></h4>
<p>对于许多其他类型的字符串，根据之前的工作（Ahmed et al.2009；Tian et
al.2010；Islam et
al.2010），我们<strong>从所有可打印字符串中提取统计信息</strong>。可打印字符串由0x20到0x7f的字符组成。<strong>因此，包括所有路径、注册表项、URL、IP和其他一些可打印字符串</strong>。</p>
<ul>
<li>以“MZ”开头的一类字符串通常是包含整个PE文件的缓冲区，通常出现在恶意PE文件中，如<strong>线程注入</strong>（Liu
et al.2011）。因此，我们额外计算“MZ”字符串的出现次数。</li>
<li><strong>10维向量用于记录字符串的数量、平均长度、字符数、所有可打印字符串的字符熵，以及路径、DLL、URL、注册表项、IP和“MZ”字符串的数量。</strong>我们没有处理其他参数，如虚拟地址、结构等，与上述类型的参数相比，这些参数相对不太重要。</li>
</ul>
<p>虽然所提出的特征工程方法很容易使用额外的bins应用于它们，但我们期待着进行更有针对性的研究来探索这些论点。</p>
<h4><span id="42-模型结构">4.2 模型结构</span></h4>
<p>我们提出了一种深度神经网络架构，它利用了所提出的特征工程步骤中的特征。图2概述了我们提出的深度学习模型。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548514.png" alt="image-20220526184024769" style="zoom:50%;"></p>
<ul>
<li><h4><span id="输入模块">输入模块</span></h4></li>
</ul>
<p>在特征工程之后，我们得到大小为（N，d）的输入向量，<strong>其中N是API调用序列的长度</strong>，<strong>d（102位）是每个提取的API特征的维数</strong>。我们首先通过<strong>批量规范化层（BN）</strong>对输入进行规范化（Ioffe和Szegedy
2015）。该批次标准化层通过减去批次平均值并除以批次标准偏差来标准化输入值。<strong>它保证了特征向量的某些维数不会太大而影响训练；实验验证了该方法的正则化效果。</strong></p>
<ul>
<li><h4><span id="门控cnns模块">门控CNNs模块</span></h4></li>
</ul>
<p>输入模块后应用了多个<strong>门控-CNN</strong>（Dauphin et
al.2017）。<strong>门控-CNN允许选择重要和相关的信息，使其在语言任务上与循环模型相比，但消耗更少的资源和时间</strong>。对于每个选通的CNN，输入分别馈入两个卷积层。设XA表示第一卷积层的输出，XB表示第二卷积层的输出；它们由<img src="image-20220526184352710.png" alt="image-20220526184352710" style="zoom:50%;">组成，它涉及到元素乘法运算。这里，σ是sigmoid函数。<strong>σ（XB）被视为控制从XA传递到模型中下一层的信息的门</strong>。<strong>按照（Shen
et
al.2014)中的想法，一维卷积滤波器被用作n-gram检测器。如图2所示，我们使用两个选通CNN，其过滤器大小分别为2和3。所有卷积层的滤波器个数为128，步长为1。</strong></p>
<ul>
<li><h4><span id="bi-lstm模块">BI-LSTM模块</span></h4></li>
</ul>
<p><strong>来自门CNN的所有输出连接在一起</strong>。对这些输出应用批处理规范化层，以减少过拟合。我们使用<strong>双向LSTM来学习序列模式</strong>。<strong>每个LSTM的单元数为100</strong>。LSTM是一种递归神经网络架构，其中设计了几个门来控制信息传输状态，以便能够捕获长期上下文信息（Pichotta和Mooney
2016）。双向LSTM是两个LSTM叠加在一起，但方向输入不同。与单向LSTM相比，双向LSTM能够同时整合过去和未来状态的信息。双向LSTM在恶意软件检测方面已被证明是有效的（Agrawal
et al.2018）。</p>
<ul>
<li><h4><span id="分类模块">分类模块</span></h4></li>
</ul>
<p><strong>在Bi
LSTM模块中学习序列模式后，应用全局最大池层从隐藏向量中提取抽象特征</strong>。全局最大池层不是使用Bi
LSTM的最终激活，而是依赖于整个序列中观察到的每个信号，这有助于保留整个序列中学习到的相关信息。在全局最大池层之后，<strong>我们使用单元数为64的密集层将中间向量的维数减少到64</strong>。将<strong>ReLU激活应用于该致密层</strong>。然后，我们使用速率为0.5的<strong>衰减层（dropout）</strong>来减少过度拟合。最后，<strong>单位数为1的致密层将维数减少到1</strong>。在致密层之后附加一个<strong>Sigmoid激活以输出概率</strong>。我们的模型使用与每个输入向量相关的标签进行监督。为了测量用于训练模型的损失。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191548788.png" alt="image-20220526185129696" style="zoom:50%;"></p>
<p>此外，我们采用的优化方法是Adam，学习率为0.001。</p>
<h2><span id="dynamic-malware-analysis-代码结构"><strong><font color="red">
Dynamic Malware Analysis - 代码结构</font></strong></span></h2>
<blockquote>
<p><strong>model.py</strong></p>
<ul>
<li>ClassifyGenerator: Generates data for Keras</li>
<li>Model: 模型结构定义、模型训练</li>
<li>Cuckoo2DMDS：</li>
<li>DMDS</li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/27/">27</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lzy</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

    </div>
  </footer>

  

  <a href="https://github.com/PowerLZY" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>




        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'powerlzy.github.io' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>
</html>
