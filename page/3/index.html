<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.lug.ustc.edu.cn/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-bounce.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"powerlzy.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="相比到达的地方，同行的人更重要！">
<meta property="og:type" content="website">
<meta property="og:title" content="PowerLZY&#39;s Blog">
<meta property="og:url" content="https://powerlzy.github.io/page/3/index.html">
<meta property="og:site_name" content="PowerLZY&#39;s Blog">
<meta property="og:description" content="相比到达的地方，同行的人更重要！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="lzy">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://powerlzy.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>PowerLZY's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">PowerLZY's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">本博客主要用于记录个人学习笔记（测试阶段）</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="lzy"
      src="/images/cat_mac.jpg">
  <p class="site-author-name" itemprop="name">lzy</p>
  <div class="site-description" itemprop="description">相比到达的地方，同行的人更重要！</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">119</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/PowerLZY" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;PowerLZY" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:3289218653@qq.com" title="E-Mail → mailto:3289218653@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2A4A099/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2A4A099/" class="post-title-link" itemprop="url">工业落地（5）蚂蚁安全-柳星《FXY：Security-Scenes-Feature-Engineering-Toolkit》</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-07-15 13:40:50 / 修改时间：13:55:29" itemprop="dateCreated datePublished" datetime="2022-07-15T13:40:50+08:00">2022-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/" itemprop="url" rel="index"><span itemprop="name">工业落地</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="fxysecurity-scenes-feature-engineering-toolkit">FXY：<em>Security-Scenes-Feature-Engineering-Toolkit</em></span></h2><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://github.com/404notf0und/FXY/blob/master/docs/%E9%9C%80%E6%B1%82%E5%92%8C%E8%AE%BE%E8%AE%A1.md">https://github.com/404notf0und/FXY/blob/master/docs/%E9%9C%80%E6%B1%82%E5%92%8C%E8%AE%BE%E8%AE%A1.md</a></p>
</blockquote>
<h3><span id="介绍">介绍</span></h3><p>FXY是一款特征工程框架，用于安全场景中数据预处理、数据预分析、数据特征化和向量化等任务。FXY这个名字一方面代表这款工具的目的是从原始安全数据中获取Feature X和Feature Y用于对接人工智能算法，另一方面寓意着人工智能的本质，函数Y=F(X)。FXY的特性是支持多种安全场景多种安全数据的预处理和特征化，内置多种NLP通用特征提取方法，内置脚本扩展支持二次开发。</p>
<h3><span id="需求">需求</span></h3><p>无论机器学习、深度学习还是强化学习应用在哪个领域，<strong>其处理流程主要有五个环节：问题-&gt;数据-&gt;特征化-&gt;算法-&gt;结果</strong>，数据的数字化，狭义的来说是数据的特征化，在整个流程中起到了承上启下的关键作用，承上，<strong>特征化的好坏直接反映了对问题本质的理解深入与否</strong>，启下，作为算法的输入，一定程度上决定了最终结果的天花板。这是FXY定位于安全场景下特征工程环节的一点原因。另一点原因是考虑到算法环节的不确定性因素和确定性因素，不确定性因素导致难以形成统一的范式，确定性因素导致问题已被解决。就算法的应用来说，机器学习算法、深度学习算法和超参数众多，在同一特征化方法下，难以客观比较不同算法的性能，并且找到泛化性强的SOTA算法。<strong>就算法本身来说，现有的框架tensorflow、keras等对算法的封装已经很完美了，重复造轮子意义不大。如果给算法环节盖上安全场景的帽子，问题依然如此，这是FXY不选择定位于安全场景下算法环节的原因。</strong></p>
<h3><span id="架构设计">架构设计</span></h3><p><img src="https://i.imgur.com/d2Rq9hc.png" alt></p>
<p>因为机器学习解决安全问题的流程固定为安全问题-&gt;数据-&gt;数字化-&gt;算法-&gt;结果，<strong>具体到FXY的架构设计，从下到上依次是安全场景层-&gt;数据的数据层-&gt;数据清洗层-&gt;特征层-&gt;算法层-&gt;API层</strong>，对应的FXY各模块层次结构依次为内置函数模块-&gt;数据预处理模块-&gt;特征工程模块-&gt;tensorflow/keras-&gt;控制器模块。</p>
<p>扩展可扩展的，因为安全场景较多且杂，完全不可能用一种或少数几种特征方法解决所有问题，想到的一种解决方式是针对安全问题做特征方法的插件化扩展，把每个安全问题对应每个CMS，每个feature engineering方法对应每个POC，那么就可以像写CMS POC一样专注于安全场景的底层数据feature engineering。</p>
<h3><span id="集成">集成</span></h3><p>笔者Github上AI-for-Security-Learning仓库专注于知识，而此FXY仓库专注于工具，现依赖前者仓库，笔者开始二刷，站在前人的肩膀上，不断集成优质方法到FXY框架中，此框架不做未知的创新。现已集成4种安全场景，4种特征工程方法，四种安全场景分别是<strong>LSTM识别恶意HTTP请求@cdxy，AI-Driven-WAF@exp-db，Phishing URL Classification@surajr，使用深度学习检测XSS@Webber，基于深度学习的恶意样本行为检测@ApplePig@360云影实验室</strong>，四种特征工程方法分别是<strong>钓鱼url的统计特征，恶意url和恶意软件api的词典索引特征，恶意url的TF-IDF特征，xss的word2vec词嵌入向量</strong>。</p>
<p>在二刷并集成的过程中，需要彻底读懂原作者的文章思路和代码，然后改写到FXY限定的框架中，学到了很多。同时输出一份二刷笔记，里面不但包括已集成代码到框架中的原文理解，还包括一些暂时无法集成的文章的理解，文档化记录了原作者用到的安全场景、解决的思路、数据的构成、数据预处理方法、特征的方法、使用的模型、有无监督分类，二刷笔记持续更新。</p>
<h3><span id="潜在问题">潜在问题</span></h3><p><strong>FXY框架专注于安全问题、数据和特征化三个环节</strong>:这其中数据环节存在数据源难获取的问题，有些文章中的数据属于公司级数据不会开源，较难获取，这导致只能使用开源数据集或自己采集数据集复现原作者的实验，集成并测试框架，虽说不会影响FXY框架的预处理、预分析和特征化等主要功能，但这会导致数据环节数据本身的价值变小，一定程度上减小了FXY框架的价值，因为可能大多数人遇到的问题不是没有方法，而是没有数据，数据本身的价值和数据分析的价值都很高，前者价值甚至大于后者。而CMS的POC框架可以靠各种搜索引擎和爬虫来获取数据源，输送给POC脚本，就不会存在此问题。</p>
<p>这促使我们是不是可以通过爬虫爬取更多异源开源数据，用开源弥补闭源，或是本地搭建环境采集数据，缓解数据源缺失的问题，从而使FXY框架的价值不只在于数据分析，更在于数据集本身，采集数据集是个脏活累活，在规划中。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2A5FQTF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2A5FQTF/" class="post-title-link" itemprop="url">工业落地（9）阿里云恶意软件检测平台</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-07-15 13:22:12 / 修改时间：13:26:00" itemprop="dateCreated datePublished" datetime="2022-07-15T13:22:12+08:00">2022-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/" itemprop="url" rel="index"><span itemprop="name">工业落地</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>981</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="一-阿里云恶意文件检测平台">一、阿里云恶意文件检测平台</span></h2><p>Linux沙箱 ｜ 阿里云恶意文件检测平台开放Linux二进制文件检测：<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/276349#10006-weixin-1-52626-6b3bffd01fdde4900130bc5a2751b6d1">https://www.anquanke.com/post/id/276349#10006-weixin-1-52626-6b3bffd01fdde4900130bc5a2751b6d1</a></p>
<h3><span id="11-简介">1.1 简介</span></h3><p>在病毒检测方向，一直以来常见的两种手段就是<strong>静态特征检测</strong>与<strong>动态行为检测</strong>。两者各有优势与不足，<strong>静态特征检测方案实施成本更低，检出结果也更精准，但是其泛化能力不足</strong>，针对具有高级对抗能力的恶意文件显得力不从心，并且天然地处于被动的地位，人力运营成本会更高。</p>
<p>动态行为检测实施成本相对较高，需要有足够的资源，而且检出的结果在一定程度上不如静态检测精准，但是它最大的优势是可以从<strong>恶意行为、技术手段</strong>的角度识别恶意文件，具有极大的泛化能力。对于需要检测大量恶意文件的安全厂商来说，人工运营所有样本并提取静态特征是不现实的，而沙箱的作用也就显现出来了：在海量的文件中，识别出最值得关注的恶意文件。</p>
<h3><span id="12-沙箱优势">1.2 沙箱优势</span></h3><h4><span id="高性能的环境仿真">高性能的环境仿真</span></h4><p><strong>云沙箱依托于阿里云神龙架构，在具备高性能的仿真的同时，还支持资源池化和自动化运维的能力</strong>。利用自定义的虚拟化技术和定制的沙箱OS内核，对恶意样本使用的反虚拟化的技术具备天然的对抗能力，配合上专门打造的二进制检测探针，可以在安全、高效、仿真的隔离环境中对二进制进行深度的行为分析。</p>
<h4><span id="全面的动态行为分析">全面的动态行为分析</span></h4><p><strong>基于虚拟化构建的沙箱深度分析技术，对进程、文件、网络、敏感系统调用、rootkit、漏洞利用等进行全面监控</strong>，配合智能模型规则检测引擎，快速分析出样本潜在的恶意行为。</p>
<h4><span id="海量的数据积累">海量的数据积累</span></h4><p>阿里云沙箱服务于阿里云安全云上恶意文件检测，积累了海量样本数据，提炼出大量有独检优势的行为检测规则。</p>
<h3><span id="33-检测优势">3.3 检测优势</span></h3><h4><span id="算法模型覆盖未知威胁">算法模型——覆盖未知威胁</span></h4><p>基于阿里云平台海量样本数据和强劲计算能力，<strong>采用“机器智能(神经网络)”与“专家智能(行为标签、ATT&amp;CK)”结合的智能安全思想</strong>，挖掘海量样本数据中可疑内容信息和行为标签威胁值，构建智能的威胁检测模型发现新威胁。</p>
<p>将专家知识与海量数据结合智能化构建以<strong>ATT&amp;CK为核心的多模态特征表示</strong>，对样本行为从技术战术度量、敏感信息表征、意图逻辑推理等角度进行多维度刻画、分析，同时依赖机器智能的学习泛化能力、检测模型能覆盖更多的未知，拓展威胁发现边界。</p>
<p><img src="https://p2.ssl.qhimg.com/t019938cd9a1afcd563.png" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/1WZGAE8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/1WZGAE8/" class="post-title-link" itemprop="url">高级威胁发现（6）UNICORN: Provenance-Based Detector for APTs</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-10 21:02:53" itemprop="dateCreated datePublished" datetime="2022-07-10T21:02:53+08:00">2022-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:58:24" itemprop="dateModified" datetime="2023-04-19T15:58:24+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="ndss20-unicorn-provenance-based-detector-for-apts">NDSS20 UNICORN: Provenance-Based Detector for APTs</span></h2><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MTM5ODU2Mg==&amp;mid=2247492967&amp;idx=1&amp;sn=60f14977758cc7d1e8504446422e5ec0&amp;chksm=cfcf55aaf8b8dcbc86935b76e7f36961202174ecba1df597fee9d44428c607e80d41add1b2f9&amp;scene=178&amp;cur_album_id=1776483007625822210#rd">[AI安全论文] 06.NDSS20 UNICORN: Provenance-Based Detector for APTs</a></p>
</blockquote>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555641.png" alt="图片"></p>
<blockquote>
<p>  原文作者：Xueyuan Han, Thomas Pasquier, Adam Bates, James Mickens and Margo Seltzer<br>  原文标题：UNICORN: Runtime Provenance-Based Detector for Advanced Persistent Threats<br>  原文链接：<a target="_blank" rel="noopener" href="https://arxiv.org/pdf/2001.01525.pdf">https://arxiv.org/pdf/2001.01525.pdf</a><br>  发表会议：NDSS 2020参考文献：感谢两位老师  <a target="_blank" rel="noopener" href="https://blog.csdn.net/Sc0fie1d/article/details/104868847">https://blog.csdn.net/Sc0fie1d/article/details/104868847</a>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/xjxtx1985/article/details/106473928">https://blog.csdn.net/xjxtx1985/article/details/106473928</a></p>
</blockquote>
<h3><span id="摘要">摘要</span></h3><p>本文提出的<strong>UNICORN是一种基于异常的APT检测器</strong>，可以有效利用数据<strong>Provenance进行分析</strong>。通过广泛且快速的图分析，使用<strong>graph sketching技术</strong>，UNICORN可以在长期运行的系统中分析Provenance Graph，从而识别未知慢速攻击。其中，Provenance graph提供了丰富的上下文和历史信息，实验证明了其先进性和较高准确率。</p>
<p>由于APT（Advanced Persistent Threats）攻击具有缓慢可持续的攻击模式以及频繁使用0-day漏洞的高级特性使其很难被检测到。<strong>本文利用数据来源分析（provenance）提出了一种基于异常的APT检测方法，称为UNICORN。</strong></p>
<ul>
<li>从建模到检测，UNICORN专门针对APT的独有特性（low-and-slow、0-Days）设计。</li>
<li>UNICONRN利用高效的图分析方法结合溯源图丰富的上下文语义和历史信息，在没有预先设定攻击特征情况下识别隐蔽异常行为。</li>
<li>通过图概要（graph sketching）技术，它有效概括了长时间系统运行来对抗长时间缓慢攻击。</li>
<li>UNICONRN使用一种新的建模方法来更好地捕捉长期行为规律，以提高其检测能力。</li>
</ul>
<p>最后通过大量实验评估表明，本文提出的方法优于现有最先进的APT检测系统，并且在真实APT环境中有较高的检测精度。</p>
<h3><span id="一-引言">一、引言</span></h3><p>APT攻击现在变得越来越普遍。这种攻击的时间跨度长，且与传统攻击行为有着本质的区别。APT攻击者的目的是获取特定系统的访问控制，并且能够长期潜伏而不被发现。攻击者通常使用0-day漏洞来获取受害者系统的访问控制。</p>
<p><strong>传统检测系统通常无法检测到APT攻击。</strong></p>
<ul>
<li>依赖恶意软件签名的检测器对利用新漏洞的攻击无效。</li>
<li>基于异常检测的系统通常分析一系列的系统调用或日志系统事件，其中大部分方法无法对长期行为进行建模。</li>
<li>由于基于异常检测的方法只能检测系统调用和事件的短序列很容易被绕过。</li>
</ul>
<p>综上，当前针对APT攻击的检测方法很少能成功。攻击者一旦使用0-Day漏洞，防御者便无计可施；而基于系统调用和系统事件的检测方法，由于数据过于密集，这些方法难以对长时间的行为模式进行建模。<strong>因此，数据溯源（data provenance）是一种检测APT更合适的数据。</strong></p>
<p>最近的研究成果表明数据溯源是一个很好的APT检测数据源。数据溯源将系统执行表示成一个有向无环图（DAG），该图描述了系统主体（如进程）和对象（文件或sockets）之间的信息流。即使跨了很时间，在图中也把因果相关的事件关联到一起。因此，即使遭受APT攻击的系统与正常系统比较类似，但是溯源图中丰富的上下文语义信息中也可以很好地区分正常行为与恶意行为。</p>
<p><strong>然而，基于数据溯源的实时APT检测依然具有挑战。</strong><br>随着APT攻击的渗透的进行，数据溯源图的规模会不断增大。其中必要的上下文分析需要处理大量图中的元素，而图上的分析通常复杂度比较高。当前基于数据溯源的APT检测方法根据已有的攻击知识通过简单的边匹配实现APT检测，无法处理未知的APT攻击。基于溯源的异常检测系统主要是基于图模型的邻域搜索，利用动态或静态模型识别正常行为模式。理论上关联的上下文越丰富越好，但是实际中由于图分析的复杂性较高限制了其可行性。</p>
<ul>
<li>Provenance Graph的分析是相当耗费计算资源，因为APT是可持续攻击，图的规模也会越来越大</li>
</ul>
<p><strong><font color="red"> 当前APT检测系统面临如下三种问题：</font></strong></p>
<ul>
<li>静态模型难以捕获长时间的系统行为；</li>
<li>low-and-slow APT投毒攻击：由于APT高级可持续的特性可以在系统中潜伏很长时间，相关的行为会被认为是正常行为，这样的攻击会影响检测模型；</li>
<li>在主存内进行计算的方法，应对长期运行的攻击表现不佳。</li>
</ul>
<p>基于此，本文提出了UNICORN，使用graph sketching来建立一个增量更新、固定大小的纵向图数据结构。这种纵向性质允许进行广泛的图探索，使得UNICORN可以追踪隐蔽的入侵行为。而固定大小和增量更新可以避免在内存中来表示provenance graph，因此UNICORN具有可扩展性，且计算和存储开销较低。UNICORN在训练过程中直接对系统的行为进行建模，但此后不会更新模型，从而防止模型的投毒攻击。</p>
<p><strong><font color="red"> 本文的主要贡献如下：</font></strong></p>
<ul>
<li>针对APT攻击特性提出一种<strong>基于Provenance的异常检测系统</strong>。</li>
<li><strong>引入一种新的基于概要的（sketch-based）、时间加权的（time-weighted）溯源编码</strong>，该编码非常紧凑且可处理长时间的溯源图。</li>
<li>通过模拟和真实的APT攻击来评估UNICORN，证明其能高精度检测APT活动。</li>
<li><strong><font color="red"> 实现代码开源。</font></strong></li>
</ul>
<h3><span id="二-背景">二、背景</span></h3><h4><span id="21-系统调用追踪的挑战"><strong>2.1 系统调用追踪的挑战</strong></span></h4><p><strong>系统调用抽象提供了一个简单的接口，用户级应用程序可以通过这个接口请求操作系统的服务</strong>。作为调用系统服务的机制，系统调用接口通常也是攻击者入侵的入口点。因此，系统调用跟踪一直被认为是入侵检测的实际信息源。然而：</p>
<ul>
<li>当前的攻击检测系统是对非结构化的系统调用的审记日志进行分析，但捕获的系统调用杂乱分散，传统基于异常检测的思路无法处理APT。因此需要将其关联成data provenance，基于溯源的方法是将历史上下文数据都编码到因果关系图中。</li>
<li>数据溯源方法已经被应用到攻击调查中，已经有一些方法能够根据审计数据构建系统溯源图用以实现对系统执行过程的建模。然而这些方法依然存在一些局限：(1) 这种事后构建很难保证溯源图的正确性，由于系统调用问题存大量并发，溯源图的完整性与可靠性无法保证；(2) 容易被绕过；(3) 时空复杂度较高。</li>
<li>由于一些内核线程不使用系统调用，因此<strong>基于Syscall生成的Provenance是一些分散的图，而不是一张系统运行状况的完整图</strong></li>
</ul>
<h4><span id="22-全系统追踪溯源">2.2 <strong>全系统追踪溯源</strong></span></h4><p><strong>全系统溯源运行在操作系统层面，捕获的是所有系统行为和它们之间的交互</strong>。通过捕获信息流和因果关系，即使攻击者通过操作内核对象来隐藏自己的行踪也无济于事。</p>
<p>本文使用CamFlow，采用了Linux安全模块（Linux Security Modules，LSM）框架来确保高效可靠的信息流记录。LSM可以消除race condition。</p>
<blockquote>
<p>  <strong>CamFlow：溯源搜集系统</strong>，参考官网 <a target="_blank" rel="noopener" href="https://camflow.org/。">https://camflow.org/。</a></p>
<p>  <strong>CamFlow 将系统的执行表示为有向无环图</strong>。图中的顶点表示内核对象（例如线程、文件、套接字等）的状态，关系表示这些状态之间的信息流。</p>
<p>  <img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555346.png" alt="CamFlow 图表概览" style="zoom: 33%;"></p>
<p>  在上面的示例中<code>process 1</code>克隆<code>process 2</code>。 <code>process 2</code>写到一个<code>pipe</code>。 <code>process 1</code>同读<code>pipe</code>。创建版本是为了保证非周期性并代表信息的正确排序（有关详细信息，请参阅我们的<a target="_blank" rel="noopener" href="http://camflow.org/publications/ccs-2018.pdf">CCS’18 论文</a>）。</p>
</blockquote>
<h3><span id="23-问题描述">2.3 问题描述</span></h3><p>现有基于数据溯源的APT攻击检测方法主要存在如下缺陷：</p>
<ul>
<li>预定义的边匹配规则过于敏感，很难检测到APT攻击中的0-Day漏洞；</li>
<li>溯源图的近邻约束导致其只能提供局部上下文信息（而非whole-system），然而这会影响相关异常检测精度；</li>
<li>系统行为模型难以检测APT：静态模型无法捕获长期运行的系统的行为；动态模型容易遭受中毒攻击；</li>
<li>溯源图的存储与计算都是在内存中，在执行长期检测上有局限性。</li>
</ul>
<p><strong>UNICORN可以解决如上问题，其本质是把APT检测问题看成大规模、带有属性的实时溯源图异常检测问题。在任何时间，从系统启动到其当前状态捕获的溯源图都将与已知正常行为的溯源图进行比较。如果有明显差别，那么就认为该系统正在遭受攻击。</strong></p>
<p>对于APT检测来说，理想基于溯源的IDS应该如下：</p>
<ul>
<li>充分利用溯源图的丰富上下文，以时间与空间有效的方法持续分析溯源图；</li>
<li>在不假设攻击行为的基础上，应考虑系统执行的整个持续时间；</li>
<li>只学习正常行为的变化，而不是学习攻击者指示的变化。</li>
</ul>
<h3><span id="三-威胁模型">三、威胁模型</span></h3><p>假设主机入侵检测有适当的场景：攻击者非法获得对系统的访问权限，并计划在不被检测的情况下驻留在系统中很长一段时间。<strong>攻击者可能分阶段执行攻击，在每个阶段还会使用大量的攻击技术</strong>。UNICORN的目标是通过解决主机生成的溯源来实现在所有阶段对APT攻击进行检测。本文假设，我们假设在受到攻击之前，UNICORN在正常运行期间会完全观察主机系统，并且在此初始建模期间不会发生攻击。</p>
<p>数据收集框架的完整性是UNICORN正确性的核心，因此<strong>我们假定所使用的CamFlow中，LSM完整性是可信的。同时，本文假设内核、溯源数据和分析引擎的正确性，我们重点关注UNICORN的分析能力。</strong></p>
<h3><span id="四-系统设计">四、系统设计</span></h3><p>独角兽是一个基于主机的入侵检测系统，能够同时检测在网络主机集合上的入侵。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555615.png" alt="图片" style="zoom: 67%;"></p>
<ol>
<li><strong>以一个带标签的流式溯源图作为输入</strong>。该图由CamFlow生成，每条边是带属性的。溯源系统构建一个具有偏序关系的DAG溯源图，能实现有效的流式计算和上下文分析。</li>
<li><strong>建立一个运行时的内存直方图</strong>。UNICORN有效构建一个流式直方图，该直方图表示系统执行的历史，如果有新边产生则实时更新直方图的计数结果。通过迭代的探索大规模图的近邻关系，发现了在上下文环境中系统实体的因果关系。该工作是UNICORN的第一步，具体来说，<strong>直方图中每个元素描述了图中唯一的一个子结构</strong>，同时考虑了子结构中的顶点与边上的异构标签，以及这些边的时间顺序。APT攻击缓慢的渗透攻击目标系统，希望基于的异常检测方法最终忘记这一行为，把其当成正常的系统行为，但是APT攻击并不能破坏攻击成功的相关信息流依赖关系。</li>
<li><strong>定期计算固定大小的概要图（graph sketch）</strong>。在纯流式环境，当UNICORN对整个溯源进行汇总时，唯一直方图元素的数量可能会任意增长。这种动态变化导致两个直方图之间的相似计算变得非常有挑战，从而使得基于直方图相似计算的建模以及检测算法变的不可行。<strong>UNICORN采用相似度保存的hash技术把直方图转换成概要图。概要图可以增量维护，也意味着UNICORN并不需要将整个溯源图都保存在内存中。</strong>另外，<strong>概要图保存了两个直方图之间的jaccard相似性，这在后续图聚类分析中特别有效。</strong></li>
<li><strong>将简略图聚类为模型</strong>。UNICORN可以在没有攻击知识的前提下实现APT攻击检测。与传统的聚类方法不同，UNICORN利用它的流处理能力生成一个动态演化模型。该模型通过在其运行的各个阶段对系统活动进行聚类捕获单个执行中的行为改变，但是UNICORN无法在攻击者破坏系统时动态实时修改模型。因此，它更适合APT攻击这类长期运行的攻击。</li>
</ol>
<h4><span id="41-溯源图">4.1 溯源图</span></h4><p>最近几年溯源图在攻击分析中越来越流行，并且本身固有的特别可以有效的用于APT检测。溯源图挖掘事件之间的因果关系，因果关系有助于对时间跨度较远的事件进行推理分析，因此有助于在检测APT相关攻击。</p>
<p>UNICORN根据两个系统执行的溯源图的相似性还判定两个系统的行为相似性。而且UNICORN总是考虑整个溯源来检测长期持续的攻击行为。<strong>当前已经有许多图相似度计算方法，然而这些算法大部分是NPC的，即使多项式时间复杂度的算法也无法满足整个溯源图快速增涨的需求。</strong></p>
<h4><span id="42-构建graph直方图">4.2 构建Graph直方图</span></h4><p>本文方法的目标是有效对溯源图进行比较分析，同时容忍正常执行中的微小变化。对于算法，我们有两个标准：</p>
<ul>
<li>图表示应考虑长期的因果关系；</li>
<li>必须能够在<strong>实时流图数据</strong>上实现该算法，以便能够在入侵发生时阻止入侵（不仅仅是检测到入侵）。</li>
</ul>
<p><strong><font color="red"> 本文基于一维WL同构检验，采用了线性时间的、快速的Weisfeiler-Lehman（WL）子树图核算法。该算法的使用依赖于构造的顶点直方图的能力，需要直方图能捕捉每个顶点周围的结构信息。</font></strong>根据扩充的顶点标签对顶点进行分类，这些标签完全描述了顶点的领域，并且<strong>通过迭代的标签传播来构造这些扩展的顶点标签</strong>。</p>
<p>同构性的WL检验及其子树kernel变化，以其对多种图的判别能力而闻名，超越了许多最新的图学习算法（例如，图神经网络）。对Weisfeiler-Lehman（WL）子树图核的使用取决于我们构建顶点直方图的能力，捕获围绕每个顶点的图结构。我们根据增强顶点标签对顶点进行分类，标签描述了顶点的R-hop邻居。</p>
<p>为了简单说明，假设有一个完整静态图，重标记对所有的输入标签的聚合。对每个顶点都重复执行这个过程来实现对n跳邻居的描述。一旦为图中的每个顶点都构建了扩展标签，那么就可以基于此生成一个直方图，其中每个bucket表示一个标签。两个图的相似性比较是基于以下假设：两个图如果相似那么在相似的标签上会有相似的分布。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555022.png" alt="图片" style="zoom: 67%;"></p>
<p>我们的目标是构建一个直方图，图中的每个元素对应一个唯一的顶点标签，用于捕获顶点的R-hop的in-coming邻居。</p>
<p><strong>信息流的多样性与复杂性（Streaming Variant and Complexity）</strong>。算法1只有新顶点出现或是新边出现对其邻顶点有影响时才会执行。本文方法只需要为每条新边更新其目标顶点的邻域。UNICORN采用这种偏序关系来最小化计算代价。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555986.png" alt="图片" style="zoom: 67%;"></p>
<p><strong>直方图元素的概念漂移问题</strong>。APT攻击场景需要模型必须能够处理长期运行行为分析能力，而系统行为的动态变化会导致溯源图的统计信息也随之变化，这种现象就叫概念漂移（concept drift）。</p>
<p>UNICORN通过对直方图元素计数使用指数权重衰减来逐渐消除过时的数据（逐渐忘记机制），从而解决了系统行为中的此类变化。它分配的权重与数据的年龄成反比。</p>
<script type="math/tex; mode=display">
H_h=\sum_t \mathbb{1}_{x_t=h}</script><p><strong>入侵检测场景中的适用性</strong>。上述“逐渐忘记”的方法，使得UNICORN可以着眼于当前的系统执行动态，而且那些与先前的object/activity有关系的事件不会被忘记。</p>
<h4><span id="43-生成概要图graph-sketches">4.3 生成概要图（Graph Sketches）</span></h4><p>Graph直方图是描述系统执行的简单向量空间图统计量。然而，与传统的基于直方图的相似性分析不同，UNICORN会随着新边的到来不断更新直方图。另外，UNCORN会根据图特征的分布来计算相似性，而不是利用绝对统计值。</p>
<p><strong><font color="red"> 本文采用locality sensitive hashing，也称作similarity-preserving data sketching。UNICORN的部署采用了前人的研究成果HistoSketch，该方法是一种基于一致加权采样的方法，且时间得性是常数。</font></strong></p>
<h4><span id="44-学习进化模型">4.4 学习进化模型</span></h4><p>在给定graph sketch和相似性度量的情况下，聚类是检测离群点常用的数据挖掘手段。<strong>然而传统的聚类方法无法捕获系统不断发展的行为</strong>。UNICORN利用其流处理的能力，创建了进化模型，可以捕获系统正常行为的变化。更重要的是，模型的建立是在训练阶段完成的，而不是在部署阶段，因为部署阶段训练模型可能会遭受中毒攻击。</p>
<p><strong><font color="red"> UNICORN在训练期间创建一个时序sketches，然后使用著名的K-medods算法从单个服务器对该概要序列进行聚类，使用轮廓系数（silhouette coefficient）确定最佳K值。</font></strong>每个簇表示系统执行的元状态（meta-states），如启动、初始化、稳定状态。然后UNICORN使用所有簇中sketches的时间顺序和每个簇的统计量（如直径、medoid），来生成系统进化的模型。</p>
<blockquote>
<ul>
<li><p>更新C中的每一列，即类中心 <img src="https://www.zhihu.com/equation?tex=c_j" alt="[公式]"> ,对于第j类，<strong>中心 <img src="https://www.zhihu.com/equation?tex=c_j" alt="[公式]"> 需要通过遍历所有该类中的样本，取与该类所有样本距离和最小的样本为该中心。</strong></p>
<p>K-means 模型: $\min <em>{G, C} \sum</em>{i=1}^n \sum<em>{j=1}^k g</em>{i j}\left|x_i-c_j\right|_2$<br>算法流程：</p>
</li>
</ul>
<ul>
<li>固定C,更新 G<ul>
<li>更新C中的每一列, 即类中心 $c_j$,其通过计算第j类中样本的平均值得到</li>
</ul>
</li>
</ul>
<p>K-mediods:模型： $\min <em>{G, C \subseteq X} \sum</em>{i=1}^n \sum<em>{j=1}^k g</em>{i j}\left|x_i-c_j\right|_1 \quad$ 可以是曼哈顿距离或其它距离度量;由于类中心的更新规 则，该方法较之于K-means更鲁棒。<br>  算法流程:</p>
<ul>
<li>固定C,更新 G</li>
<li>更新C中的每一列，即类中心$c<em>{j}$,对于第j类，**中心$c</em>{j}$需要通过遍历所有该类中的样本，取与该类所有样本距离和最小的样本为该中心。**</li>
</ul>
</blockquote>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191556090.png" alt="图片" style="zoom: 67%;"></p>
<p><strong>对于每个训练实例，UNICORN创建一个模型，该模型捕获系统运行时执行状态的更新。直观地说，这类似于跟踪系统执行状态的自动机。</strong>最终的模型由训练数据中所有种源图的多个子模型组成。</p>
<h4><span id="45-异常检测">4.5 异常检测</span></h4><p>在部署期间，异常检测遵循前面章节中描述的相同流模式。UNICORN周期性地创建graph sketch，因为直方图从流式溯源图演变而来。给定一个概要图，UNICORN将该概要与建模期间学习的所有子模型进行比较，将其拟合到每个子模型中的一个聚类中。</p>
<p><strong>UNICORN假设监视从系统启动开始，并跟踪每个子模型中的系统状态转换。要在任何子模型中为有效，概要必须适合当前状态或下一个状态；否则，被视为异常。因此，我们检测到两种形式的异常行为：</strong></p>
<ul>
<li>不符合现有聚类的概要</li>
<li>聚类之间的无效转换</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/29WR3P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/29WR3P/" class="post-title-link" itemprop="url">特征工程（0）【Nan】数据清洗</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-08 17:48:29" itemprop="dateCreated datePublished" datetime="2022-07-08T17:48:29+08:00">2022-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-18 16:48:00" itemprop="dateModified" datetime="2022-07-18T16:48:00+08:00">2022-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">特征工程</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>533</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="特征工程-数据清洗">特征工程-数据清洗</span></h2><blockquote>
<p>  特征工程 - 未来达摩大师的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/476659737">https://zhuanlan.zhihu.com/p/476659737</a></p>
<p>  这9个特征工程使用技巧，解决90%机器学习问题！ - Python与数据挖掘的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/462744763">https://zhuanlan.zhihu.com/p/462744763</a></p>
<p>  有哪些精彩的特征工程案例？ - 京东科技风险算法与技术的回答 - 知乎 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/400064722/answer/1308358333">https://www.zhihu.com/question/400064722/answer/1308358333</a></p>
</blockquote>
<p><img src="https://pic1.zhimg.com/v2-3baead31deae5b339481aa843a13e21c_b.jpg" alt="img"></p>
<p>数据格式内容错误数据来源有多种，有些是传感器采集，然后算法提取的特征数据；有些是采集的控制器的数据；还有一些应用场合，则是用户/访客产生的，数据肯定存在格式和内容上不一致的情况，所以在进行模型构建之前需要先进行数据的格式内容清洗操作。逻辑错误清洗主要是通过简单的逻辑推理发现数据中的问题数据，防止分析结果走偏，主要包含以下几个步骤：</p>
<p><strong><em>1.数据去重，去除或替换不合理的值；</em></strong></p>
<p><strong><em>2.去除或重构不可靠的字段值（修改矛盾的内容）；</em></strong></p>
<p><strong><em>3.去除异常点数据。</em></strong></p>
<h2><span id="采样">采样</span></h2><blockquote>
<p>  随机采样方法整理与讲解（MCMC、Gibbs Sampling等） - 向阳树的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109978580">https://zhuanlan.zhihu.com/p/109978580</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/31GH3TV/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/31GH3TV/" class="post-title-link" itemprop="url">高级威胁发现（5）Log2vec: A Heterogeneous Graph Embedding Based Approach for Detecting Cyber Threats within Enterprise</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-03 17:46:43" itemprop="dateCreated datePublished" datetime="2022-07-03T17:46:43+08:00">2022-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:55:27" itemprop="dateModified" datetime="2023-04-19T15:55:27+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="log2vec-a-heterogeneous-graph-embedding-based-approach-for-detecting-cyber-threats-within-enterprise"><strong>Log2vec: A Heterogeneous Graph Embedding Based Approach for Detecting Cyber Threats within Enterprise</strong></span></h2><blockquote>
<p>  【顶会论文解读】Log2vec 基于异构图Heterogeneous Graph 检测网络空间威胁 - 笑个不停的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/275952146">https://zhuanlan.zhihu.com/p/275952146</a></p>
<p>  <strong>AIops博客</strong>：<a target="_blank" rel="noopener" href="https://blog.csdn.net/markaustralia/category_11284226.html">https://blog.csdn.net/markaustralia/category_11284226.html</a></p>
<p>  <a target="_blank" rel="noopener" href="https://randy.blog.csdn.net/article/details/111773951?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-111773951-blog-118577347.pc_relevant_multi_platform_whitelistv1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-111773951-blog-118577347.pc_relevant_multi_platform_whitelistv1&amp;utm_relevant_index=2">基于深度学习的日志数据异常检测</a></p>
</blockquote>
<p>发表在<strong>CCS2019</strong>会议的一篇应用异质图embedding进行企业内部网络空间威胁检测的文章。</p>
<h3><span id="摘要">摘要</span></h3><p>内部人员的攻击以及APT攻击是组织常见的攻击类型，现有的检测算法多基于行为检测，大部分方法考虑log日志的序列关系以及用户的行为序列，忽略了其他的关系导致不使用于丰富多样的攻击场景。<strong>本文提出的Log2vec模型，将日志转化为异质图，将日志学习为低纬度的embedding并使用检测算法进行攻击检测（由于攻击样本较少，因此使用聚类算法进行检测）。</strong></p>
<h3><span id="一-引言">一、引言</span></h3><p>现有方法一般会转换用户的各种操作（也包括日志条目）分成序列，这些序列可以保存信息，例如 日志条目之间的顺序关系，然后使用序列处理技术，例如 深度学习从过去的事件中学习并预测下一个事件。<strong>本质上，这些日志条目级别的方法可以模拟用户的正常行为行为并将其偏离标记为异常。</strong></p>
<p>但是，这种方法忽略了其他关系。 例如，<strong>比较用户的日常行为是常规内部威胁检测的一种常用方法</strong>。 此检测基于以下前提：用户的日常行为在一段时间内（几天之间的逻辑关系）相对规则。 上述预测方法忽略了这种关系，并且会降低其性能。 此外，他们需要正常的日志条目，甚至需要大量标记数据来进行模型训练。 但是，在现实世界中，存在罕见的攻击动作，从而限制了其正确预测的能力。</p>
<p><strong>对于检测内部威胁以及APT攻击来说，我们面临三个问题：</strong></p>
<p>（1）<strong>如何同时检测上述两种攻击情形，特别是考虑到检测系统中提到的所有三种关系（日志之间序列关系 sequantial relationship among log entries、几天之内的逻辑关系logical relationship among days以及交互关系interactive relationship among hosts）；</strong></p>
<p><strong>解决办法</strong>：构建异构图来表示前面提到的三种关系；</p>
<p>（2）<strong>如何在APT场景中进行细粒度的检测，尤其是深入挖掘和分析主机内日志条目之间的关系；</strong></p>
<p><strong>解决办法</strong>：将日志条目分为五个属性。根据这些属性，我们深入考虑了主机内日志之间的关系，并设计了精细的规则来关联它们。这种设计使正常和异常日志条目可以在这种图中拥有不同的拓扑；</p>
<p>（3）<strong>如何针对训练模型进行无攻击样本的检测。【内部威胁】</strong></p>
<p><strong>解决办法</strong>：log2vec的图嵌入和检测算法将日志条目表示并分组到不同的群集中，而没有攻击样本，适用于数据不平衡的情况（针对问题3）。此外，图形嵌入本身可以自动学习每个操作的表示形式（矢量），而无需手动提取特定于领域的特征，从而独立于专家的知识。我们的改进版本可以进一步差分提取并表示来自上述异构图的操作之间的多个关系。</p>
<h3><span id="二-文章的设计">二、<strong>文章的设计</strong></span></h3><p><strong>Log2vec包含以下三个组件：</strong></p>
<ul>
<li><p><strong>图的构造。</strong> Log2vec构造一个异构图以集成日志之间的多个关系条目;</p>
</li>
<li><p><strong>图嵌入</strong>（也是图表示学习）。这是一种强大的图形处理方法，可用于了解每个操作的</p>
<p>表示（向量）基于它们在这种图中的关系。通过矢量化用户操作，可以直接比较他们的操作</p>
<p>找出异常的相似之处；</p>
</li>
<li><p><strong>检测算法，</strong>无监督，要有效将恶意操作分组为单个群集</p>
</li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555029.png" alt="image-20220703183858975" style="zoom:50%;"></p>
<h3><span id="三-概述">三、概述</span></h3><p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555735.png" alt="image-20220703184011385" style="zoom:50%;"></p>
<p>如图2（a）所示，<strong>日志记录了用户的操作，如登录操作，设备之间移动操作以及网络操作</strong>。图2（b）描述日志的属性，<strong>主体（user），操作类型（visit或者send），客体（网址或者是邮件）以及时间和主机（设备ID）</strong>。实际上，日志的属性能够反映用户的行为，比如，第一个登录的时间和日志结束的时间能够反映用户的工作时长。系统管理员会频繁的登录服务器和操作对系统进行维护。</p>
<p>图2（c）将a中显示的<strong>日志组成序列</strong>，然后使用如LSTM的方法学习日志序列信息进行预测。此类模型能够捕捉日志的因果信息和序列关系。但是，这样的方法忽视了其他关系，比如（a）中day3序列，有大量的设备连接和文件复制的操作，远比以前多（这意味着数据泄露）。 可以通过直接比较用户的日常行为来检测出这种差异。进行比较的前提是，在一段时间内（几天之间的逻辑关系），用户的日常行为相对规则且相似。 虽然是深度学习，例如 LSTM可以记住序列的长期依赖关系（多天），它没有明确比较用户的日常行为，也无法获得令人满意的性能。 类似地，它们不能保持图2d中主机之间的另一种关系，交互关系，并且不能在APT检测中正常工作。 另外，其中一些需要大量标记数据进行培训。 但是，在我们的检测方案中，存在罕见的攻击行为。</p>
<p>图2d展示了图2a中的登录（红色字体）的图表，<strong>该图表指示用户在主机之间的行为</strong>。 我们可以分析主机之间的这些交互关系，以发现异常登录。 例如，管理员可以定期登录到一组主机以进行系统维护，而APT实施者只能访问他可以访问的主机。 登录跟踪的功能可以捕获这种差异。例如，良性跟踪中涉及的主机数量（1或3，实线）通常不同于APT（2，虚线）。在分析了这些功能之后，可以识别出受感染的主机。 但是，这些主机包含许多良性操作，并且手动提取的特定于域的特征显然无法应用于图2c中的攻击。</p>
<p>本文构建的模型用于检测以下类型的攻击： 第一种情况是<strong>内部人员滥用职权执行恶意操作，例如访问数据库或应用程序服务器，然后破坏系统或窃取知识产权以谋取个人利益</strong>。 其次，<strong>恶意内部人员通过窥视或密钥记录器获取其他合法用户的凭据，并利用此新身份来寻找机密信息或在公司中造成混乱</strong>。 这两种情况属于内部员工的典型攻击。 第三种攻击是<strong>APT参与者破坏了系统中的主机，并从该主机中持续破坏了多个主机，以提升其特权并窃取机密文件。</strong></p>
<h3><span id="四-详细论述"><strong>四、详细论述</strong></span></h3><h4><span id="41-图构建">4.1 图构建</span></h4><p><strong><font color="red"> 本文构建的图的节点是日志，只有一种节点类型，边是通过规则来建立联系的，本文提出10条规则，代表着图有10种边类型。因此，本文构建的异构图只是边类型不同，节点类型是相同的。</font></strong></p>
<p><strong>定义：<sub,obj,a,t,h> 提取日志的五个主要属性：subject, object, operation type, time and host，称为元属性</sub,obj,a,t,h></strong></p>
<ul>
<li>sub表示用户集合；</li>
<li>obj表示客体集合（文件、移动存储设备、网站）；</li>
<li>A是操作类型集合（文件操作和网页利用）；</li>
<li>T表示时间</li>
<li>H是主机（计算机或者是服务器）。</li>
</ul>
<p><strong>sub,obj,A,H有自己的子属性</strong>。比如，用户在服务器中写入文件，sub的属性包括用户角色（系统管理员等）和所属单位；obj属性包括文件类型和大小；H属性包括是文件服务器还是邮件服务器；对于登录操作，A的属性包括身份验证。对于用户登录，可以表示为user (sub) logs in to (A) a destination host (obj) in a source one (H),</p>
<h4><span id="42-构建图的规则">4.2 <strong>构建图的规则</strong></span></h4><p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555928.png" alt="image-20220703193951973" style="zoom:50%;"></p>
<p>上图，R1-3描述一天中的因果关系和序列关系；R4-6描述多天之间的逻辑关系；R7 R9描述用户登录和web浏览行为序列。R8 R10按照逻辑关系进行关联。</p>
<p><strong>log2vec考虑三种关系：</strong></p>
<ul>
<li>causal and sequential relationships within a day; 一天内的因果关系和顺序关系；</li>
<li>logical relationships among days；日之间的逻辑关系</li>
<li>logical relationships among objects；对象之间的逻辑关系。</li>
</ul>
<p>在设计有关这三种关系的规则时，我们考虑这些元属性的不同组合，以关联较少的日志条目，并将更精细的日志关系映射到图中。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191555332.png" alt="image-20220703194402679" style="zoom:50%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/2ZWAT5R/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/2ZWAT5R/" class="post-title-link" itemprop="url">机器学习（11）CatBoost</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-02 15:21:08" itemprop="dateCreated datePublished" datetime="2022-07-02T15:21:08+08:00">2022-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-16 21:38:38" itemprop="dateModified" datetime="2023-04-16T21:38:38+08:00">2023-04-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">集成学习</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="深入理解catboost">深入理解CatBoost</span></h2><blockquote>
<p>  深入理解CatBoost - Microstrong的文章 - 知乎 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102540344">https://zhuanlan.zhihu.com/p/102540344</a></p>
</blockquote>
<p><strong>本文主要内容概览：</strong></p>
<p><img src="https://pic1.zhimg.com/v2-f6a9520c6db0ba77ad620800cb36c054_b.jpg" alt="img"></p>
<h3><span id="一-catboost简介"><strong>一、CatBoost简介</strong></span></h3><p>CatBoost是俄罗斯的搜索巨头Yandex在2017年开源的机器学习库，是Boosting族算法的一种。CatBoost和XGBoost、LightGBM并称为GBDT的三大主流神器，都是在GBDT算法框架下的一种改进实现。XGBoost被广泛的应用于工业界，LightGBM有效的提升了GBDT的计算效率，而Yandex的CatBoost号称是比XGBoost和LightGBM在算法准确率等方面表现更为优秀的算法。</p>
<p>CatBoost是一种基于对称决策树（oblivious trees）为基学习器实现的参数较少、支持类别型变量和高准确性的GBDT框架，主要解决的痛点是高效合理地处理类别型特征，这一点从它的名字中可以看出来，<strong>CatBoost是由Categorical和Boosting组成。此外，CatBoost还解决了梯度偏差（Gradient Bias）以及预测偏移（Prediction shift）的问题，从而减少过拟合的发生，进而提高算法的准确性和泛化能力。</strong></p>
<p><strong>与XGBoost、LightGBM相比，CatBoost的创新点有：</strong></p>
<ul>
<li><strong>嵌入了自动将类别型特征处理为数值型特征的创新算法。首先对categorical features做一些统计，计算某个类别特征（category）出现的频率，之后加上超参数，生成新的数值型特征（numerical features）。</strong></li>
<li><strong>Catboost还使用了组合类别特征，可以利用到特征之间的联系，这极大的丰富了特征维度</strong>。</li>
<li>采用排序提升的方法对抗训练集中的噪声点，从而避免梯度估计的偏差，进而解决预测偏移的问题。</li>
<li>采用了<strong>完全对称树作为基模型</strong>。</li>
</ul>
<h3><span id="二-类别型特征">二、<strong>类别型特征</strong></span></h3><p><strong>所谓类别型特征，即这类特征不是数值型特征，而是离散的集合</strong>，比如省份名（山东、山西、河北等），城市名（北京、上海、深圳等），学历（本科、硕士、博士等）。在梯度提升算法中，最常用的是将这些类别型特征转为数值型来处理，一般类别型特征会转化为一个或多个数值型特征。</p>
<p><strong>类别型特征基数比较低（low-cardinality features）</strong>，即该特征的所有值去重后构成的集合元素个数比较少，一般利用One-hot编码方法将特征转为数值型。One-hot编码可以在数据预处理时完成，也可以在模型训练的时候完成，从训练时间的角度，后一种方法的实现更为高效，CatBoost对于基数较低的类别型特征也是采用后一种实现。</p>
<p><strong>高基数类别型特征（high cardinality features）</strong>当中，比如 <code>user ID</code>，这种编码方式会产生大量新的特征，造成维度灾难。一种折中的办法是可以将类别分组成有限个的群体再进行One-hot编码。<strong>一种常被使用的方法是根据目标变量统计（Target Statistics，以下简称TS）进行分组</strong>，目标变量统计用于估算每个类别的目标变量期望值。甚至有人直接用TS作为一个新的数值型变量来代替原来的类别型变量。<strong><font color="red"> 重要的是，可以通过对TS数值型特征的阈值设置，基于对数损失、基尼系数或者均方差，得到一个对于训练集而言将类别一分为二的所有可能划分当中最优的那个。</font></strong></p>
<p>在LightGBM当中，类别型特征用每一步梯度提升时的梯度统计（Gradient Statistics，以下简称GS）来表示。虽然为建树提供了重要的信息，但是这种方法有以下两个缺点：</p>
<ul>
<li>增加计算时间，因为需要对每一个类别型特征，在迭代的每一步，都需要对GS进行计算；</li>
<li>增加存储需求，对于一个类别型变量，需要存储每一次分离每个节点的类别；</li>
</ul>
<p><strong>为了克服这些缺点，LightGBM以损失部分信息为代价将所有的长尾类别归为一类</strong>，作者声称这样处理高基数类别型特征时比One-hot编码还是好不少。不过如果采用TS特征，那么对于每个类别只需要计算和存储一个数字。</p>
<p>因此，采用TS作为一个新的数值型特征是最有效、信息损失最小的处理类别型特征的方法。TS也被广泛应用在点击预测任务当中，这个场景当中的类别型特征有用户、地区、广告、广告发布者等。接下来我们着重讨论TS，暂时将One-hot编码和GS放一边。</p>
<h4><span id="21-目标变量统计target-statistics">2.1 <strong>目标变量统计（Target Statistics）</strong></span></h4><p><strong><font color="red"> CatBoost算法的设计初衷是为了更好的处理GBDT特征中的categorical features</font></strong>。在处理 GBDT特征中的categorical features的时候，最简单的方法是用 categorical feature 对应的标签的平均值来替换。在决策树中，标签平均值将作为节点分裂的标准。<strong>这种方法被称为 Greedy Target-based Statistics , 简称 Greedy TS</strong>，用公式来表达就是：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k%5Ei%3D%5Cfrac%7B%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%5Bx_%7Bj%2Ck%7D%3Dx_%7Bi%2Ck%7D%5D%5Ccdot+Y_i%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bn%7D%5Bx_%7Bj%2Ck%7D%3Dx_%7Bi%2Ck%7D%5D%7D+%5C%5C" alt="[公式]"></p>
<p>这种方法有一个显而易见的缺陷，就是通常特征比标签包含更多的信息，<strong><font color="red"> 如果强行用标签的平均值来表示特征的话，当训练数据集和测试数据集数据结构和分布不一样的时候会出条件偏移问题。</font></strong></p>
<p>一个标准的改进 Greedy TS的方式是添加先验分布项，这样可以减少噪声和低频率类别型数据对于数据分布的影响：</p>
<p><img src="https://www.zhihu.com/equation?tex=%5Chat%7Bx%7D_k%5Ei%3D%5Cfrac%7B%5Csum_%7Bj%3D1%7D%5E%7Bp-1%7D%7B%5Bx_%7B%5Csigma_%7Bj%2Ck%7D%7D%3Dx_%7B%5Csigma_%7Bp%2Ck%7D%7D%5D%7DY_%7B%5Csigma_%7Bj%7D%7D%2Ba%5Ccdot+p%7D%7B%5Csum_%7Bj%3D1%7D%5E%7Bp-1%7D%7B%5Bx_%7B%5Csigma_%7Bj%2Ck%7D%7D%3Dx_%7B%5Csigma_%7Bp%2Ck%7D%7D%5D%7D%2Ba%7D+%5C%5C" alt="[公式]"></p>
<p> 其中$p$是添加的先验项， $a$通常是大于 <img src="https://www.zhihu.com/equation?tex=+0+" alt="[公式]"> 的权重系数。添加先验项是一个普遍做法，针对类别数较少的特征，它可以减少噪声数据。对于回归问题，一般情况下，先验项可取数据集label的均值。对于二分类，先验项是正例的先验概率。利用多个数据集排列也是有效的，但是，如果直接计算可能导致过拟合。CatBoost利用了一个比较新颖的计算叶子节点值的方法，这种方式(oblivious trees，对称树)可以避免多个数据集排列中直接计算会出现过拟合的问题。</p>
<p>当然，在论文《CatBoost: unbiased boosting with categorical features》中，还提到了其它几种改进Greedy TS的方法，分别有：Holdout TS、Leave-one-out TS、Ordered TS。我这里就不再翻译论文中的这些方法了，感兴趣的同学可以自己翻看一下原论文。</p>
<h4><span id="22-特征组合">2.2 <strong>特征组合</strong></span></h4><p>值得注意的是几个类别型特征的任意组合都可视为新的特征。例如，在音乐推荐应用中，我们有两个类别型特征：用户ID和音乐流派。如果有些用户更喜欢摇滚乐，将用户ID和音乐流派转换为数字特征时，根据上述这些信息就会丢失。结合这两个特征就可以解决这个问题，并且可以得到一个新的强大的特征。然而，组合的数量会随着数据集中类别型特征的数量成指数增长，因此不可能在算法中考虑所有组合。为当前树构造新的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=分割点&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;102540344&quot;}">分割点</a>时，CatBoost会采用贪婪的策略考虑组合。对于树的第一次分割，不考虑任何组合。对于下一个分割，CatBoost将当前树的所有组合、类别型特征与数据集中的所有类别型特征相结合，并将新的组合类别型特征动态地转换为数值型特征。CatBoost还通过以下方式生成数值型特征和类别型特征的组合：树中选定的所有分割点都被视为具有两个值的类别型特征，并像类别型特征一样被进行组合考虑。</p>
<h4><span id="23-catboost处理categorical-features总结">2.3  <strong>CatBoost处理Categorical features总结</strong></span></h4><ul>
<li><strong>首先计算一些数据的statistics。计算某个category出现的频率，加上超参数，生成新的numerical features</strong>。这一策略要求同一标签数据不能排列在一起（即先全是0之后全是1这种方式），训练之前需要打乱数据集。</li>
<li>使用数据的不同排列（实际上是4个）。在每一轮建立树之前，先扔一轮骰子，决定使用哪个排列来生成树。</li>
<li>考虑使用categorical features的不同组合。例如颜色和种类组合起来，可以构成类似于blue dog这样的特征。当需要组合的categorical features变多时，CatBoost只考虑一部分<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=combinations&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;102540344&quot;}">combinations</a>。在选择第一个节点时，只考虑选择一个特征，例如A。在生成第二个节点时，考虑A和任意一个categorical feature的组合，选择其中最好的。就这样使用贪心算法生成combinations。</li>
<li><strong>除非向gender这种维数很小的情况，不建议自己生成One-hot编码向量，最好交给算法来处理。</strong></li>
</ul>
<h2><span id="三-catboostqampa">三、CatboostQ&amp;A</span></h2><h4><span id="31-catboost与xgboost-lightgbm的联系与区别">3.1 <strong>CatBoost与XGBoost、LightGBM的联系与区别？</strong></span></h4><p>（1）2014年3月XGBoost算法首次被<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=陈天奇&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;102540344&quot;}">陈天奇</a>提出，但是直到2016年才逐渐著名。2017年1月微软发布LightGBM第一个稳定版本。2017年4月Yandex开源CatBoost。自从XGBoost被提出之后，很多文章都在对其进行各种改进，CatBoost和LightGBM就是其中的两种。</p>
<p>（2）<strong>CatBoost处理类别型特征十分灵活，可直接传入类别型特征的列标识，模型会自动将其使用One-hot编码，还可通过设置 one_hot_max_size参数来限制One-hot特征向量的长度</strong>。如果不传入类别型特征的列标识，那么CatBoost会把所有列视为数值特征。对于One-hot编码超过设定的one_hot_max_size值的特征来说，CatBoost将会使用一种高效的encoding方法，与mean encoding类似，但是会降低过拟合。处理过程如下：</p>
<ul>
<li>将输入样本集随机排序，并生成多组随机排列的情况；</li>
<li>将浮点型或属性值标记转化为整数；</li>
<li>将所有的类别型特征值结果都根据以下公式，转化为数值结果；</li>
</ul>
<p><img src="https://www.zhihu.com/equation?tex=avg%5C_target+%3D+%5Cfrac%7BcountInClass+%2B+prior%7D%7BtotalCount+%2B+1%7D+%5C%5C" alt="[公式]"> </p>
<p>其中 countInClass 表示在当前类别型特征值中有多少样本的标记值是1；prior 是分子的初始值，根据初始参数确定。totalCount 是在所有样本中（包含当前样本）和当前样本具有相同的类别型特征值的样本数量。</p>
<p>LighGBM 和 CatBoost 类似，也可以通过使用特征名称的输入来处理类别型特征数据，它没有对数据进行独热编码，因此速度比独热编码快得多。LighGBM 使用了一个特殊的算法来确定属性特征的分割值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train_data = lgb.Dataset(data, label=label, feature_name=[<span class="string">&#x27;c1&#x27;</span>, <span class="string">&#x27;c2&#x27;</span>, <span class="string">&#x27;c3&#x27;</span>], categorical_feature=[<span class="string">&#x27;c3&#x27;</span>])</span><br><span class="line"><span class="comment"># 注意，在建立适用于 LighGBM 的数据集之前，需要将类别型特征变量转化为整型变量，此算法不允许将字符串数据传给类别型变量参数。</span></span><br></pre></td></tr></table></figure>
<p>（3）XGBoost 和 CatBoost、 LighGBM 算法不同，XGBoost 本身无法处理类别型特征，而是像随机森林一样，只接受数值数据。因此在将类别型特征数据传入 XGBoost 之前，必须通过各种编码方式：例如序号编码、独热编码和二进制编码等对数据进行处理。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/3ADMGV5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/3ADMGV5/" class="post-title-link" itemprop="url">风控反欺诈（2）GraphSAGE算法在网络黑产挖掘中的思考</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-30 14:24:55" itemprop="dateCreated datePublished" datetime="2022-06-30T14:24:55+08:00">2022-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:34:05" itemprop="dateModified" datetime="2023-04-19T15:34:05+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/" itemprop="url" rel="index"><span itemprop="name">工业落地</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">业务安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="graphsage图算法在网络黑产挖掘中的思考">GraphSAGE图算法在网络黑产挖掘中的思考</span></h2><blockquote>
  <font color="blue"> Harry 高级研究员-DataFunTalk https://mp.weixin.qq.com/s/sZ7VQz26c5mrWAsnMKx8Hw</font>

  <font color="blue"> **graphSAGE-pytorch**：https://github.com/twjiang/graphSAGE-pytorch/tree/master/src</font>

<p>  <strong>导读：</strong>虚拟网络中存在部分黑产用户，这部分用户通过违法犯罪等不正当的方式去谋取利益。作为恶意内容生产的源头，管控相关黑产用户可以保障各业务健康平稳运行。<strong>当前工业界与学术界的许多组织通常采用树形模型、社区划分等方式挖掘黑产用户，但树形模型、社区划分的方式存在一定短板，为了更好地挖掘黑产用户，我们通过图表征学习与聚类相结合的方式进行挖掘</strong>。本文将为大家介绍图算法在网络黑产挖掘中的思考与应用，主要介绍：</p>
<ul>
<li>图算法设计的背景及目标</li>
<li>图算法GraphSAGE落地及优化</li>
<li>孤立点&amp;异质性</li>
<li>总结思考</li>
</ul>
</blockquote>
<h3><span id="一-图算法设计的背景"><strong>一、 图算法设计的背景</strong></span></h3><p>在虚拟网络中存在部分的黑产用户，这部分用户通过违法犯罪等不正当的方式去谋取利益，比如招嫖、色情宣传、赌博宣传的行为，更有甚者，如毒品、枪支贩卖等严重的犯罪行为。当前工业界与学术界的许多组织推出了基于图像文字等内容方面的API以及解决方案。而本次主题则是介绍基于账号层面上的解决方法，为什么需要在账号层面对网络黑产的账号进行挖掘呢？</p>
<p><strong>原因主要有三：</strong></p>
<ul>
<li><strong>恶意账号是网络黑产的源头，在账号层面对网络黑产的账号进行挖掘可以对黑产的源头进行精准地打击</strong>；</li>
<li>账号行为对抗门槛高，用户的行为习惯以及关系网络是很难在短期内作出改变的，而针对单一的黑产内容可以通过多种方式避免被现有的算法所感知，虽然黑产用户可能不懂算法，但其可以通过“接地气”的方式来干扰算法模型，譬如在图片上进行简单的涂抹，在敏感处打上马赛克，在图片处加上黑框，通过简单的对抗手段会对基于黑产内容的算法产生较大的影响；</li>
<li>可以防范于未然，通过账号层面的关联提前圈定可疑账号，在其进行违法犯罪行为之前对账号进行相应的处理以及管控。</li>
</ul>
<p><strong>具体通过什么方式挖掘黑产账号？</strong></p>
<p>首先，简单介绍下在推荐场景中应用。比如广告推荐，通常上，广告商会给予平台方用户的用户标签，用户存在用户标签之后，平台方则会将相关类别的用户找出，然后将广告推送给对应的用户；另一种方式是广告方提供种子包给平台方，平台方会找到相似的用户，然后将广告推送给相关的用户，常见的应用场景有Facebook look like、Google similar audiences。</p>
<h4><span id="11-应用场景">1.1 应用场景</span></h4><p><strong>在黑产场景中与推荐场景中的应用类似，主要分为两个任务场景：</strong></p>
<ul>
<li>找出目标恶意类别用户。比如需要找出散播招嫖信息的用户，则给定该类用户招嫖的标签，类似于一个用户定性的问题；</li>
<li>黑产种子用户扩散，即利用历史的黑产用户进行用户扩散以及用户召回，可以通过染色扩散以及相似用户检索等方式完成。</li>
</ul>
<p><strong><font color="red"> 针对恶意用户定性的传统方法，通常采用树形模型，比如说XGboost、GBDT等</font></strong>。这类算法短板显而易见，其<strong>缺乏对用户之间的关联进行考虑</strong>；另外一种<strong>用户召回方式为用户社区划分（相似用户召回），其中比较常用的社区划分算法有FastUnfolding、Copra等</strong>。这类算法的缺陷也相当明显，其由于原本社区规模小，所以最终召回的人数也少。且会存在多个种子用户在同一个社区的情况，<strong>难以召回大量可疑用户</strong>。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533000.jpeg" alt="图片" style="zoom:50%;"></p>
<p><strong><font color="red"> 通过图表征学习与聚类相结合的方式进行召回</font></strong>。<strong>通过图表征学习将图结构的节点属性以及结构特征映射到一个节点低维空间，由此产生一个节点特征，然后再去进行下游的任务，如用户定性即节点分类等</strong>。其中，图表征学习的关键点在于在进行低维的映射当中需要保留原始图的结构和节点属性信息。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533575.jpeg" alt="图片" style="zoom:50%;"></p>
<h4><span id="12-图算法设计">1.2 图算法设计</span></h4><ul>
<li>算法的覆盖率和精准度；</li>
<li>用户分群规模合理，保证分群的可用性；</li>
<li><strong>支持增量特征，下游任务易用性</strong>。</li>
</ul>
<p>由于业务场景更多为动态网络，当新增节点时，如果模型支持增量特征，则不需要重复训练模型，可以极大的减少开发的流程，节省机器学习的资源，缩短任务完成的时间。</p>
<h3><span id="二-图算法graphsage落地及优化">二、图算法GraphSAGE落地及优化</span></h3><h4><span id="21-graphsage核心思想">2.1 GraphSAGE核心思想</span></h4><p><strong><font color="red"> GraphSAGE核心思想主要为两点：邻居抽样；特征聚合。</font></strong></p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533811.jpeg" alt="图片" style="zoom:50%;"></p>
<p><strong>GraphSAGE的聚合过程实际是节点自身的属性特征和其抽样的邻居节点特征分别做一次线性变换，然后将两者concat在一起，再进行一次线性变换得到目标节点的embedding特征</strong>。最后利用得到的目标节点的embedding特征进行下游的任务，训练的方式的可以采用无监督的方式，如<strong>NCE Loss</strong>。</p>
<h4><span id="22-graphsage的优点">2.2 <strong>GraphSAGE的优点</strong></span></h4><p><strong>GraphSAGE通过邻居抽样的方式解决了GCN内存爆炸的问题</strong>，同时可以将<strong>==直推式学习转化为归纳式学习==</strong>，<strong>==避免了节点的embedding特征每一次都需要重新训练的情况，支持了增量特征==</strong>。为什么通过邻居随机抽样就可以使得直推式的模型变为支持增量特征的归纳式模型呢？</p>
<p>在原始的GraphSAGE模型（直推式模型）当中，节点标签皆仅对应一种局部结构、一种embedding特征。在GraphSAGE引入邻居随机抽样之后，节点标签则变为对应多种局部结构、多种embedding特征，这样可以防止模型在训练过程过拟合，增强模型的泛化能力，则可以支持增量特征。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533971.jpeg" alt="图片" style="zoom:50%;"></p>
<h4><span id="23-graphsage的缺点">2.3 <strong>GraphSAGE的缺点</strong></span></h4><ul>
<li><strong>原GraphSAGE无法处理加权图，仅能够邻居节点等权聚合</strong>；</li>
<li>抽样引入随机过程，推理过程中同一节点embedding特征不稳定；</li>
<li>抽样数目限制会导致部分局部信息丢失；</li>
<li>GCN网络层太多容易引起训练中过度平滑问题。</li>
</ul>
<h4><span id="24-graphsage的优化">2.4 <strong>GraphSAGE的优化</strong></span></h4><p>为解决上述GraphSAGE存在的缺点，对GraphSAGE进行优化。</p>
<h5><span id="聚合优化">聚合优化:</span></h5><p>解决等权聚合的问题。相对于直接将邻居节点进行聚合，将边权重进行归一化之后，点的邻居节点的特征进行点燃，最后再进行特征融合。这样做的好处主要有两点：边权重越大的邻居，对目标节点影响越大；节点边权重归一化在预处理阶段完成，几再与目标节乎不影响算法速度。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533699.jpeg" alt="图片" style="zoom:50%;"></p>
<h5><span id="剪枝优化">剪枝优化:</span></h5><p>解决embedding特征不稳定的问题。<strong>在训练的过程希望通过引入随机过程防止模型出现过拟合的现象</strong>，<strong>但是在模型的推理过程式是想要去掉这样一个随机过程</strong>。直接对原始网络进行剪枝操作，仅保留每个节点权重最大的K条边，在模型进行推理的时候，会将目标节点所有的K个邻居节点的特征都聚合到目标节点上，聚合方式同样为加权的方式。<strong>这样做的好处主要有两个点：在网络结构不变的情况下，保证同节点embedding特征相同；在保证算法精度的前提下，大幅度降低图的稠密程度，降低内存开销。</strong></p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533517.jpeg" alt="图片" style="zoom:50%;"></p>
<h5><span id="采样优化">==采样优化:==</span></h5><p><strong>解决局部信息丢失以及训练过平滑的问题</strong>。主要通过<strong>DGL的抽样方式代替原有的抽样方式</strong>，具体的做法为：提前将每一个节点的属性特征与它所有的邻居节点的属性特征的均值进行concat，这样可以使得每一个节点初始状态下已经包含了周围一些邻居节点的一些信息，通过这种方式，在采样相同节点的前提下，可以获得更多的局部信息。<strong>一般情况下，GCN模型采用两层网络模型，当增加至第三层的时候则将存在内存爆炸的问题</strong>；当增加至第四层时，则将出现过平滑的问题，将导致特征分布去重，这样则导致节点没有区分性。而采用DGL采样，通过采样两层GCN模型而实际上采样了三层，而且不会出现过平滑问题。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533122.jpeg" alt="图片" style="zoom:50%;"></p>
<h4><span id="25-效果评估"><strong>2.5 效果评估</strong></span></h4><p>效果评估的指标主要有两个：<strong>聚类（社区）准确率；召回恶意率</strong>。相对于原有的fastunfolding以及<strong>node2vec</strong>从聚类准确率、召回恶意率、平均社区规模、运行时间作一个横向对比：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533948.jpeg" alt="图片" style="zoom:50%;"></p>
<h4><span id="三-孤立点amp异质性">三、<strong>孤立点&amp;异质性</strong></span></h4><h4><span id="31-黑产挖掘场景中的孤立点的解决思路"><strong>3.1 黑产挖掘场景中的孤立点的解决思路</strong></span></h4><p><strong>黑产用户在被处理后，通常会快速地申请新的账号或使用备用账号，因为在对黑产的挖掘过程中就不可避免地会出现孤立点</strong>，类似在推荐算法中的冷启动问题。以node2vec算法为例，算法通常会通过游走去构造训练的节点段，那么如果孤立节点没有连边的话，节点是无法出现在训练集当中。<strong><font color="red"> 为了解决该问题，引入一个解决推荐系统冷启动的算法——EGES</font></strong>，将每一个节点的属性特征映射到一个embedding特征，然后将每一个属性的embedding特征置于注意力层进行处理，比如将N个随机特征通过注意力加权，可以获得最终的一个节点层面的embedding特征，新增的节点将不再依赖于关系网络以及用户的一些交互行为，新增的节点可以通过自身的属性特征就直接获得我们的embedding特征，不需要考虑用户关系从而解决孤立点的问题。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533883.jpeg" alt="图片" style="zoom:50%;"></p>
<p>在具体落地过程中，提出了GraphSAGE-EGES算法，实际上是综合了两种算法的优势，GraphSAGE的节点本身的初始特征将其替换成了EGES增强之后的属性特征，通过此类方式，最终的算法框架如下图所示：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533345.jpeg" alt="图片" style="zoom:50%;"></p>
<h4><span id="32-黑产网络中异质性的解决思路"><strong>3.2 黑产网络中异质性的解决思路</strong></span></h4><p>在正常的网络结构当中，一个用户的一阶邻居基本上都是同一类的用户，比如说在学术引用当中，一篇数据挖掘的论文，引用其的论文也多是与数据挖掘相关的。这一类的网络称之为同质性网络。<strong>但在黑产的关系网络当中，图的异质性就非常高了，黑产用户不仅仅与黑产用户相关，其也可以与正常用户建立关系，这种特殊的网络结构就会存在一些弊端</strong>，以下图异质性网络为例，圈住的正常节点的一阶邻居节点一半为恶意账号，算法进行预测、聚类时，该节点很多概率会被判定为恶意账号。圈住的恶意节点的一阶邻居3个皆为正常账号，算法进行预测、聚类时，该节点则大概率被判定为正常节点，导致算法的精度下降。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533084.jpeg" alt="图片" style="zoom:50%;"></p>
<p>为了解决上述问题，需要去考虑网络的结构是否合理。为了构建合理的网络结构，需要将恶意账号与正常账号之间存在的联系剔除掉，并将恶意账号之间的联系进行一定的增强。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533269.jpeg" alt="图片" style="zoom:50%;"></p>
<p>当网络结构合理时，算法进行预测、聚类时会更加准确，因此引入图结构学习的概念，尝试用LDS算法解决这类问题。</p>
<p>LDS算法的思想：在训练GCN模型的参数的同时对网络的结构进行调整，在最初的时候给予一个网络结构（邻接矩阵），先固定GCN的模型，然后训练邻接矩阵，通过几轮迭代之后再固定邻接矩阵，再训练GCN模型，通过几轮迭代之后，可以得出一个合理的网络结构。</p>
<p><strong>总的来说，这个算法实际上就是一个极大似然估计以及伯努利分布的问题。在LDS算法学习邻接矩阵的时候实际就是学习两个点的邻边是否应该存在，实际上为一个0-1分布。</strong>最终通过网络结构以及节点的标签去预估在当前数据标签的情况下，更应该得到什么样的一个网络结构，以上即为该算法的核心思想。</p>
<p>实际上，在许多业务场景当中会存在许多不合理的图结构，甚者在某些业务场景中不存在关系信息，这样的话，在最初达不到完整网络的情况时，通常会使用KNN的方式对网络进行初始化，然后再去学习一个更加合理的网络结构，最终达到一个更好节点预测、聚类的目的。</p>
<p><strong><font color="red"> 实际上，在许多业务场景当中会存在许多不合理的图结构，甚者在某些业务场景中不存在关系信息，这样的话，在最初达不到完整网络的情况时，通常会使用KNN的方式对网络进行初始化，然后再去学习一个更加合理的网络结构，最终达到一个更好节点预测、聚类的目的。</font></strong></p>
<h3><span id="四-总结思考">四、<strong>总结思考</strong></span></h3><p>下面分享几点在算法落地以及算法选择中的一些工作总结与思考：</p>
<ul>
<li><strong><font color="red"> 针对图算法这块，特征工程和图的构建方式是非常重要的</font></strong>。如果图的结构不合理的话，即使算法模型再强大、特征工程处理得再好，算法训练出的结果也不是最终理想的效果；</li>
<li><strong><font color="red"> 多数业务场景的区分度是不一样的，不存在一个普适的算法可以解决所有业务场景存在的问题</font></strong>，如上述的FastUnfolding、node2vec在某些特定的业务场景下效果可以比GraphSAGE的效果更好，所以在面临具体问题的时候，需要结合场景作算法选择以及优化；</li>
<li><strong>在工业界落地的算法通常比较直接、明了，这样的算法往往效果更好</strong>。</li>
</ul>
<h3><span id="五-graphsage应用">五、GraphSAGE应用</span></h3><p>本例中的训练，评测和可视化的完整代码在下面的git仓库中</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/shenweichen/GraphNeuralNetwork">shenweichen/GraphNeuralNetworkgithub.com/shenweichen/GraphNeuralNetwor</a></p>
<p><strong>这里我们使用引文网络数据集Cora进行测试，Cora数据集包含2708个顶点, 5429条边,每个顶点包含1433个特征，共有7个类别。</strong></p>
<p>按照论文的设置，从<strong>每个类别中选取20个共140个顶点作为训练</strong>，<strong>500个顶点作为验证集合</strong>，<strong>1000个顶点作为测试集</strong>。 <strong>采样时第1层采样10个邻居，第2层采样25个邻居。</strong></p>
<ul>
<li>节点分类任务结果</li>
</ul>
<p>通过多次运行准确率在0.80-0.82之间。</p>
<ul>
<li>节点向量可视化</li>
</ul>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191533940.jpg" alt="img" style="zoom:50%;"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/VSDR5Z/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/VSDR5Z/" class="post-title-link" itemprop="url">风控反欺诈（3）Fraudar：二部图反欺诈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-30 13:32:34" itemprop="dateCreated datePublished" datetime="2022-06-30T13:32:34+08:00">2022-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:36:23" itemprop="dateModified" datetime="2023-04-19T15:36:23+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/" itemprop="url" rel="index"><span itemprop="name">工业落地</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E4%B8%9A%E8%90%BD%E5%9C%B0/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">业务安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="fraudar二部图反欺诈">Fraudar：二部图反欺诈</span></h2><blockquote>
<p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/172423556">Fraudar：二部图反欺诈</a></p>
<p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/369534469">图异常簇检测：<em>FRAUDAR</em></a></p>
<p>  <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/528366101">京东图计算团队：一文读懂电商广告作弊与反作弊</a></p>
<p>  <strong>图异常检测系列文章：</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348278101">图异常点检测：OddBall</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348713075">图异常簇检测：LOCKINFER</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/369534469">图异常簇检测：FRAUDAR</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/380421374">图异常检测：GDN和Meta-GDN</a></li>
</ol>
</blockquote>
<p>可以说电商的发展，滋生并带火了一个由出资店铺、刷单中介、各级代理、刷手、空包物流组成的刷单产业。</p>
<h3><span id="一-黑产与反欺诈">一、黑产与反欺诈</span></h3><h4><span id="关系网络与二部图"><strong>关系网络与二部图</strong></span></h4><p><strong>不同于对个体自身特征的分析，网络提供了对多个对象的关系之间另一种看问题的视角</strong>。把对象看做结点，把交互看成边，对象间的发生的各种关联自然会构成一张关系网络。<strong>从图论的角度出发，根据结点属性的不同可以把网络分为同构图和异构图</strong>。同构图是由同一种结点组成的关系网络，如家庭亲属关系、社交好友关系、论文间的引用关系等。历史上对于同构图的网络表示有很多研究，早在十九世纪就形成了几何拓扑学这一数学分支。在现代的同构关系研究中也逐步提出了基于网页链接的谷歌PageRank网页评级、基于结点关系紧密度的Louvian社区发现等重要算法。<strong>不过异构图在生活中的表现更为广泛，异构图是由不同属性的结点组成的关系网络，如由买方卖方以及中介组成的交易网络、由大V和其关注者组成的关注网络、由手机号\地址\证件号\IP地址组成的复杂关系网络等。</strong>二部图（也叫二分图）是异构网络的一种，它由两类结点组成，并且同类结点之间通常没有关联。前述的刷单欺诈，即是以<strong>出资店铺</strong>和<strong>刷手</strong>这两类结点组成的<strong>交易关系二部图</strong>。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191534576.jpg" alt="img" style="zoom: 67%;"></p>
<h4><span id="二部图下的欺诈"><strong>二部图下的欺诈</strong></span></h4><p>两类结点组成的欺诈场景还可以举出很多例子，如电商场景下<strong>用户对商户的薅羊毛、刷好评</strong>，如<strong>社交场景下水军账号的虚假关注、转发</strong>，又如<strong>消金场景下用户与商户勾结对平台的消费贷套现欺诈</strong>。<strong><font color="red"> 这些行为都会使两类结点之间出现异常的连接分布，从整体网络看来其呈现出了一张致密的双边连接子图，且该子图内的结点与图外结点联系相对较少</font></strong>。我们把这种大量的、同步的非正常关联行为模式称之为Lockstep，即在本不应出现聚集行为的二部图自然关系网络中，出现了双边聚集性行为。</p>
<p>只要能把欺诈行为总结成一种模式，自然可以将其分离出来。但是欺诈者往往会对自己做出某种伪装以使自己看起来有向好的一面，意图绕过风控系统。如在刷单欺诈场景下，<strong>为了尽量贴近真实用户的购买习惯，刷单平台会对刷手提出一系列要求</strong>，比如要求货比三家、要求最低浏览时长、要求滚动浏览高度及停留时间、要求对于正常热销商品做一定购买等，这些行为都会导致风控经验指标和模型特征的部分失效。在二部图交易网络中，对于正常热销商品的购买体现为刷手为自己增加了一些优异的边连接，使自己看起来更像一个正常的消费者结点。<strong><font color="red"> 我们需要一种能从这种复杂关系网络中对抗伪装、抽丝剥茧的提取出异常致密子图的算法。</font></strong>接下来对症下药引入Fraudar。<strong>Fraudar算法来源于2016年的KDD会议，并获得了当年的最佳论文奖。</strong></p>
<h3><span id="二-fraudar算法介绍-无监督异常簇检测">二、<strong>Fraudar算法介绍</strong>- 无监督异常簇检测</span></h3><blockquote>
<p>  <a href="https://link.zhihu.com/?target=https%3A//dl.acm.org/doi/pdf/10.1145/2939672.2939747">FRAUDAR: Bounding Graph Fraud in the Face of Camouflagedl.acm.org/doi/pdf/10.1145/2939672.2939747</a></p>
</blockquote>
<p><strong>简单来说，Fraudar定义了一个可以表达结点平均可疑度的全局度量G(·)</strong>，在逐步贪心移除可疑度最小结点的迭代过程中，使G(·)达到最大的留存结点组成了可疑度最高的致密子图。接下来我们稍微细化一下算法过程，以刷单交易场景为例（定义二部图结点集合S=[A,B]，其中A、B分别代表消费者和店铺的结点集合），看Fraudar是如何从交易网络剥离出刷手和其出资店铺的。</p>
<p>网络水军、刷量刷单等行为在互联网中屡见不鲜，如何检测网络中的该类行为，即<strong>异常簇，</strong>是值得研究的问题。<strong>本文介绍一种图异常簇检测方案-FRAUDAR，该方法在具有14.7亿条边的Twitter社交网络中成功检测出了一系列刷量账户。</strong></p>
<h4><span id="21-论文贡献"><strong>2.1 论文贡献</strong></span></h4><ol>
<li>提出了一组满足公理的指标，且兼具多种优点。</li>
<li>提出了一个可证明的界限，即某个欺诈账户可以在图中有多少欺诈行为而不被抓获，即使是在伪装的情况下。接着通过新的优化改进了该界限，使其能够更好地区分真实数据中的欺诈行为和正常行为。</li>
<li>该算法在超大规模的Twitter网络中被证明了是有效的且能够在<strong>接近线性时间复杂度</strong>内完成任务。</li>
</ol>
<h4><span id="22-欺诈行为的特点">2.2 欺诈行为的特点</span></h4><p>网络中存在不少水军刷量刷单的现象，该类欺诈行为在社交网络中尤其显著，其中”刷量者”可称为<strong>follower</strong>，”刷单目标”可以称为<strong>followee。</strong>下图展示了Twitter中的“僵尸粉”购买服务案例：左图红色和蓝色颜色的柱子分别代表了正常用户和欺诈用户，用户所属的两个柱子中左柱子表示followee的数量，右柱子表示follower的数量；右图展示了某个刷量账号，其个人简介中表示“只要你follow他那么他就会follow你”。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191534862.jpg" alt="img" style="zoom:50%;"></p>
<p>欺诈行为在网络的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=邻接矩阵&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;369534469&quot;}">邻接矩阵</a>视角下具有显著特征，某些“聪明”的刷量分子为了逃避检测往往会采取伪装（camouflage）来让自己看起来更像普通用户。下图从左到右分别展示了邻接矩阵中的随机伪装者、偏置伪装者和被劫持账户参与刷量行为。</p>
<h4><span id="23-fraudar算法">2.3 FRAUDAR算法</span></h4><p>FRAUDAR算法基于二部图表示，即网络中存在两种类型的节点Users和Objects。文中假设可能存在一个或多个User受到相关某个实体的控制，进而与Objects的某个子集交互而产生连边。算法所需的符号表示如下：</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191535249.jpg" alt="img" style="zoom:50%;"></p>
<p>算法的目标是找到一个 $S$, 并使得 $S$ 构成子图的嫌疑指标 $g(S)$ 最大。</p>
<p>子图内节点嫌疑度，即密集度指标 (density metrics) 可描述为： $g(S)=\frac{f(S)}{|S|}$</p>
<p>子图总嫌疑度 (total suspiciousness) 可描述为: </p>
<script type="math/tex; mode=display">
\begin{aligned} f(S) & =f_\nu(S)+f_{\varepsilon}(S) \\ & =\sum_{i \in S} a_i+\sum_{i, j \in S \wedge(i, j) \in \varepsilon} c_{i j}\end{aligned}</script><p>其中, $a<em>i$ 和 $c</em>{i j}$ 都是大于 0 的常数, $a<em>i$ 即某个节点 $i$ 的嫌疑度, 而 $c</em>{i j}=\frac{1}{\log \left(d_j+c\right)}$ 可即边 $(i, j)$ 的嫌疑度, $d_j$ 表示Object $j$ 的度, $c$ 是一个较小的常量。</p>
<p><strong>由此，FRAUDAR算法可描述为如下过程</strong>：</p>
<ol>
<li>将优先级最高的节点移出二部图</li>
<li>更新与移出节点相关的节点可疑度</li>
<li>反复执行步骤1和步骤2，直至所有节点都被移出</li>
<li>最后比较各轮迭代中节点的可疑度，找到最大可疑度对应的子图</li>
</ol>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191535525.jpg" alt="img" style="zoom:50%;"></p>
<p>算法中有如下两点值得注意：</p>
<p><strong>1. 如何构造<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=优先树&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;369534469&quot;}">优先树</a></strong></p>
<p>优先树本质上是一个小顶堆，其叶子节点为二部图中的Users或Objects，排序规则依赖于节点的嫌疑度。由此，根结点将记录全局嫌疑度最小的节点，将根节点从二部图中移出使得新子图中的节点具有最大的平均嫌疑度。</p>
<p><strong>2. 如何更新可疑度</strong></p>
<p>删除网络中的节点导致<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=二部图&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;article&quot;%2C&quot;sourceId&quot;%3A&quot;369534469&quot;}">二部图</a>结构被改变，因此每轮迭代后都需要在保持边可疑度不变的前提下，更新与被删除节点相关的节点可疑度，即相关节点减去被删节点的嫌疑度。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/1RE0J1S/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/1RE0J1S/" class="post-title-link" itemprop="url">风控算法（3）阿里云-风险商品图算法识别</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-30 13:16:10" itemprop="dateCreated datePublished" datetime="2022-06-30T13:16:10+08:00">2022-06-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-18 20:40:22" itemprop="dateModified" datetime="2023-04-18T20:40:22+08:00">2023-04-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">算法比赛</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AE%97%E6%B3%95%E6%AF%94%E8%B5%9B/%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">业务安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="阿里安全-icdm-2022大规模电商图上的风险商品检测赛">【阿里安全 × ICDM 2022】大规模电商图上的风险商品检测赛</span></h2><blockquote>
<ul>
<li><p><strong>比赛链接</strong>：Https://tianchi.aliyun.com/competition/entrance/531976/introduction</p>
</li>
<li><p>ICDM 2022: Risk Commodities Detection on Large-Scale E-Commence Graphs：<a target="_blank" rel="noopener" href="https://github.com/EdisonLeeeee/ICDM2022_competition_3rd_place_solution">https://github.com/EdisonLeeeee/ICDM2022_competition_3rd_place_solution</a></p>
</li>
<li><p>ICDM2022大规模电商图上的风险商品检测比赛（第六名）：<a target="_blank" rel="noopener" href="https://github.com/JaySaligia/SGHQS">https://github.com/JaySaligia/SGHQS</a></p>
</li>
<li><strong>ICDM 2022 : 大规模电商图上的风险商品检测 — top1方案分享+代码</strong>：<a target="_blank" rel="noopener" href="https://github.com/fmc123653/Competition/tree/main/ICDMCup2022-top1">https://github.com/fmc123653/Competition/tree/main/ICDMCup2022-top1</a></li>
<li><strong>【论文笔记】KGAT：融合知识图谱的 CKG 表示 + 图注意力机制的推荐系统</strong>：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/364002920">https://zhuanlan.zhihu.com/p/364002920</a></li>
</ul>
</blockquote>
<h3><span id="一-黑灰产vs风控系统">一、<strong>黑灰产VS风控系统</strong></span></h3><p>近年来，图计算尤其是图神经网络等技术获得了快速的发展以及广泛的应用。</p>
<p>在电商平台上的风险商品检测场景中，<strong>黑灰产和风控系统</strong>之间存在着<strong>激烈的对抗</strong>，黑灰产为了躲避平台管控，会蓄意掩饰风险信息，通过引入场景中存在的图数据，可以缓解因黑灰产对抗带来的检测效果下降。</p>
<p>在实际应用中，图算法的效果往往和图结构的质量紧密相关，由于风险商品检测场景中对抗的存在，<strong>恶意用户会通过伪造设备、伪造地址等方式，伪造较为“干净”的关联关系</strong>。<strong><font color="red"> 如何能够在这种存在着大量噪声的图结构数据中充分挖掘风险信息，是一个十分有挑战性的问题，另外该场景中还存在着黑白样本严重不均衡、图结构规模巨大且异构等多种挑战</font></strong>。</p>
<h3><span id="二-赛题背景">二、赛题背景</span></h3><p>在电商平台上，商品是最主要的内容之一。风险商品检测旨在识别平台上存在的假货商品、违禁商品等，对维护平台内容信息健康、保护消费者权益起着至关重要的作用。</p>
<p>风险商品检测和其他风控领域一样，<strong>面临风险的对抗和变异</strong>，如对商品风险内容的刻意隐藏等，而使用平台广泛存在的各类图关系数据可以提供更多证据，提升黑灰产的攻击成本。</p>
<p>本次比赛提供了<strong>阿里巴巴平台来源于真实场景的风险商品检测数据</strong>，需要参赛者利用大规模的异构图结构以及比例不均衡的黑白样本，利用图算法，检测出风险商品。</p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182039050.png" alt="图片"></p>
<h3><span id="三-结题思路">三、结题思路</span></h3><h4><span id="31-deepfm模型">3.1 DeepFM模型</span></h4><p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182039128.jpg" alt="img"></p>
<p><strong><font color="red"> 低阶和高阶特征选择</font></strong></p>
<h4><span id="32-序列模型">3.2 序列模型</span></h4><p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304182040137.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/v2-1e23798979f03dd7369306c91df35042_b.jpg" alt="img"></p>
<h4><span id="33-图模型">3.3 图模型</span></h4><p><img src="https://pic4.zhimg.com/v2-526f68f85c8b9d6116039bf2b98f3403_b.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/v2-9eadc122d63374a77d5090b3f62a8ff3_b.jpg" alt="img"></p>
<p><img src="https://pic4.zhimg.com/v2-4602cba212d520cb5babfde5865856a7_b.jpg" alt="img"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://powerlzy.github.io/posts/1J98PCJ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cat_mac.jpg">
      <meta itemprop="name" content="lzy">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PowerLZY's Blog">
      <meta itemprop="description" content="相比到达的地方，同行的人更重要！">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | PowerLZY's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/1J98PCJ/" class="post-title-link" itemprop="url">恶意软件检测（9）Forecasting Malware Capabilities From Cyber Attack Memory Images</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-24 12:15:11" itemprop="dateCreated datePublished" datetime="2022-06-24T12:15:11+08:00">2022-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-04-19 15:50:55" itemprop="dateModified" datetime="2023-04-19T15:50:55+08:00">2023-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/" itemprop="url" rel="index"><span itemprop="name">学术前沿</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E6%9C%AF%E5%89%8D%E6%B2%BF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2><span id="forecasting-malware-capabilities-from-cyber-attack-memory-images">Forecasting Malware Capabilities From Cyber Attack Memory Images</span></h2><blockquote>
<ul>
<li>项目：<a target="_blank" rel="noopener" href="https://www.usenix.org/conference/usenixsecurity21/presentation/alrawi-forecasting">https://www.usenix.org/conference/usenixsecurity21/presentation/alrawi-forecasting</a></li>
<li>文章：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1907.07352">https://arxiv.org/abs/1907.07352</a></li>
</ul>
</blockquote>
<h3><span id="摘要">摘要</span></h3><p>正在进行的网络攻击的补救依赖于及时的恶意软件分析，其目的是发现尚未执行的恶意功能。不幸的是，这需要在不同工具之间重复切换上下文，并且会给分析员带来很高的认知负荷，从而减慢调查速度，并给攻击者带来优势。<strong>我们提出了Forecast，这是一种事后检测技术，可使事件响应者自动预测恶意软件的执行能力。预测基于概率模型，该模型允许预测发现能力，并根据其相对执行可能性（即预测）对每个能力进行权衡</strong>。<strong><font color="red"> Forecast利用当前攻击的执行上下文（来自恶意软件的内存映像）来指导恶意软件代码的符号分析。</font></strong>我们进行了广泛的评估，有6727个真实世界的恶意软件和旨在颠覆预测的未来主义攻击，显示了预测恶意软件能力的准确性和鲁棒性。</p>
<blockquote>
<p>  Forecast is based on a probabilistic model that allows Forecast to discover capabilities and also weigh each capability according to its relative likelihood of execution</p>
</blockquote>
<h3><span id="一-说明">一、说明</span></h3><p>网络攻击响应需要对抗阶段性恶意软件功能（即尚未执行的恶意功能），以防止进一步的损害[1]、[2]。不幸的是，检测后预测恶意软件功能仍然是手动的、繁琐的和容易出错的。目前，分析师必须重复执行多个分类步骤。例如，分析员通常会将二进制文件加载到静态反汇编程序中，并执行内存取证，以组合静态和动态工件。这一艰苦的过程需要在二进制分析和取证工具之间进行上下文切换。因此，它给分析员带来了很高的认知负荷，减慢了调查速度，给攻击者带来了优势。</p>
<p><strong>为了自动化事件响应，符号执行很有可能用于恶意软件代码探测，但缺少先前的攻击执行状态，而这种状态在事后可能无法重新实现（例如，来自C&amp;C活动的具体输入）</strong>。特定于环境的条件（如预期的C&amp;C命令）限制了动态和协同技术（如[3]–[14]）预测无法访问的能力。此外，这些技术依赖于剖析独立恶意软件二进制文件或在沙箱中运行它。然而，已知恶意软件会删除其二进制文件或将自身锁定为仅在受感染的计算机上运行（硬件锁定）。<strong>更糟糕的是，研究人员发现，无文件恶意软件事件（即，仅驻留在内存中）继续增加[1]、[15]、[16]</strong>。</p>
<p>有权访问正确的执行上下文对于引导恶意软件显示其功能是必要的。恶意软件在内部收集来自特定环境源的输入，例如注册表、网络和环境变量，以便做出行为决策【11】、【17】、【18】。因此，恶意软件的理想和实用输入公式可以根据内存中的该内部执行状态进行调整，其中包含已收集的输入工件。<strong>事实证明，在检测到恶意进程后，反病毒和IDS已经收集了该进程的内存映像。恶意软件内存映像包含被调查的特定攻击实例特有的这种内部具体执行状态。</strong></p>
<p><strong><font color="red"> 在我们的研究过程中，我们注意到，如果我们可以在内存图像中设置代码和数据页的动画，并根据捕获的快照执行向前的代码探索，那么我们就可以重用这些早期的具体执行数据来推断恶意软件的下一步。</font></strong>此外，通过分析这些具体输入如何在代码探索期间诱导路径，我们可以根据恶意软件捕获的执行状态预测哪些路径更有可能执行功能。基于这一思想，<strong><font color="red"> 我们提出用通过内存图像取证获得的具体执行状态对恶意软件的预阶段路径进行符号探索。</font></strong>通过这一点，我们克服了分析员之前必须进行的艰苦而繁重的认知过程。</p>
<p><strong>我们介绍了Forecast，这是一种后检测技术，使事件响应者能够从捕获的内存图像中预测可能的功能。Forecast根据发现的每个功能的执行概率（即预测）对其进行排序，以使分析师能够确定其修复工作流的优先级。</strong>为了计算这种概率，Forecast会衡量每条路径对具体数据的相对使用情况。这种方法基于内存映像执行状态的具体程度（或DC）的形式化模型。Forecast从内存映像中的最后一个指令指针（IP）值开始，通过象征性地执行每条指令的CPU语义来探索每条路径。在此探索过程中，预测建模符号和具体数据的混合如何影响路径生成和选择。基于这种混合，沿路径计算每个状态的“具体性”分数，以得出每个发现能力的预测百分比。DC（s）还通过动态调整循环边界、处理符号控制流和修剪路径来优化符号分析，以减少路径爆炸。</p>
<p>为了自动识别每个功能，我们开发了几个模块化的功能分析插件：<strong>代码注入、文件过滤、滴管、持久性、键和屏幕监视、反分析和C&amp;C URL连接</strong>。每个插件根据API序列、它们的参数以及它们的输入和输出约束如何连接每个API来定义一个给定的功能。Forecast插件是可移植的，可以很容易地扩展以捕获基于目标系统API的其他功能。值得注意的是，Forecast的分析只需要一个法医记忆图像，允许它对无文件恶意软件工作，使其非常适合事件响应。</p>
<p>我们使用涵盖274个家族的6727个真实恶意软件（包括打包和解包）的内存图像评估Forecast。与人工专家手动生成的报告相比，Forecast可提供准确的能力预测。此外，我们还表明，Forecast对旨在颠覆Forecast的未来主义攻击具有鲁棒性。我们表明，预测的检测后预测是由早期的具体输入准确诱导的。我们将预测与S2E【6】、angr【22】和Triton【23】进行了经验比较，发现预测在识别能力和减少路径爆炸方面优于它们。预测可在线访问：<a target="_blank" rel="noopener" href="https://cyfi.ece.gatech.edu/">https://cyfi.ece.gatech.edu/</a>.</p>
<blockquote>
<p>  “S2E: A platform for in-vivo multi-path analysis of software systems,” 2011</p>
<p>  “SoK: (State of) The Art of War: Offensive Techniques in Binary Analysis,” 2016</p>
<p>  “Triton: A Dynamic Symbolic Execution Framework” 2015</p>
</blockquote>
<h3><span id="二-概述">二、概述</span></h3><p>本节介绍了结合<strong>记忆图像取证和符号分析技术</strong>的挑战和好处。以<strong>DarkHotel事件</strong>[2]为例，我们将展示事件响应者如何利用预测加快调查并补救网络攻击。</p>
<p><strong><font color="red"> 运行示例：DarkHotel APT。</font></strong>DarkHotel是一种APT，通过矛式网络钓鱼攻击C&amp;C服务器【2】。感染后，DarkHotel会从受害者的文件系统中删除其二进制文件，与C&amp;C服务器通信，将线程注入Windows资源管理器，并最终过滤侦察数据。当IDS检测到受感染主机上的异常活动时，终端主机代理会捕获可疑进程内存（即DarkHotel内存），终止其执行，并生成通知。<strong>此时，事件响应者必须从不同的可用取证来源（网络日志、事件日志、内存快照等）快速了解DarkHotel的能力，以防止进一步的损坏。</strong></p>
<p>动态技术【11】–【14】可能需要一个激活的C&amp;C以诱使恶意软件二进制文件显示其功能，然而该C&amp;C可能已被取下。由于DarkHotel只驻留在内存中，这些通过在沙盒中运行恶意软件而起作用的技术无法应用。</p>
<ul>
<li><strong>只有内存图像，分析员可以使用取证工具，如Volatility</strong>【24】，来“切割”内存图像代码和数据页。基于提取的代码页，符号分析可以模拟恶意软件的执行，以探索所有潜在的路径。</li>
<li>不幸的是，现有的符号工具需要一个格式正确的二进制文件，并且没有针对内存图像进行优化[7]、[22]、[23]。</li>
</ul>
<p><strong>理想情况下，分析员可以手动将这些代码片段投影到符号分析中，并从数据页中获取具体值，以告诉哪一个代码分支会导致某个功能</strong>。然而，这种用提取的内存工件“缝合”代码的来回过程涉及符号执行和取证工具之间的上下文切换。这给分析员带来了很高的认知负担。<strong>分析员还必须处理路径爆炸、API调用模拟[4]、[22]、[25]–[27]和具体化API参数（例如攻击者的URL）等挑战，这些挑战可能无法在内存映像中静态访问</strong>。最后，分析师必须沿每条路径手动检查API，以推断高级功能。</p>
<h4><span id="21混合事件响应">2.1混合事件响应</span></h4><p>事件响应者依靠内存取证来识别内存图像中的攻击瑕疵。然而，仅仅是基于签名的记忆取证，由于高漏报率，会遗漏重要的数据结构【21】。另一方面，符号执行可以正向探索代码，但会遇到路径爆炸等问题[22]。为了解决这些限制，Forecast通过反馈循环将符号执行和内存取证结合起来，以解决这两种技术的缺点。</p>
<p><strong>上下文感知记忆取证</strong>。符号分析提供代码探索上下文，以准确识别内存取证遗漏的数据构件。例如，DarkHotel内存图像的传统法医解析遗漏了C&amp;C URL字符串，因为它们通过自定义编码方案进行了混淆。然而，对引用这些字节作为参数的指令（如strncpy API）进行的后续符号分析允许Forecast正确识别和利用内存映像中的这些数据瑕疵。此外，有针对性的恶意软件可能会采用旨在颠覆预测的策略，使用反取证和反符号分析，这是我们在设计和评估中仔细考虑的。</p>
<p>内存图像取证提供了具体的输入，可以帮助符号分析执行地址具体化、控制流解析和循环边界。此外，内存取证可以识别内存中加载的库地址，从而允许Forecast执行库函数模拟。</p>
<p>路径概率。给定一个内存映像，目标是利用可用的具体数据来探索潜在的代码路径，并预测沿途的功能。通过分析具体内存图像数据是如何产生不同路径的，Forecast可以得出一条路径相对于其他路径达到某种能力的概率。Forecast基于建模具体和符号数据操作如何影响路径生成和选择来计算此概率。Forecast还利用此概率度量作为一种启发式方法来修剪具有最少具体数据的路径。</p>
<h4><span id="22-incident-response-with-forecast">2.2 Incident Response with Forecast</span></h4><p><strong>Forecast可识别来自自动管道中恶意软件内存映像的功能</strong>。为了证明这一点，我们模拟了DarkHotel的攻击和内存捕获，其中包括使用DarkHotel的网络签名设置IDS并执行高级持久性威胁（APT）。检测完成后，IDS向终端host agent发出信号，以捕获DarkHotel进程内存。然后，我们输入该内存图像进行预测以进行分析。在459秒内，<strong><font color="red"> Forecast显示了DarkHotel的功能：C&amp;C通信（即mse.vmmnat.com）、文件过滤（即主机信息）和代码注入（即注入Windows Explorer）。</font></strong></p>
<p><img src="https://lzy-picture.oss-cn-beijing.aliyuncs.com/img/202304191550504.png" alt="image-20220624145017568"></p>
<p>处理法医记忆图像有六个阶段，如图1所示。1 Forecast以取证方式解析内存映像，并通过将最后一个CPU和内存状态加载到符号环境中进行分析来重建先前的执行上下文。在分析内存映像时，Forecast检查加载的库，以识别导出的函数名和地址。接下来，2 Forecast继续探索可能的路径，利用内存映像中可用的具体数据来具体化路径约束。3预测模型和权重每个路径如何由具体数据归纳，并为每个生成的路径分配概率。4 Forecast然后使用此概率作为权重来调整循环边界并修剪错误路径，从而允许Forecast缩小诱导能力相关路径的范围。5 Forecast将已识别的API与功能分析插件库相匹配，以向分析师报告功能。最后，6 Forecast确定了三种能力，并从路径概率中得出了它们的预测百分比，分别为31%、15%和54%。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lzy</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>-->
<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>

    </div>
  </footer>

  

  <a href="https://github.com/PowerLZY" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/9.4.3/mermaid.min.js","integrity":"sha256-e0o3JYsdjqKajf9eOe22FhioYSz9WofRY4dLKo3F6do="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>


  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>




        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'powerlzy.github.io' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>
</html>
